{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/location.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error/module-errors.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error/to-node-description.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error/standard-errors.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error/strict-mode-errors.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error/pipeline-operator-errors.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parse-error.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/estree.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/tokenizer/context.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/tokenizer/types.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/babel-helper-validator-identifier/src/identifier.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/babel-helper-validator-identifier/src/keyword.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/identifier.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/scope.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/flow/scope.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/base.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/comments.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/whitespace.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/tokenizer/state.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/babel-helper-string-parser/src/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/tokenizer/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/class-scope.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/expression-scope.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/util/production-parameter.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/util.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/node.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/flow/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/jsx/xhtml.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/jsx/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/typescript/scope.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/lval.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/typescript/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/placeholders.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugins/v8intrinsic.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/plugin-utils.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/options.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/expression.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/statement.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/parser/index.ts", "../../../node_modules/.pnpm/@babel+parser@7.23.6/node_modules/@babel/parser/src/index.ts", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/base64.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/base64-vlq.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/util.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/array-set.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/mapping-list.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/source-map-generator.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/binary-search.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/quick-sort.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/source-map-consumer.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/lib/source-node.js", "../../../node_modules/.pnpm/source-map-js@1.0.2/node_modules/source-map-js/source-map.js", "../src/index.ts", "../../reactivity/src/operations.ts", "../../shared/src/makeMap.ts", "../../shared/src/general.ts", "../../shared/src/patchFlags.ts", "../../shared/src/slotFlags.ts", "../../shared/src/globalsAllowList.ts", "../../shared/src/codeframe.ts", "../../shared/src/normalizeProp.ts", "../../shared/src/domTagConfig.ts", "../../shared/src/domAttrConfig.ts", "../../shared/src/looseEqual.ts", "../../shared/src/toDisplayString.ts", "../../reactivity/src/warning.ts", "../../reactivity/src/effectScope.ts", "../../reactivity/src/dep.ts", "../../reactivity/src/effect.ts", "../../reactivity/src/baseHandlers.ts", "../../reactivity/src/collectionHandlers.ts", "../../reactivity/src/reactive.ts", "../../reactivity/src/ref.ts", "../../reactivity/src/computed.ts", "../../runtime-core/src/warning.ts", "../../runtime-core/src/errorHandling.ts", "../../runtime-core/src/scheduler.ts", "../../runtime-core/src/hmr.ts", "../../runtime-core/src/devtools.ts", "../../runtime-core/src/compat/compatConfig.ts", "../../runtime-core/src/componentEmits.ts", "../../runtime-core/src/componentRenderContext.ts", "../../runtime-core/src/componentRenderUtils.ts", "../../runtime-core/src/apiWatch.ts", "../../runtime-core/src/directives.ts", "../../runtime-core/src/components/BaseTransition.ts", "../../runtime-core/src/apiDefineComponent.ts", "../../runtime-core/src/apiAsyncComponent.ts", "../../runtime-core/src/components/KeepAlive.ts", "../../runtime-core/src/apiLifecycle.ts", "../../runtime-core/src/helpers/resolveAssets.ts", "../../runtime-core/src/helpers/renderList.ts", "../../runtime-core/src/helpers/createSlots.ts", "../../runtime-core/src/helpers/renderSlot.ts", "../../runtime-core/src/helpers/toHandlers.ts", "../../runtime-core/src/componentPublicInstance.ts", "../../runtime-core/src/apiSetupHelpers.ts", "../../runtime-core/src/componentOptions.ts", "../../runtime-core/src/apiCreateApp.ts", "../../runtime-core/src/apiInject.ts", "../../runtime-core/src/componentProps.ts", "../../runtime-core/src/componentSlots.ts", "../../runtime-core/src/rendererTemplateRef.ts", "../../runtime-core/src/hydration.ts", "../../runtime-core/src/profiling.ts", "../../runtime-core/src/renderer.ts", "../../runtime-core/src/components/Suspense.ts", "../../runtime-core/src/components/Teleport.ts", "../../runtime-core/src/vnode.ts", "../../runtime-core/src/component.ts", "../../runtime-core/src/apiComputed.ts", "../../runtime-core/src/h.ts", "../../runtime-core/src/helpers/useSsrContext.ts", "../../runtime-core/src/customFormatter.ts", "../../runtime-core/src/helpers/withMemo.ts", "../../runtime-core/src/index.ts", "../../runtime-dom/src/nodeOps.ts", "../../runtime-dom/src/components/Transition.ts", "../../runtime-dom/src/modules/class.ts", "../../runtime-dom/src/directives/vShow.ts", "../../runtime-dom/src/helpers/useCssVars.ts", "../../runtime-dom/src/modules/style.ts", "../../runtime-dom/src/modules/attrs.ts", "../../runtime-dom/src/modules/props.ts", "../../runtime-dom/src/modules/events.ts", "../../runtime-dom/src/patchProp.ts", "../../runtime-dom/src/apiCustomElement.ts", "../../runtime-dom/src/helpers/useCssModule.ts", "../../runtime-dom/src/components/TransitionGroup.ts", "../../runtime-dom/src/directives/vModel.ts", "../../runtime-dom/src/directives/vOn.ts", "../../runtime-dom/src/index.ts", "../src/dev.ts", "../../compiler-core/src/errors.ts", "../../compiler-core/src/runtimeHelpers.ts", "../../compiler-core/src/ast.ts", "../../compiler-core/src/utils.ts", "../../compiler-core/src/parse.ts", "../../compiler-core/src/transforms/hoistStatic.ts", "../../compiler-core/src/transform.ts", "../../compiler-core/src/codegen.ts", "../../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js", "../../compiler-core/src/babelUtils.ts", "../../compiler-core/src/validateExpression.ts", "../../compiler-core/src/transforms/transformExpression.ts", "../../compiler-core/src/transforms/vIf.ts", "../../compiler-core/src/transforms/vFor.ts", "../../compiler-core/src/transforms/vSlot.ts", "../../compiler-core/src/transforms/transformElement.ts", "../../compiler-core/src/transforms/transformSlotOutlet.ts", "../../compiler-core/src/transforms/vOn.ts", "../../compiler-core/src/transforms/vBind.ts", "../../compiler-core/src/transforms/transformText.ts", "../../compiler-core/src/transforms/vOnce.ts", "../../compiler-core/src/transforms/vModel.ts", "../../compiler-core/src/transforms/vMemo.ts", "../../compiler-core/src/compile.ts", "../../compiler-core/src/transforms/noopDirectiveTransform.ts", "../../compiler-dom/src/runtimeHelpers.ts", "../../compiler-dom/src/decodeHtmlBrowser.ts", "../../compiler-dom/src/parserOptions.ts", "../../compiler-dom/src/transforms/transformStyle.ts", "../../compiler-dom/src/errors.ts", "../../compiler-dom/src/transforms/vHtml.ts", "../../compiler-dom/src/transforms/vText.ts", "../../compiler-dom/src/transforms/vModel.ts", "../../compiler-dom/src/transforms/vOn.ts", "../../compiler-dom/src/transforms/vShow.ts", "../../compiler-dom/src/transforms/Transition.ts", "../../compiler-dom/src/transforms/ignoreSideEffectTags.ts", "../../compiler-dom/src/index.ts"],
  "sourcesContent": ["export type Pos = {\n  start: number;\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nexport class Position {\n  line: number;\n  column: number;\n  index: number;\n\n  constructor(line: number, col: number, index: number) {\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\n\nexport class SourceLocation {\n  start: Position;\n  end: Position;\n  filename: string;\n  identifierName: string | undefined | null;\n\n  constructor(start: Position, end?: Position) {\n    this.start = start;\n    // (may start as null, but initialized later)\n    this.end = end;\n  }\n}\n\n/**\n * creates a new position with a non-zero column offset from the given position.\n * This function should be only be used when we create AST node out of the token\n * boundaries, such as TemplateElement ends before tt.templateNonTail. This\n * function does not skip whitespaces.\n */\nexport function createPositionWithColumnOffset(\n  position: Position,\n  columnOffset: number,\n) {\n  const { line, column, index } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\n\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\n\nexport default {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code,\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code,\n  },\n} satisfies ParseErrorTemplates;\n", "const NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\",\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\",\n};\n\ntype NodeTypesWithDescriptions = keyof Omit<\n  typeof NodeDescriptions,\n  \"UpdateExpression\"\n>;\n\ntype NodeWithDescription =\n  | {\n      type: \"UpdateExpression\";\n      prefix: boolean;\n    }\n  | {\n      type: NodeTypesWithDescriptions;\n    };\n\n// @ts-expect-error prefix is specified only when type is UpdateExpression\n// eslint-disable-next-line no-confusing-arrow\nconst toNodeDescription = ({ type, prefix }: NodeWithDescription) =>\n  type === \"UpdateExpression\"\n    ? NodeDescriptions.UpdateExpression[String(prefix) as \"true\" | \"false\"]\n    : NodeDescriptions[type];\n\nexport default toNodeDescription;\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\nimport toNodeDescription from \"./to-node-description.ts\";\n\nexport type LValAncestor =\n  | { type: \"UpdateExpression\"; prefix: boolean }\n  | {\n      type:\n        | \"ArrayPattern\"\n        | \"AssignmentExpression\"\n        | \"CatchClause\"\n        | \"ForOfStatement\"\n        | \"FormalParameters\"\n        | \"ForInStatement\"\n        | \"ForStatement\"\n        | \"ImportSpecifier\"\n        | \"ImportNamespaceSpecifier\"\n        | \"ImportDefaultSpecifier\"\n        | \"ParenthesizedExpression\"\n        | \"ObjectPattern\"\n        | \"RestElement\"\n        | \"VariableDeclarator\";\n    };\n\nexport default {\n  AccessorIsGenerator: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass:\n    \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext:\n    \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier:\n    \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock:\n    \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter:\n    \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext:\n    \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext:\n    \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter:\n    \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField:\n    \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind,\n  }: {\n    kind: \"const\" | \"destructuring\";\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses:\n    \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport:\n    \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport:\n    \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor:\n    \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass:\n    \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace:\n    'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport:\n    \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({ exportName }: { exportName: string }) =>\n    `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  DynamicImportPhaseRequiresImportExpressions: ({ phase }: { phase: string }) =>\n    `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName,\n  }: {\n    localName: string;\n    exportName: string;\n  }) =>\n    `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier:\n    \"'from' is not allowed as an identifier after 'export default'.\",\n\n  ForInOfLoopInitializer: ({\n    type,\n  }: {\n    type: \"ForInStatement\" | \"ForOfStatement\";\n  }) =>\n    `'${\n      type === \"ForInStatement\" ? \"for-in\" : \"for-of\"\n    }' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext:\n    \"Generators can only be declared at the top level or inside a block.\",\n\n  IllegalBreakContinue: ({\n    type,\n  }: {\n    type: \"BreakStatement\" | \"ContinueStatement\";\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n\n  IllegalLanguageModeDirective:\n    \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert:\n    \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.\",\n  ImportBindingIsString: ({ importName }: { importName: string }) =>\n    `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma:\n    \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({ maxArgumentCount }: { maxArgumentCount: 1 | 2 }) =>\n    `\\`import()\\` requires exactly ${\n      maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"\n    }.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault:\n    \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding:\n    'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags:\n    \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({ radix }: { radix: number }) =>\n    `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({ reservedWord }: { reservedWord: string }) =>\n    `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({ identifierName }: { identifierName: string }) =>\n    `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({ ancestor }: { ancestor: LValAncestor }) =>\n    `Invalid optional chaining in the left-hand side of ${toNodeDescription(\n      ancestor,\n    )}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent:\n    \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({ unexpected }: { unexpected: string }) =>\n    `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName,\n  }: {\n    identifierName: string;\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty:\n    \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({ labelName }: { labelName: string }) =>\n    `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment:\n    \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({ missingPlugin }: { missingPlugin: [string] }) =>\n    `This experimental syntax requires enabling the parser plugin: ${missingPlugin\n      .map(name => JSON.stringify(name))\n      .join(\", \")}.`,\n  // FIXME: Would be nice to make this \"missingPlugins\" instead.\n  // Also, seems like we can drop the \"(s)\" from the message and just make it \"s\".\n  MissingOneOfPlugins: ({ missingPlugin }: { missingPlugin: string[] }) =>\n    `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin\n      .map(name => JSON.stringify(name))\n      .join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical:\n    \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType:\n    \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue:\n    \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({ key }: { key: string }) =>\n    `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode,\n  }: {\n    surrogateCharCode: number;\n  }) =>\n    `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(\n      16,\n    )}'.`,\n  ModuleExportUndefined: ({ localName }: { localName: string }) =>\n    `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence:\n    \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar:\n    \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew:\n    \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate:\n    \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor:\n    \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({ identifierName }: { identifierName: string }) =>\n    `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({ identifierName }: { identifierName: string }) =>\n    `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType:\n    \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType:\n    \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType:\n    \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction:\n    \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB:\n    \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault:\n    'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed:\n    \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType:\n    \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody:\n    'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport:\n    \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({ keyword }: { keyword: string }) =>\n    `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator:\n    \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration:\n    \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget:\n    \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator:\n    \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({ reservedWord }: { reservedWord: string }) =>\n    `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected,\n  }: {\n    expected?: string | null;\n    unexpected?: string | null;\n  }) =>\n    `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${\n      expected ? `, expected \"${expected}\"` : \"\"\n    }`,\n  UnexpectedTokenUnaryExponentiation:\n    \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration:\n    \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport:\n    \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport:\n    \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport:\n    \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName,\n  }: {\n    target: string;\n    onlyValidPropertyName: string;\n  }) =>\n    `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator:\n    \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator:\n    \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper:\n    \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern:\n    \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({ identifierName }: { identifierName: string }) =>\n    `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier:\n    \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator:\n    \"Numeric separator can not be used after leading 0.\",\n} satisfies ParseErrorTemplates;\n", "import type { ParseErrorTemplates } from \"../parse-error\";\n\nexport default {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n\n  // `referenceName` is the StringValue[1] of an IdentifierReference[2], which\n  // is represented as just an `Identifier`[3] in the Babel AST.\n  // 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue\n  // 2. https://tc39.es/ecma262/#prod-IdentifierReference\n  // 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier\n  StrictEvalArguments: ({ referenceName }: { referenceName: string }) =>\n    `Assigning to '${referenceName}' in strict mode.`,\n\n  // `bindingName` is the StringValue[1] of a BindingIdentifier[2], which is\n  // represented as just an `Identifier`[3] in the Babel AST.\n  // 1. https://tc39.es/ecma262/#sec-static-semantics-stringvalue\n  // 2. https://tc39.es/ecma262/#prod-BindingIdentifier\n  // 3. https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md#identifier\n  StrictEvalArgumentsBinding: ({ bindingName }: { bindingName: string }) =>\n    `Binding '${bindingName}' in strict mode.`,\n\n  StrictFunction:\n    \"In strict mode code, functions can only be declared at top level or inside a block.\",\n\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n\n  StrictWith: \"'with' in strict mode.\",\n} satisfies ParseErrorTemplates;\n", "import type { ParseErrorTemplates } from \"../parse-error.ts\";\nimport toNodeDescription from \"./to-node-description.ts\";\n\nexport const UnparenthesizedPipeBodyDescriptions = new Set([\n  \"ArrowFunctionExpression\",\n  \"AssignmentExpression\",\n  \"ConditionalExpression\",\n  \"YieldExpression\",\n] as const);\n\ntype GetSetMemberType<T extends Set<any>> = T extends Set<infer M>\n  ? M\n  : unknown;\n\ntype UnparenthesizedPipeBodyTypes = GetSetMemberType<\n  typeof UnparenthesizedPipeBodyDescriptions\n>;\n\nexport default {\n  // This error is only used by the smart-mix proposal\n  PipeBodyIsTighter:\n    \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes:\n    'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound:\n    \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({ token }: { token: string }) =>\n    `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused:\n    \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({ type }: { type: UnparenthesizedPipeBodyTypes }) =>\n    `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n      type,\n    })}; please wrap it in parentheses.`,\n\n  // Messages whose codes start with “Pipeline” or “PrimaryTopic”\n  // are retained for backwards compatibility\n  // with the deprecated smart-mix pipe operator proposal plugin.\n  // They are subject to removal in a future major version.\n  PipelineBodyNoArrow:\n    'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression:\n    \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression:\n    \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused:\n    \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed:\n    \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline:\n    'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n} satisfies ParseErrorTemplates;\n", "import { Position } from \"./util/location.ts\";\nimport type { Undone } from \"./parser/node.ts\";\nimport type { Node } from \"./types.ts\";\n\ntype SyntaxPlugin =\n  | \"flow\"\n  | \"typescript\"\n  | \"jsx\"\n  | \"pipelineOperator\"\n  | \"placeholders\";\n\ntype ParseErrorCode =\n  | \"BABEL_PARSER_SYNTAX_ERROR\"\n  | \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\n\n// Babel uses \"normal\" SyntaxErrors for it's errors, but adds some extra\n// functionality. This functionality is defined in the\n// `ParseErrorSpecification` interface below. We may choose to change to someday\n// give our errors their own full-blown class, but until then this allow us to\n// keep all the desirable properties of SyntaxErrors (like their name in stack\n// traces, etc.), and also allows us to punt on any publicly facing\n// class-hierarchy decisions until Babel 8.\ninterface ParseErrorSpecification<ErrorDetails> {\n  // Look, these *could* be readonly, but then Flow complains when we initially\n  // set them. We could do a whole dance and make a special interface that's not\n  // readonly for when we create the error, then cast it to the readonly\n  // interface for public use, but the previous implementation didn't have them\n  // as readonly, so let's just not worry about it for now.\n  code: ParseErrorCode;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  missingPlugin?: string | string[];\n  loc: Position;\n  details: ErrorDetails;\n\n  // We should consider removing this as it now just contains the same\n  // information as `loc.index`.\n  // pos: number;\n}\n\nexport type ParseError<ErrorDetails> = SyntaxError &\n  ParseErrorSpecification<ErrorDetails>;\n\n// By `ParseErrorConstructor`, we mean something like the new-less style\n// `ErrorConstructor`[1], since `ParseError`'s are not themselves actually\n// separate classes from `SyntaxError`'s.\n//\n// 1. https://github.com/microsoft/TypeScript/blob/v4.5.5/lib/lib.es5.d.ts#L1027\nexport type ParseErrorConstructor<ErrorDetails> = (a: {\n  loc: Position;\n  details: ErrorDetails;\n}) => ParseError<ErrorDetails>;\n\ntype ToMessage<ErrorDetails> = (self: ErrorDetails) => string;\n\ntype ParseErrorCredentials<ErrorDetails> = {\n  code: string;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  toMessage: ToMessage<ErrorDetails>;\n};\n\nfunction defineHidden(obj: object, key: string, value: unknown) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value,\n  });\n}\n\nfunction toParseErrorConstructor<ErrorDetails extends object>({\n  toMessage,\n  ...properties\n}: ParseErrorCredentials<ErrorDetails>): ParseErrorConstructor<ErrorDetails> {\n  type ConstructorArgument = {\n    loc: Position;\n    details: ErrorDetails;\n  };\n\n  return function constructor({ loc, details }: ConstructorArgument) {\n    const error = new SyntaxError();\n    Object.assign(error, properties, { loc, pos: loc.index });\n    if (\"missingPlugin\" in details) {\n      Object.assign(error, { missingPlugin: details.missingPlugin });\n    }\n\n    type Overrides = {\n      loc?: Position;\n      details?: ErrorDetails;\n    };\n    defineHidden(error, \"clone\", function clone(overrides: Overrides = {}) {\n      const { line, column, index } = overrides.loc ?? loc;\n      return constructor({\n        loc: new Position(line, column, index),\n        details: { ...details, ...overrides.details },\n      });\n    });\n\n    defineHidden(error, \"details\", details);\n\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get(this: ParseError<ErrorDetails>): string {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value: string) {\n        Object.defineProperty(this, \"message\", { value, writable: true });\n      },\n    });\n\n    return error as ParseError<ErrorDetails>;\n  };\n}\n\ntype ParseErrorTemplate =\n  | string\n  | ToMessage<any>\n  | { message: string | ToMessage<any>; code?: ParseErrorCode };\n\nexport type ParseErrorTemplates = { [reasonCode: string]: ParseErrorTemplate };\n\n// This is the templated form of `ParseErrorEnum`.\n//\n// Note: We could factor out the return type calculation into something like\n// `ParseErrorConstructor<T extends ParseErrorTemplates>`, and then we could\n// reuse it in the non-templated form of `ParseErrorEnum`, but TypeScript\n// doesn't seem to drill down that far when showing you the computed type of\n// an object in an editor, so we'll leave it inlined for now.\nexport function ParseErrorEnum(a: TemplateStringsArray): <\n  T extends ParseErrorTemplates,\n>(\n  parseErrorTemplates: T,\n) => {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : {}\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : {}\n  >;\n};\n\nexport function ParseErrorEnum<T extends ParseErrorTemplates>(\n  parseErrorTemplates: T,\n  syntaxPlugin?: SyntaxPlugin,\n): {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : {}\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : {}\n  >;\n};\n\n// You call `ParseErrorEnum` with a mapping from `ReasonCode`'s to either:\n//\n// 1. a static error message,\n// 2. `toMessage` functions that define additional necessary `details` needed by\n//    the `ParseError`, or\n// 3. Objects that contain a `message` of one of the above and overridden `code`\n//    and/or `reasonCode`:\n//\n// ParseErrorEnum `optionalSyntaxPlugin` ({\n//   ErrorWithStaticMessage: \"message\",\n//   ErrorWithDynamicMessage: ({ type } : { type: string }) => `${type}`),\n//   ErrorWithOverriddenCodeAndOrReasonCode: {\n//     message: ({ type }: { type: string }) => `${type}`),\n//     code: \"AN_ERROR_CODE\",\n//     ...(BABEL_8_BREAKING ? { } : { reasonCode: \"CustomErrorReasonCode\" })\n//   }\n// });\n//\nexport function ParseErrorEnum(\n  argument: TemplateStringsArray | ParseErrorTemplates,\n  syntaxPlugin?: SyntaxPlugin,\n) {\n  // If the first parameter is an array, that means we were called with a tagged\n  // template literal. Extract the syntaxPlugin from this, and call again in\n  // the \"normalized\" form.\n  if (Array.isArray(argument)) {\n    return (parseErrorTemplates: ParseErrorTemplates) =>\n      ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n\n  const ParseErrorConstructors = {} as Record<\n    string,\n    ParseErrorConstructor<unknown>\n  >;\n\n  for (const reasonCode of Object.keys(argument)) {\n    const template = (argument as ParseErrorTemplates)[reasonCode];\n    const { message, ...rest } =\n      typeof template === \"string\"\n        ? { message: () => template }\n        : typeof template === \"function\"\n          ? { message: template }\n          : template;\n    const toMessage = typeof message === \"string\" ? () => message : message;\n\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage,\n      ...(syntaxPlugin ? { syntaxPlugin } : {}),\n      ...rest,\n    });\n  }\n\n  return ParseErrorConstructors;\n}\n\nexport type RaiseProperties<ErrorDetails> = {\n  at: Position | Undone<Node>;\n} & ErrorDetails;\n\nimport ModuleErrors from \"./parse-error/module-errors.ts\";\nimport StandardErrors from \"./parse-error/standard-errors.ts\";\nimport StrictModeErrors from \"./parse-error/strict-mode-errors.ts\";\nimport PipelineOperatorErrors from \"./parse-error/pipeline-operator-errors.ts\";\n\nexport const Errors = {\n  ...ParseErrorEnum(ModuleErrors),\n  ...ParseErrorEnum(StandardErrors),\n  ...ParseErrorEnum(StrictModeErrors),\n  ...ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),\n};\n\nexport type { LValAncestor } from \"./parse-error/standard-errors.ts\";\n", "import type { TokenType } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type * as N from \"../types.ts\";\nimport type { Node as NodeType, NodeBase, File } from \"../types.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { BindingFlag } from \"../util/scopeflags.ts\";\n\nconst { defineProperty } = Object;\nconst toUnenumerable = (object: any, key: string) =>\n  defineProperty(object, key, { enumerable: false, value: object[key] });\n\nfunction toESTreeLocation(node: any) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n\n  return node;\n}\n\nexport default (superClass: typeof Parser) =>\n  class ESTreeParserMixin extends superClass implements Parser {\n    parse(): File {\n      const file = toESTreeLocation(super.parse());\n\n      if (this.options.tokens) {\n        file.tokens = file.tokens.map(toESTreeLocation);\n      }\n\n      return file;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {\n      let regex: RegExp | null = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral<N.EstreeRegExpLiteral>(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt: BigInt | null;\n      try {\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral<N.EstreeBigIntLiteral>(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal: null = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral<T extends N.Node>(value: any) {\n      // @ts-expect-error ESTree plugin changes node types\n      return this.parseLiteral<T>(value, \"Literal\");\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseStringLiteral(value: any): N.Node {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNumericLiteral(value: any): any {\n      return this.estreeParseLiteral(value);\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseNullLiteral(): N.Node {\n      return this.estreeParseLiteral(null);\n    }\n\n    parseBooleanLiteral(value: boolean): N.BooleanLiteral {\n      return this.estreeParseLiteral(value);\n    }\n\n    // Cast a Directive to an ExpressionStatement. Mutates the input Directive.\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const expression = directive.value as any as N.EstreeLiteral;\n      delete directive.value;\n\n      expression.type = \"Literal\";\n      // @ts-expect-error N.EstreeLiteral.raw is not defined.\n      expression.raw = expression.extra.raw;\n      expression.value = expression.extra.expressionValue;\n\n      const stmt = directive as any as N.ExpressionStatement;\n      stmt.type = \"ExpressionStatement\";\n      stmt.expression = expression;\n      // @ts-expect-error N.ExpressionStatement.directive is not defined\n      stmt.directive = expression.extra.rawValue;\n\n      delete expression.extra;\n\n      return stmt;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        // @ts-expect-error plugin typings\n        this.checkDeclaration((node as unknown as N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return (method as any as N.EstreeProperty | N.EstreeMethodDefinition)\n        .value.params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      allowDirectives: boolean | undefined | null,\n      topLevel: boolean,\n      end: TokenType,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): void {\n      super.parseBlockBody(\n        node,\n        allowDirectives,\n        topLevel,\n        end,\n        afterBlockParse,\n      );\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      // @ts-expect-error estree plugin typings\n      node.body = directiveStatements.concat(node.body);\n      delete node.directives;\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      );\n      if (method.typeParameters) {\n        // @ts-expect-error mutate AST types\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(method);\n    }\n\n    parsePrivateName(): any {\n      const node = super.parsePrivateName();\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return node;\n        }\n      }\n      return this.convertPrivateNameToPrivateIdentifier(node);\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = node as any;\n      delete node.id;\n      // @ts-expect-error mutate AST types\n      node.name = name;\n      // @ts-expect-error mutate AST types\n      node.type = \"PrivateIdentifier\";\n      return node as unknown as N.EstreePrivateIdentifier;\n    }\n\n    isPrivateName(node: N.Node): boolean {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.isPrivateName(node);\n        }\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    getPrivateNameSV(node: N.Node): string {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.getPrivateNameSV(node);\n        }\n      }\n      return node.name;\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseLiteral<T extends N.Literal>(value: any, type: T[\"type\"]): T {\n      const node = super.parseLiteral<T>(value, type);\n      // @ts-expect-error mutating AST types\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseMethod<\n      T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope: boolean = false,\n    ): N.EstreeMethodDefinition {\n      let funcNode = this.startNode<N.MethodLike>();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        // @ts-expect-error todo(flow->ts)\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error mutate AST types\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // @ts-expect-error mutate AST types\n      node.value = funcNode;\n      if (type === \"ClassPrivateMethod\") {\n        node.computed = false;\n      }\n      return this.finishNode(\n        // @ts-expect-error cast methods to estree types\n        node as Undone<N.EstreeMethodDefinition>,\n        \"MethodDefinition\",\n      );\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = super.parseClassProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = super.parseClassPrivateProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      propertyNode.computed = false;\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): N.ObjectMethod | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) as any;\n\n      if (node) {\n        node.type = \"Property\";\n        if ((node as any as N.ClassMethod).kind === \"method\") {\n          node.kind = \"init\";\n        }\n        node.shorthand = false;\n      }\n\n      return node as any;\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startLoc: Position | undefined | null,\n      isPattern: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectProperty | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectProperty(\n        prop,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ) as any;\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node as any;\n    }\n\n    isValidLVal(\n      type: string,\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingFlag,\n    ) {\n      return type === \"Property\"\n        ? \"value\"\n        : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node != null && this.isObjectProperty(node)) {\n        return this.isAssignable(node.value, isBinding);\n      }\n      return super.isAssignable(node, isBinding);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (node != null && this.isObjectProperty(node)) {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableObjectExpressionProp(\n      prop: N.Node,\n      isLast: boolean,\n      isLHS: boolean,\n    ) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(Errors.PatternHasAccessor, { at: prop.key });\n      } else if (prop.method) {\n        this.raise(Errors.PatternHasMethod, { at: prop.key });\n      } else {\n        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n      }\n    }\n\n    finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n      unfinished: Undone<T>,\n      optional: boolean,\n    ): T {\n      const node = super.finishCallExpression(unfinished, optional);\n\n      if (node.callee.type === \"Import\") {\n        (node as N.Node as N.EstreeImportExpression).type = \"ImportExpression\";\n        (node as N.Node as N.EstreeImportExpression).source = node.arguments[0];\n        if (\n          this.hasPlugin(\"importAttributes\") ||\n          this.hasPlugin(\"importAssertions\")\n        ) {\n          (node as N.Node as N.EstreeImportExpression).options =\n            node.arguments[1] ?? null;\n          // compatibility with previous ESTree AST\n          (node as N.Node as N.EstreeImportExpression).attributes =\n            node.arguments[1] ?? null;\n        }\n        // arguments isn't optional in the type definition\n        delete node.arguments;\n        // callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(\n      unfinished: Undone<N.AnyExport>,\n      decorators: N.Decorator[] | null,\n    ) {\n      const exportStartLoc = this.state.lastTokStartLoc;\n      const node = super.parseExport(unfinished, decorators);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          // @ts-expect-error mutating AST types\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            // @ts-expect-error mutating AST types\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            // @ts-expect-error mutating AST types\n            node.type = \"ExportAllDeclaration\";\n            // @ts-expect-error mutating AST types\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n        // fallthrough\n        case \"ExportDefaultDeclaration\":\n          {\n            const { declaration } = node;\n            if (\n              declaration?.type === \"ClassDeclaration\" &&\n              declaration.decorators?.length > 0 &&\n              // decorator comes before export\n              declaration.start === node.start\n            ) {\n              this.resetStartLocation(\n                node,\n                // For compatibility with ESLint's keyword-spacing rule, which assumes that an\n                // export declaration must start with export.\n                // https://github.com/babel/babel/issues/15085\n                // Here we reset export declaration's start to be the start of the export token\n                exportStartLoc,\n              );\n            }\n          }\n\n          break;\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ) {\n      const node = super.parseSubscript(base, startLoc, noCalls, state);\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          node.type = node.type.substring(8); // strip Optional prefix\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    isOptionalMemberExpression(node: N.Node) {\n      if (node.type === \"ChainExpression\") {\n        return node.expression.type === \"MemberExpression\";\n      }\n      return super.isOptionalMemberExpression(node);\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    // @ts-expect-error override interfaces\n    isObjectProperty(node: N.Node): boolean {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    isObjectMethod(node: N.Node): boolean {\n      return node.method || node.kind === \"get\" || node.kind === \"set\";\n    }\n\n    finishNodeAt<T extends NodeType>(\n      node: Undone<T>,\n      type: T[\"type\"],\n      endLoc: Position,\n    ): T {\n      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n    }\n\n    resetStartLocation(node: N.Node, startLoc: Position) {\n      super.resetStartLocation(node, startLoc);\n      toESTreeLocation(node);\n    }\n\n    resetEndLocation(\n      node: NodeBase,\n      endLoc: Position = this.state.lastTokEndLoc,\n    ): void {\n      super.resetEndLocation(node, endLoc);\n      toESTreeLocation(node);\n    }\n  };\n", "// The token context is used in JSX plugin to track\n// jsx tag / jsx text / normal JavaScript expression\n\nexport class TokContext {\n  constructor(token: string, preserveSpace?: boolean) {\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n  token: string;\n  preserveSpace: boolean;\n}\n\nconst types: {\n  [key: string]: TokContext;\n} = {\n  brace: new TokContext(\"{\"), // normal JavaScript expression\n  j_oTag: new TokContext(\"<tag\"), // JSX opening tag\n  j_cTag: new TokContext(\"</tag\"), // JSX closing tag\n  j_expr: new TokContext(\"<tag>...</tag>\", true), // JSX expressions\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  types.template = new TokContext(\"`\", true);\n}\n\nexport { types };\n", "import { types as tc, type TokContext } from \"./context.ts\";\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between 1) binary\n// expression (<) and JSX Tag start (<name>); 2) object literal and JSX\n// texts. It is set on the `updateContext` function in the JSX plugin.\n\n// The `startsExpr` property is used to determine whether an expression\n// may be the “argument” subexpression of a `yield` expression or\n// `yield` statement. It is set on all token types that may be at the\n// start of a subexpression.\n\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\n\ntype TokenOptions = {\n  keyword?: string;\n  beforeExpr?: boolean;\n  startsExpr?: boolean;\n  rightAssociative?: boolean;\n  isLoop?: boolean;\n  isAssign?: boolean;\n  prefix?: boolean;\n  postfix?: boolean;\n  binop?: number | null;\n};\n\n// Internally the tokenizer stores token as a number\nexport type TokenType = number;\n\n// The `ExportedTokenType` is exported via `tokTypes` and accessible\n// when `tokens: true` is enabled. Unlike internal token type, it provides\n// metadata of the tokens.\nexport class ExportedTokenType {\n  label: string;\n  keyword: string | undefined | null;\n  beforeExpr: boolean;\n  startsExpr: boolean;\n  rightAssociative: boolean;\n  isLoop: boolean;\n  isAssign: boolean;\n  prefix: boolean;\n  postfix: boolean;\n  binop: number | undefined | null;\n  // todo(Babel 8): remove updateContext from exposed token layout\n  declare updateContext:\n    | ((context: Array<TokContext>) => void)\n    | undefined\n    | null;\n\n  constructor(label: string, conf: TokenOptions = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    if (!process.env.BABEL_8_BREAKING) {\n      this.updateContext = null;\n    }\n  }\n}\n\n// A map from keyword/keyword-like string value to the token type\nexport const keywords = new Map<string, TokenType>();\n\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name: string, binop: number) {\n  return createToken(name, { beforeExpr, binop });\n}\n\nlet tokenTypeCounter = -1;\nexport const tokenTypes: ExportedTokenType[] = [];\nconst tokenLabels: string[] = [];\nconst tokenBinops: number[] = [];\nconst tokenBeforeExprs: boolean[] = [];\nconst tokenStartsExprs: boolean[] = [];\nconst tokenPrefixes: boolean[] = [];\n\nfunction createToken(name: string, options: TokenOptions = {}): TokenType {\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(\n  name: string,\n  options: TokenOptions = {},\n): TokenType {\n  ++tokenTypeCounter;\n  keywords.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  // In the exported token type, we set the label as \"name\" for backward compatibility with Babel 7\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n\n  return tokenTypeCounter;\n}\n\n// For performance the token type helpers depend on the following declarations order.\n// When adding new token types, please also check if the token helpers need update.\n\nexport type InternalTokenTypes = typeof tt;\n\nexport const tt = {\n  // Punctuation token types.\n  bracketL: createToken(\"[\", { beforeExpr, startsExpr }),\n  bracketHashL: createToken(\"#[\", { beforeExpr, startsExpr }),\n  bracketBarL: createToken(\"[|\", { beforeExpr, startsExpr }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", { beforeExpr, startsExpr }),\n  braceBarL: createToken(\"{|\", { beforeExpr, startsExpr }),\n  braceHashL: createToken(\"#{\", { beforeExpr, startsExpr }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", { beforeExpr, startsExpr }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", { beforeExpr }),\n  semi: createToken(\";\", { beforeExpr }),\n  colon: createToken(\":\", { beforeExpr }),\n  doubleColon: createToken(\"::\", { beforeExpr }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", { beforeExpr }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", { beforeExpr }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", { beforeExpr }),\n  backQuote: createToken(\"`\", { startsExpr }),\n  dollarBraceL: createToken(\"${\", { beforeExpr, startsExpr }),\n  // start: isTemplate\n  templateTail: createToken(\"...`\", { startsExpr }),\n  templateNonTail: createToken(\"...${\", { beforeExpr, startsExpr }),\n  // end: isTemplate\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", { startsExpr }),\n\n  // Special hashbang token.\n  interpreterDirective: createToken(\"#!...\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  // start: isAssign\n  eq: createToken(\"=\", { beforeExpr, isAssign }),\n  assign: createToken(\"_=\", { beforeExpr, isAssign }),\n  slashAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // These are only needed to support % and ^ as a Hack-pipe topic token.\n  // When the proposal settles on a token, the others can be merged with\n  // tt.assign.\n  xorAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  moduloAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // end: isAssign\n\n  incDec: createToken(\"++/--\", { prefix, postfix, startsExpr }),\n  bang: createToken(\"!\", { beforeExpr, prefix, startsExpr }),\n  tilde: createToken(\"~\", { beforeExpr, prefix, startsExpr }),\n\n  // More possible topic tokens.\n  // When the proposal settles on a token, at least one of these may be removed.\n  doubleCaret: createToken(\"^^\", { startsExpr }),\n  doubleAt: createToken(\"@@\", { startsExpr }),\n\n  // start: isBinop\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\n  // startsExpr: required by v8intrinsic plugin\n  modulo: createToken(\"%\", { binop: 10, startsExpr }),\n  // unset `beforeExpr` as it can be `function *`\n  star: createToken(\"*\", { binop: 10 }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true,\n  }),\n\n  // Keywords\n  // Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js\n  // when new keywords are added\n  // start: isLiteralPropertyName\n  // start: isKeyword\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\n  // end: isBinop\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", { beforeExpr }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", { beforeExpr }),\n  _else: createKeyword(\"else\", { beforeExpr }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", { startsExpr }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", { beforeExpr }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", { beforeExpr, startsExpr }),\n  _this: createKeyword(\"this\", { startsExpr }),\n  _super: createKeyword(\"super\", { startsExpr }),\n  _class: createKeyword(\"class\", { startsExpr }),\n  _extends: createKeyword(\"extends\", { beforeExpr }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", { startsExpr }),\n  _null: createKeyword(\"null\", { startsExpr }),\n  _true: createKeyword(\"true\", { startsExpr }),\n  _false: createKeyword(\"false\", { startsExpr }),\n  _typeof: createKeyword(\"typeof\", { beforeExpr, prefix, startsExpr }),\n  _void: createKeyword(\"void\", { beforeExpr, prefix, startsExpr }),\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\n  // start: isLoop\n  _do: createKeyword(\"do\", { isLoop, beforeExpr }),\n  _for: createKeyword(\"for\", { isLoop }),\n  _while: createKeyword(\"while\", { isLoop }),\n  // end: isLoop\n  // end: isKeyword\n\n  // Primary literals\n  // start: isIdentifier\n  _as: createKeywordLike(\"as\", { startsExpr }),\n  _assert: createKeywordLike(\"assert\", { startsExpr }),\n  _async: createKeywordLike(\"async\", { startsExpr }),\n  _await: createKeywordLike(\"await\", { startsExpr }),\n  _defer: createKeywordLike(\"defer\", { startsExpr }),\n  _from: createKeywordLike(\"from\", { startsExpr }),\n  _get: createKeywordLike(\"get\", { startsExpr }),\n  _let: createKeywordLike(\"let\", { startsExpr }),\n  _meta: createKeywordLike(\"meta\", { startsExpr }),\n  _of: createKeywordLike(\"of\", { startsExpr }),\n  _sent: createKeywordLike(\"sent\", { startsExpr }),\n  _set: createKeywordLike(\"set\", { startsExpr }),\n  _source: createKeywordLike(\"source\", { startsExpr }),\n  _static: createKeywordLike(\"static\", { startsExpr }),\n  _using: createKeywordLike(\"using\", { startsExpr }),\n  _yield: createKeywordLike(\"yield\", { startsExpr }),\n\n  // Flow and TypeScript Keywordlike\n  _asserts: createKeywordLike(\"asserts\", { startsExpr }),\n  _checks: createKeywordLike(\"checks\", { startsExpr }),\n  _exports: createKeywordLike(\"exports\", { startsExpr }),\n  _global: createKeywordLike(\"global\", { startsExpr }),\n  _implements: createKeywordLike(\"implements\", { startsExpr }),\n  _intrinsic: createKeywordLike(\"intrinsic\", { startsExpr }),\n  _infer: createKeywordLike(\"infer\", { startsExpr }),\n  _is: createKeywordLike(\"is\", { startsExpr }),\n  _mixins: createKeywordLike(\"mixins\", { startsExpr }),\n  _proto: createKeywordLike(\"proto\", { startsExpr }),\n  _require: createKeywordLike(\"require\", { startsExpr }),\n  _satisfies: createKeywordLike(\"satisfies\", { startsExpr }),\n  // start: isTSTypeOperator\n  _keyof: createKeywordLike(\"keyof\", { startsExpr }),\n  _readonly: createKeywordLike(\"readonly\", { startsExpr }),\n  _unique: createKeywordLike(\"unique\", { startsExpr }),\n  // end: isTSTypeOperator\n  // start: isTSDeclarationStart\n  _abstract: createKeywordLike(\"abstract\", { startsExpr }),\n  _declare: createKeywordLike(\"declare\", { startsExpr }),\n  _enum: createKeywordLike(\"enum\", { startsExpr }),\n  _module: createKeywordLike(\"module\", { startsExpr }),\n  _namespace: createKeywordLike(\"namespace\", { startsExpr }),\n  // start: isFlowInterfaceOrTypeOrOpaque\n  _interface: createKeywordLike(\"interface\", { startsExpr }),\n  _type: createKeywordLike(\"type\", { startsExpr }),\n  // end: isTSDeclarationStart\n  _opaque: createKeywordLike(\"opaque\", { startsExpr }),\n  // end: isFlowInterfaceOrTypeOrOpaque\n  name: createToken(\"name\", { startsExpr }),\n  // end: isIdentifier\n\n  string: createToken(\"string\", { startsExpr }),\n  num: createToken(\"num\", { startsExpr }),\n  bigint: createToken(\"bigint\", { startsExpr }),\n  decimal: createToken(\"decimal\", { startsExpr }),\n  // end: isLiteralPropertyName\n  regexp: createToken(\"regexp\", { startsExpr }),\n  privateName: createToken(\"#name\", { startsExpr }),\n  eof: createToken(\"eof\"),\n\n  // jsx plugin\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", { beforeExpr: true }),\n  jsxTagStart: createToken(\"jsxTagStart\", { startsExpr: true }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n\n  // placeholder plugin\n  placeholder: createToken(\"%%\", { startsExpr: true }),\n} as const;\n\nexport function tokenIsIdentifier(token: TokenType): boolean {\n  return token >= tt._as && token <= tt.name;\n}\n\nexport function tokenKeywordOrIdentifierIsKeyword(token: TokenType): boolean {\n  // we can remove the token >= tt._in check when we\n  // know a token is either keyword or identifier\n  return token <= tt._while;\n}\n\nexport function tokenIsKeywordOrIdentifier(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.name;\n}\n\nexport function tokenIsLiteralPropertyName(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.decimal;\n}\n\nexport function tokenComesBeforeExpression(token: TokenType): boolean {\n  return tokenBeforeExprs[token];\n}\n\nexport function tokenCanStartExpression(token: TokenType): boolean {\n  return tokenStartsExprs[token];\n}\n\nexport function tokenIsAssignment(token: TokenType): boolean {\n  return token >= tt.eq && token <= tt.moduloAssign;\n}\n\nexport function tokenIsFlowInterfaceOrTypeOrOpaque(token: TokenType): boolean {\n  return token >= tt._interface && token <= tt._opaque;\n}\n\nexport function tokenIsLoop(token: TokenType): boolean {\n  return token >= tt._do && token <= tt._while;\n}\n\nexport function tokenIsKeyword(token: TokenType): boolean {\n  return token >= tt._in && token <= tt._while;\n}\n\nexport function tokenIsOperator(token: TokenType): boolean {\n  return token >= tt.pipeline && token <= tt._instanceof;\n}\n\nexport function tokenIsPostfix(token: TokenType): boolean {\n  return token === tt.incDec;\n}\n\nexport function tokenIsPrefix(token: TokenType): boolean {\n  return tokenPrefixes[token];\n}\n\nexport function tokenIsTSTypeOperator(token: TokenType): boolean {\n  return token >= tt._keyof && token <= tt._unique;\n}\n\nexport function tokenIsTSDeclarationStart(token: TokenType): boolean {\n  return token >= tt._abstract && token <= tt._type;\n}\n\nexport function tokenLabelName(token: TokenType): string {\n  return tokenLabels[token];\n}\n\nexport function tokenOperatorPrecedence(token: TokenType): number {\n  return tokenBinops[token];\n}\n\nexport function tokenIsBinaryOperator(token: TokenType): boolean {\n  return tokenBinops[token] !== -1;\n}\n\nexport function tokenIsRightAssociative(token: TokenType): boolean {\n  return token === tt.exponent;\n}\n\nexport function tokenIsTemplate(token: TokenType): boolean {\n  return token >= tt.templateTail && token <= tt.templateNonTail;\n}\n\nexport function getExportedToken(token: TokenType): ExportedTokenType {\n  return tokenTypes[token];\n}\n\nexport function isTokenType(obj: any): boolean {\n  return typeof obj === \"number\";\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  tokenTypes[tt.braceR].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[tt.braceL].updateContext =\n    tokenTypes[tt.braceHashL].updateContext =\n    tokenTypes[tt.dollarBraceL].updateContext =\n      context => {\n        context.push(tc.brace);\n      };\n\n  tokenTypes[tt.backQuote].updateContext = context => {\n    if (context[context.length - 1] === tc.template) {\n      context.pop();\n    } else {\n      context.push(tc.template);\n    }\n  };\n\n  tokenTypes[tt.jsxTagStart].updateContext = context => {\n    context.push(tc.j_expr, tc.j_oTag);\n  };\n}\n", "import * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.js`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.js`.\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,4026,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,757,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,81,2,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,9,5351,0,7,14,13835,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,983,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `name` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n", "const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n", "import * as charCodes from \"charcodes\";\nimport { isIdentifierStart } from \"@babel/helper-validator-identifier\";\n\nexport {\n  isIdentifierStart,\n  isIdentifierChar,\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nexport const keywordRelationalOperator = /^in(stanceof)?$/;\n\n// Test whether a current state character code and next character code is @\n\nexport function isIteratorStart(\n  current: number,\n  next: number,\n  next2: number,\n): boolean {\n  return (\n    current === charCodes.atSign &&\n    next === charCodes.atSign &&\n    isIdentifierStart(next2)\n  );\n}\n\n// This is the comprehensive set of JavaScript reserved words\n// If a word is in this set, it could be a reserved word,\n// depending on sourceType/strictMode/binding info. In other words\n// if a word is not in this set, it is not a reserved word under\n// any circumstance.\nconst reservedWordLikeSet = new Set([\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"do\",\n  \"else\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"return\",\n  \"switch\",\n  \"throw\",\n  \"try\",\n  \"var\",\n  \"const\",\n  \"while\",\n  \"with\",\n  \"new\",\n  \"this\",\n  \"super\",\n  \"class\",\n  \"extends\",\n  \"export\",\n  \"import\",\n  \"null\",\n  \"true\",\n  \"false\",\n  \"in\",\n  \"instanceof\",\n  \"typeof\",\n  \"void\",\n  \"delete\",\n  // strict\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"yield\",\n  // strictBind\n  \"eval\",\n  \"arguments\",\n  // reservedWorkLike\n  \"enum\",\n  \"await\",\n]);\n\nexport function canBeReservedWord(word: string): boolean {\n  return reservedWordLikeSet.has(word);\n}\n", "import { ScopeFlag, BindingFlag } from \"./scopeflags.ts\";\nimport type { Position } from \"./location.ts\";\nimport type * as N from \"../types.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  declare flags: ScopeFlag;\n  // A set of var-declared names in the current lexical scope\n  var: Set<string> = new Set();\n  // A set of lexically-declared names in the current lexical scope\n  lexical: Set<string> = new Set();\n  // A set of lexically-declared FunctionDeclaration names in the current lexical scope\n  functions: Set<string> = new Set();\n\n  constructor(flags: ScopeFlag) {\n    this.flags = flags;\n  }\n}\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope extends Scope = Scope> {\n  parser: Tokenizer;\n  scopeStack: Array<IScope> = [];\n  inModule: boolean;\n  undefinedExports: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer, inModule: boolean) {\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inTopLevel() {\n    return (this.currentScope().flags & ScopeFlag.PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & ScopeFlag.CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & ScopeFlag.CLASS) > 0 && (flags & ScopeFlag.FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS)) {\n        // function body, module body, class property initializers\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlag): Scope {\n    return new Scope(flags);\n  }\n\n  enter(flags: ScopeFlag) {\n    /*:: +createScope: (flags:ScopeFlag) => IScope; */\n    // @ts-expect-error This method will be overwritten by subclasses\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit(): ScopeFlag {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & (ScopeFlag.FUNCTION | ScopeFlag.STATIC_BLOCK) ||\n      (!this.parser.inModule && scope.flags & ScopeFlag.PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingFlag, loc: Position) {\n    let scope = this.currentScope();\n    if (\n      bindingType & BindingFlag.SCOPE_LEXICAL ||\n      bindingType & BindingFlag.SCOPE_FUNCTION\n    ) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BindingFlag.SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & ScopeFlag.VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingFlag,\n    loc: Position,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingFlag,\n  ): boolean {\n    if (!(bindingType & BindingFlag.KIND_VALUE)) return false;\n\n    if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n      return (\n        scope.lexical.has(name) ||\n        scope.functions.has(name) ||\n        scope.var.has(name)\n      );\n    }\n\n    if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n      return (\n        scope.lexical.has(name) ||\n        (!this.treatFunctionsAsVarInScope(scope) && scope.var.has(name))\n      );\n    }\n\n    return (\n      (scope.lexical.has(name) &&\n        // Annex B.3.4\n        // https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks\n        !(\n          scope.flags & ScopeFlag.SIMPLE_CATCH &&\n          scope.lexical.values().next().value === name\n        )) ||\n      (!this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name))\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (\n      !topLevelScope.lexical.has(name) &&\n      !topLevelScope.var.has(name) &&\n      // In strict mode, scope.functions will always be empty.\n      // Modules are strict by default, but the `scriptMode` option\n      // can overwrite this behavior.\n      !topLevelScope.functions.has(name)\n    ) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.VAR) {\n        return flags;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  currentThisScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (\n        flags & (ScopeFlag.VAR | ScopeFlag.CLASS) &&\n        !(flags & ScopeFlag.ARROW)\n      ) {\n        return flags;\n      }\n    }\n  }\n}\n", "import type { Position } from \"../../util/location.ts\";\nimport ScopeHandler, { Scope } from \"../../util/scope.ts\";\nimport { BindingFlag, type ScopeFlag } from \"../../util/scopeflags.ts\";\nimport type * as N from \"../../types.ts\";\n\n// Reference implementation: https://github.com/facebook/flow/blob/23aeb2a2ef6eb4241ce178fde5d8f17c5f747fb5/src/typing/env.ml#L536-L584\nclass FlowScope extends Scope {\n  // declare function foo(): type;\n  declareFunctions: Set<string> = new Set();\n}\n\nexport default class FlowScopeHandler extends ScopeHandler<FlowScope> {\n  createScope(flags: ScopeFlag): FlowScope {\n    return new FlowScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingFlag, loc: Position) {\n    const scope = this.currentScope();\n    if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n  }\n\n  isRedeclaredInScope(\n    scope: FlowScope,\n    name: string,\n    bindingType: BindingFlag,\n  ): boolean {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n\n    if (bindingType & BindingFlag.FLAG_FLOW_DECLARE_FN) {\n      return (\n        !scope.declareFunctions.has(name) &&\n        (scope.lexical.has(name) || scope.functions.has(name))\n      );\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type State from \"../tokenizer/state.ts\";\nimport type { PluginsMap } from \"./index.ts\";\nimport type ScopeHandler from \"../util/scope.ts\";\nimport type ExpressionScopeHandler from \"../util/expression-scope.ts\";\nimport type ClassScopeHandler from \"../util/class-scope.ts\";\nimport type ProductionParameterHandler from \"../util/production-parameter.ts\";\nimport type {\n  ParserPluginWithOptions,\n  PluginConfig,\n  PluginOptions,\n} from \"../typings.ts\";\n\nexport default class BaseParser {\n  // Properties set by constructor in index.js\n  declare options: Options;\n  declare inModule: boolean;\n  declare scope: ScopeHandler<any>;\n  declare classScope: ClassScopeHandler;\n  declare prodParam: ProductionParameterHandler;\n  declare expressionScope: ExpressionScopeHandler;\n  declare plugins: PluginsMap;\n  declare filename: string | undefined | null;\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n  declare exportedIdentifiers: Set<string>;\n  sawUnambiguousESM: boolean = false;\n  ambiguousScriptDifferentAst: boolean = false;\n\n  // Initialized by Tokenizer\n  declare state: State;\n  // input and length are not in state as they are constant and we do\n  // not want to ever copy them, which happens if state gets cloned\n  declare input: string;\n  declare length: number;\n\n  // This method accepts either a string (plugin name) or an array pair\n  // (plugin name and options object). If an options object is given,\n  // then each value is non-recursively checked for identity with that\n  // plugin’s actual option value.\n  hasPlugin(pluginConfig: PluginConfig): boolean {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(\n        pluginOptions,\n      ) as (keyof typeof pluginOptions)[]) {\n        if (actualOptions?.[key] !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  getPluginOption<\n    PluginName extends ParserPluginWithOptions[0],\n    OptionName extends keyof PluginOptions<PluginName>,\n  >(plugin: PluginName, name: OptionName) {\n    return (this.plugins.get(plugin) as null | PluginOptions<PluginName>)?.[\n      name\n    ];\n  }\n}\n", "/*:: declare var invariant; */\n\nimport BaseParser from \"./base.ts\";\nimport type { Comment, Node, Identifier } from \"../types.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { Undone } from \"./node.ts\";\n\n/**\n * A whitespace token containing comments\n */\nexport type CommentWhitespace = {\n  /**\n   * the start of the whitespace token.\n   */\n  start: number;\n  /**\n   * the end of the whitespace token.\n   */\n  end: number;\n  /**\n   * the containing comments\n   */\n  comments: Array<Comment>;\n  /**\n   * the immediately preceding AST node of the whitespace token\n   */\n  leadingNode: Node | null;\n  /**\n   * the immediately following AST node of the whitespace token\n   */\n  trailingNode: Node | null;\n  /**\n   * the innermost AST node containing the whitespace with minimal size (|end - start|)\n   */\n  containingNode: Node | null;\n};\n\n/**\n * Merge comments with node's trailingComments or assign comments to be\n * trailingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nfunction setTrailingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's leadingComments or assign comments to be\n * leadingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nfunction setLeadingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's innerComments or assign comments to be\n * innerComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n */\nexport function setInnerComments(\n  node: Undone<Node>,\n  comments?: Array<Comment>,\n) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\n/**\n * Given node and elements array, if elements has non-null element,\n * merge comments to its trailingComments, otherwise merge comments\n * to node's innerComments\n */\nfunction adjustInnerComments(\n  node: Undone<Node>,\n  elements: Array<Node>,\n  commentWS: CommentWhitespace,\n) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nexport default class CommentsParser extends BaseParser {\n  addComment(comment: Comment): void {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  /**\n   * Given a newly created AST node _n_, attach _n_ to a comment whitespace _w_ if applicable\n   * {@see {@link CommentWhitespace}}\n   */\n  processComment(node: Node): void {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const { start: nodeStart } = node;\n    // invariant: for all 0 <= j <= i, let c = commentStack[j], c must satisfy c.end < node.end\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        // by definition of commentWhiteSpace, this implies commentWS.start > nodeStart\n        // so node can be a containingNode candidate. At this time we can finalize the comment\n        // whitespace, because\n        // 1) its leadingNode or trailingNode, if exists, will not change\n        // 2) its containingNode have been assigned and will not change because it is the\n        //    innermost minimal-sized AST node\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        // stop the loop when commentEnd <= nodeStart\n        break;\n      }\n    }\n  }\n\n  /**\n   * Assign the comments of comment whitespaces to related AST nodes.\n   * Also adjust innerComments following trailing comma.\n   */\n  finalizeComment(commentWS: CommentWhitespace) {\n    const { comments } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      /*:: invariant(commentWS.containingNode !== null) */\n      const { containingNode: node, start: commentStart } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === charCodes.comma) {\n        // If a commentWhitespace follows a comma and the containingNode allows\n        // list structures with trailing comma, merge it to the trailingComment\n        // of the last non-null list element\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  /**\n   * Drains remaining commentStack and applies finalizeComment\n   * to each comment whitespace. Used only in parseExpression\n   * where the top level AST node is _not_ Program\n   * {@see {@link CommentsParser#finalizeComment}}\n   */\n  finalizeRemainingComments() {\n    const { commentStack } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n\n  /* eslint-disable no-irregular-whitespace */\n  /**\n   * Reset previous node trailing comments. Used in object / class\n   * property parsing. We parse `async`, `static`, `set` and `get`\n   * as an identifier but may reinterpret it into an async/static/accessor\n   * method later. In this case the identifier is not part of the AST and we\n   * should sync the knowledge to commentStacks\n   *\n   * For example, when parsing\n   * ```\n   * async /* 1 *​/ function f() {}\n   * ```\n   * the comment whitespace `/* 1 *​/` has leading node Identifier(async). When\n   * we see the function token, we create a Function node and mark `/* 1 *​/` as\n   * inner comments. So `/* 1 *​/` should be detached from the Identifier node.\n   *\n   * @param node the last finished AST node _before_ current token\n   */\n  /* eslint-enable no-irregular-whitespace */\n  resetPreviousNodeTrailingComments(node: Node) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  /* eslint-disable no-irregular-whitespace */\n  /**\n   * Reset previous node leading comments, assuming that `node` is a\n   * single-token node. Used in import phase modifiers parsing. We parse\n   * `module` in `import module foo from ...` as an identifier but may\n   * reinterpret it into a phase modifier later. In this case the identifier is\n   * not part of the AST and we should sync the knowledge to commentStacks\n   *\n   * For example, when parsing\n   * ```\n   * import /* 1 *​/ module a from \"a\";\n   * ```\n   * the comment whitespace `/* 1 *​/` has trailing node Identifier(module). When\n   * we see that `module` is not a default import binding, we mark `/* 1 *​/` as\n   * inner comments of the ImportDeclaration. So `/* 1 *​/` should be detached from\n   * the Identifier node.\n   *\n   * @param node the last finished AST node _before_ current token\n   */\n  /* eslint-enable no-irregular-whitespace */\n  resetPreviousIdentifierLeadingComments(node: Identifier) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n\n  /**\n   * Attach a node to the comment whitespaces right before/after\n   * the given range.\n   *\n   * This is used to properly attach comments around parenthesized\n   * expressions as leading/trailing comments of the inner expression.\n   */\n  takeSurroundingComments(node: Node, start: number, end: number) {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\n", "import * as charCodes from \"charcodes\";\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n// https://tc39.github.io/ecma262/#sec-line-terminators\nexport function isNewLine(code: number): boolean {\n  switch (code) {\n    case charCodes.lineFeed:\n    case charCodes.carriageReturn:\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nexport const skipWhiteSpaceInLine =\n  /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\n\n// Skip whitespace and single-line comments, including /* no newline here */.\n// After this RegExp matches, its lastIndex points to a line terminator, or\n// the start of multi-line comment (which is effectively a line terminator),\n// or the end of string.\nexport const skipWhiteSpaceToLineBreak = new RegExp(\n  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or\n  // possessive quantifiers, so we use a trick to prevent backtracking\n  // when the look-ahead for line terminator fails.\n  \"(?=(\" +\n    // Capture the whitespace and comments that should be skipped inside\n    // a look-ahead assertion, and then re-match the group as a unit.\n    skipWhiteSpaceInLine.source +\n    \"))\\\\1\" +\n    // Look-ahead for either line terminator, start of multi-line comment,\n    // or end of string.\n    /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source,\n  \"y\", // sticky\n);\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport function isWhitespace(code: number): boolean {\n  switch (code) {\n    case 0x0009: // CHARACTER TABULATION\n    case 0x000b: // LINE TABULATION\n    case 0x000c: // FORM FEED\n    case charCodes.space:\n    case charCodes.nonBreakingSpace:\n    case charCodes.oghamSpaceMark:\n    case 0x2000: // EN QUAD\n    case 0x2001: // EM QUAD\n    case 0x2002: // EN SPACE\n    case 0x2003: // EM SPACE\n    case 0x2004: // THREE-PER-EM SPACE\n    case 0x2005: // FOUR-PER-EM SPACE\n    case 0x2006: // SIX-PER-EM SPACE\n    case 0x2007: // FIGURE SPACE\n    case 0x2008: // PUNCTUATION SPACE\n    case 0x2009: // THIN SPACE\n    case 0x200a: // HAIR SPACE\n    case 0x202f: // NARROW NO-BREAK SPACE\n    case 0x205f: // MEDIUM MATHEMATICAL SPACE\n    case 0x3000: // IDEOGRAPHIC SPACE\n    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE\n      return true;\n\n    default:\n      return false;\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type * as N from \"../types.ts\";\nimport type { CommentWhitespace } from \"../parser/comments\";\nimport { Position } from \"../util/location.ts\";\n\nimport { types as ct, type TokContext } from \"./context.ts\";\nimport { tt, type TokenType } from \"./types.ts\";\nimport type { Errors } from \"../parse-error.ts\";\nimport type { ParseError } from \"../parse-error.ts\";\n\nexport type DeferredStrictError =\n  | typeof Errors.StrictNumericEscape\n  | typeof Errors.StrictOctalLiteral;\n\ntype TopicContextState = {\n  // When a topic binding has been currently established,\n  // then this is 1. Otherwise, it is 0. This is forwards compatible\n  // with a future plugin for multiple lexical topics.\n  maxNumOfResolvableTopics: number;\n  // When a topic binding has been currently established, and if that binding\n  // has been used as a topic reference `#`, then this is 0. Otherwise, it is\n  // `null`. This is forwards compatible with a future plugin for multiple\n  // lexical topics.\n  maxTopicIndex: null | 0;\n};\n\nexport default class State {\n  strict: boolean;\n  curLine: number;\n  lineStart: number;\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  startLoc: Position;\n  endLoc: Position;\n\n  init({ strictMode, sourceType, startLine, startColumn }: Options): void {\n    this.strict =\n      strictMode === false\n        ? false\n        : strictMode === true\n          ? true\n          : sourceType === \"module\";\n\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n\n  errors: ParseError<any>[] = [];\n\n  // Used to signify the start of a potential arrow function\n  potentialArrowAt: number = -1;\n\n  // Used to signify the start of an expression which looks like a\n  // typed arrow function, but it isn't\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowAt: number[] = [];\n\n  // Used to signify the start of an expression whose params, if it looks like\n  // an arrow function, shouldn't be converted to assignable nodes.\n  // This is used to defer the validation of typed arrow functions inside\n  // conditional expressions.\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowParamsConversionAt: number[] = [];\n\n  // Flags to track\n  maybeInArrowParameters: boolean = false;\n  inType: boolean = false;\n  noAnonFunctionType: boolean = false;\n  hasFlowComment: boolean = false;\n  isAmbientContext: boolean = false;\n  inAbstractClass: boolean = false;\n  inDisallowConditionalTypesContext: boolean = false;\n\n  // For the Hack-style pipelines plugin\n  topicContext: TopicContextState = {\n    maxNumOfResolvableTopics: 0,\n    maxTopicIndex: null,\n  };\n\n  // For the F#-style pipelines plugin\n  soloAwait: boolean = false;\n  inFSharpPipelineDirectBody: boolean = false;\n\n  // Labels in scope.\n  labels: Array<{\n    kind: \"loop\" | \"switch\" | undefined | null;\n    name?: string | null;\n    statementStart?: number;\n  }> = [];\n\n  // Comment store for Program.comments\n  comments: Array<N.Comment> = [];\n\n  // Comment attachment store\n  commentStack: Array<CommentWhitespace> = [];\n\n  // The current position of the tokenizer in the input.\n  pos: number = 0;\n\n  // Properties of the current token:\n  // Its type\n  type: TokenType = tt.eof;\n\n  // For tokens that include more information than their type, the value\n  value: any = null;\n\n  // Its start and end offset\n  start: number = 0;\n  end: number = 0;\n\n  // Position information for the previous token\n  // this is initialized when generating the second token.\n  lastTokEndLoc: Position = null;\n  // this is initialized when generating the second token.\n  lastTokStartLoc: Position = null;\n  lastTokStart: number = 0;\n\n  // The context stack is used to track whether the apostrophe \"`\" starts\n  // or ends a string template\n  context: Array<TokContext> = [ct.brace];\n  // Used to track whether a JSX element is allowed to form\n  canStartJSXElement: boolean = true;\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  containsEsc: boolean = false;\n\n  // Used to track invalid escape sequences in template literals,\n  // that must be reported if the template is not tagged.\n  firstInvalidTemplateEscapePos: null | Position = null;\n\n  // This property is used to track the following errors\n  // - StrictNumericEscape\n  // - StrictOctalLiteral\n  //\n  // in a literal that occurs prior to/immediately after a \"use strict\" directive.\n\n  // todo(JLHwung): set strictErrors to null and avoid recording string errors\n  // after a non-directive is parsed\n  strictErrors: Map<number, [DeferredStrictError, Position]> = new Map();\n\n  // Tokens length in token store\n  tokensLength: number = 0;\n\n  curPosition(): Position {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n\n  clone(skipArrays?: boolean): State {\n    const state = new State();\n    const keys = Object.keys(this) as (keyof State)[];\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      // @ts-expect-error val must conform to S[key]\n      state[key] = val;\n    }\n\n    return state;\n  }\n}\n\nexport type LookaheadState = {\n  pos: number;\n  value: any;\n  type: TokenType;\n  start: number;\n  end: number;\n  context: TokContext[];\n  startLoc: Position;\n  lastTokEndLoc: Position;\n  curLine: number;\n  lineStart: number;\n  curPosition: () => Position;\n  /* Used only in readToken_mult_modulo */\n  inType: boolean;\n  // These boolean properties are not initialized in createLookaheadState()\n  // instead they will only be set by the tokenizer\n  containsEsc?: boolean;\n};\n", "import * as charCodes from \"charcodes\";\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ]),\n  hex: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ]),\n};\n\nconst isAllowedNumericSeparatorSibling = {\n  // 0 - 1\n  bin: (ch: number) => ch === charCodes.digit0 || ch === charCodes.digit1,\n\n  // 0 - 7\n  oct: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit7,\n\n  // 0 - 9\n  dec: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit9,\n\n  // 0 - 9, A - F, a - f,\n  hex: (ch: number) =>\n    (ch >= charCodes.digit0 && ch <= charCodes.digit9) ||\n    (ch >= charCodes.uppercaseA && ch <= charCodes.uppercaseF) ||\n    (ch >= charCodes.lowercaseA && ch <= charCodes.lowercaseF),\n};\n\nexport type StringContentsErrorHandlers = EscapedCharErrorHandlers & {\n  unterminated(\n    initialPos: number,\n    initialLineStart: number,\n    initialCurLine: number,\n  ): void;\n};\n\nexport function readStringContents(\n  type: \"single\" | \"double\" | \"template\",\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  errors: StringContentsErrorHandlers,\n) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const { length } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === charCodes.backslash) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        type === \"template\",\n        errors,\n      );\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = { pos, lineStart, curLine };\n      } else {\n        out += res.ch;\n      }\n      ({ pos, lineStart, curLine } = res);\n      chunkStart = pos;\n    } else if (\n      ch === charCodes.lineSeparator ||\n      ch === charCodes.paragraphSeparator\n    ) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (\n          ch === charCodes.carriageReturn &&\n          input.charCodeAt(pos) === charCodes.lineFeed\n        ) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return process.env.BABEL_8_BREAKING\n    ? { pos, str: out, firstInvalidLoc, lineStart, curLine }\n    : {\n        pos,\n        str: out,\n        firstInvalidLoc,\n        lineStart,\n        curLine,\n        containsInvalid: !!firstInvalidLoc,\n      };\n}\n\nfunction isStringEnd(\n  type: \"single\" | \"double\" | \"template\",\n  ch: number,\n  input: string,\n  pos: number,\n) {\n  if (type === \"template\") {\n    return (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign &&\n        input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)\n    );\n  }\n  return (\n    ch === (type === \"double\" ? charCodes.quotationMark : charCodes.apostrophe)\n  );\n}\n\ntype EscapedCharErrorHandlers = HexCharErrorHandlers &\n  CodePointErrorHandlers & {\n    strictNumericEscape(pos: number, lineStart: number, curLine: number): void;\n  };\n\nfunction readEscapedChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  inTemplate: boolean,\n  errors: EscapedCharErrorHandlers,\n) {\n  const throwOnInvalid = !inTemplate;\n  pos++; // skip '\\'\n\n  const res = (ch: string | null) => ({ pos, ch, lineStart, curLine });\n\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case charCodes.lowercaseN:\n      return res(\"\\n\");\n    case charCodes.lowercaseR:\n      return res(\"\\r\");\n    case charCodes.lowercaseX: {\n      let code;\n      ({ code, pos } = readHexChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        2,\n        false,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCharCode(code));\n    }\n    case charCodes.lowercaseU: {\n      let code;\n      ({ code, pos } = readCodePoint(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCodePoint(code));\n    }\n    case charCodes.lowercaseT:\n      return res(\"\\t\");\n    case charCodes.lowercaseB:\n      return res(\"\\b\");\n    case charCodes.lowercaseV:\n      return res(\"\\u000b\");\n    case charCodes.lowercaseF:\n      return res(\"\\f\");\n    case charCodes.carriageReturn:\n      if (input.charCodeAt(pos) === charCodes.lineFeed) {\n        ++pos;\n      }\n    // fall through\n    case charCodes.lineFeed:\n      lineStart = pos;\n      ++curLine;\n    // fall through\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return res(\"\");\n    case charCodes.digit8:\n    case charCodes.digit9:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    // fall through\n    default:\n      if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/)!;\n\n        let octalStr = match[0];\n\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (\n          octalStr !== \"0\" ||\n          next === charCodes.digit8 ||\n          next === charCodes.digit9\n        ) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\ntype HexCharErrorHandlers = IntErrorHandlers & {\n  invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;\n};\n\n// Used to read character escape sequences ('\\x', '\\u').\nfunction readHexChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  len: number,\n  forceLen: boolean,\n  throwOnInvalid: boolean,\n  errors: HexCharErrorHandlers,\n) {\n  const initialPos = pos;\n  let n;\n  ({ n, pos } = readInt(\n    input,\n    pos,\n    lineStart,\n    curLine,\n    16,\n    len,\n    forceLen,\n    false,\n    errors,\n    /* bailOnError */ !throwOnInvalid,\n  ));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return { code: n, pos };\n}\n\nexport type IntErrorHandlers = {\n  numericSeparatorInEscapeSequence(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  unexpectedNumericSeparator(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  // It can return \"true\" to indicate that the error was handled\n  // and the int parsing should continue.\n  invalidDigit(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n    radix: number,\n  ): boolean;\n};\n\nexport function readInt(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  radix: number,\n  len: number | undefined,\n  forceLen: boolean,\n  allowNumSeparator: boolean | \"bail\",\n  errors: IntErrorHandlers,\n  bailOnError: boolean,\n) {\n  const start = pos;\n  const forbiddenSiblings =\n    radix === 16\n      ? forbiddenNumericSeparatorSiblings.hex\n      : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling =\n    radix === 16\n      ? isAllowedNumericSeparatorSibling.hex\n      : radix === 10\n        ? isAllowedNumericSeparatorSibling.dec\n        : radix === 8\n          ? isAllowedNumericSeparatorSibling.oct\n          : isAllowedNumericSeparatorSibling.bin;\n\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === charCodes.underscore && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        if (bailOnError) return { n: null, pos };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (\n        Number.isNaN(next) ||\n        !isAllowedSibling(next) ||\n        forbiddenSiblings.has(prev) ||\n        forbiddenSiblings.has(next)\n      ) {\n        if (bailOnError) return { n: null, pos };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      // Ignore this _ character\n      ++pos;\n      continue;\n    }\n\n    if (code >= charCodes.lowercaseA) {\n      val = code - charCodes.lowercaseA + charCodes.lineFeed;\n    } else if (code >= charCodes.uppercaseA) {\n      val = code - charCodes.uppercaseA + charCodes.lineFeed;\n    } else if (charCodes.isDigit(code)) {\n      val = code - charCodes.digit0; // 0-9\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      // If we found a digit which is too big, errors.invalidDigit can return true to avoid\n      // breaking the loop (this is used for error recovery).\n      if (val <= 9 && bailOnError) {\n        return { n: null, pos };\n      } else if (\n        val <= 9 &&\n        errors.invalidDigit(pos, lineStart, curLine, radix)\n      ) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || (len != null && pos - start !== len) || invalid) {\n    return { n: null, pos };\n  }\n\n  return { n: total, pos };\n}\n\nexport type CodePointErrorHandlers = HexCharErrorHandlers & {\n  invalidCodePoint(pos: number, lineStart: number, curLine: number): void;\n};\n\nexport function readCodePoint(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  throwOnInvalid: boolean,\n  errors: CodePointErrorHandlers,\n) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === charCodes.leftCurlyBrace) {\n    ++pos;\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      input.indexOf(\"}\", pos) - pos,\n      true,\n      throwOnInvalid,\n      errors,\n    ));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return { code: null, pos };\n      }\n    }\n  } else {\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      4,\n      false,\n      throwOnInvalid,\n      errors,\n    ));\n  }\n  return { code, pos };\n}\n", "/*:: declare var invariant; */\n\nimport type { Options } from \"../options.ts\";\nimport {\n  Position,\n  SourceLocation,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport CommentsParser, { type CommentWhitespace } from \"../parser/comments.ts\";\nimport type * as N from \"../types.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier.ts\";\nimport {\n  tokenIsKeyword,\n  tokenLabelName,\n  tt,\n  keywords as keywordTypes,\n  type TokenType,\n} from \"./types.ts\";\nimport type { TokContext } from \"./context.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n  type RaiseProperties,\n} from \"../parse-error.ts\";\nimport {\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n  skipWhiteSpaceInLine,\n} from \"../util/whitespace.ts\";\nimport State from \"./state.ts\";\nimport type { LookaheadState, DeferredStrictError } from \"./state.ts\";\n\nimport {\n  readInt,\n  readCodePoint,\n  readStringContents,\n  type IntErrorHandlers,\n  type CodePointErrorHandlers,\n  type StringContentsErrorHandlers,\n} from \"@babel/helper-string-parser\";\n\nimport type { Plugin } from \"../typings.ts\";\n\nfunction buildPosition(pos: number, lineStart: number, curLine: number) {\n  return new Position(curLine, pos - lineStart, pos);\n}\n\nconst VALID_REGEX_FLAGS = new Set([\n  charCodes.lowercaseG,\n  charCodes.lowercaseM,\n  charCodes.lowercaseS,\n  charCodes.lowercaseI,\n  charCodes.lowercaseY,\n  charCodes.lowercaseU,\n  charCodes.lowercaseD,\n  charCodes.lowercaseV,\n]);\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default abstract class Tokenizer extends CommentsParser {\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Whether current token matches given type\n   */\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  /**\n   * Create a LookaheadState from current parser state\n   */\n  createLookaheadState(state: State): LookaheadState {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition,\n    };\n  }\n\n  /**\n   * lookahead peeks the next token, skipping changes to token context and\n   * comment stack. For performance it returns a limited LookaheadState\n   * instead of full parser state.\n   *\n   * The { column, line } Loc info is not included in lookahead since such usage\n   * is rare. Although it may return other location properties e.g. `curLine` and\n   * `lineStart`, these properties are not listed in the LookaheadState interface\n   * and thus the returned value is _NOT_ reliable.\n   *\n   * The tokenizer should make best efforts to avoid using any parser state\n   * other than those defined in LookaheadState\n   */\n  lookahead(): LookaheadState {\n    const old = this.state;\n    // @ts-expect-error For performance we use a simplified tokenizer state structure\n    this.state = this.createLookaheadState(old);\n\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  /**\n   * Similar to nextToken, but it will stop at line break when it is seen before the next token\n   *\n   * @returns {number} position of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  nextTokenInLineStart(): number {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n\n  nextTokenInLineStartSince(pos: number): number {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input)\n      ? skipWhiteSpaceInLine.lastIndex\n      : pos;\n  }\n\n  /**\n   * Similar to lookaheadCharCode, but it will return the char code of line break if it is\n   * seen before the next token\n   *\n   * @returns {number} char code of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  lookaheadInLineCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n\n  codePointAtPos(pos: number): number {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `input` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach(([toParseError, at]) =>\n        this.raise(toParseError, { at }),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related properties.\n  nextToken(): void {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  // Skips a block comment, whose end is marked by commentEnd.\n  // *-/ is used by the Flow plugin, when parsing block comments nested\n  // inside Flow comments.\n  skipBlockComment(commentEnd: \"*/\" | \"*-/\"): N.CommentBlock | undefined {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      // We have to call this again here because startLoc may not be set...\n      // This seems to be for performance reasons:\n      // https://github.com/babel/babel/commit/acf2a10899f696a8aaf34df78bf9725b5ea7f2da\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const comment: N.CommentBlock = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip: number): N.CommentLine | undefined {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n\n    const comment: N.CommentLine = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk: {\n              const comment = this.skipBlockComment(\"*/\");\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            case charCodes.slash: {\n              const comment = this.skipLineComment(2);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (\n            ch === charCodes.dash &&\n            !this.inModule &&\n            this.options.annexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.dash &&\n              this.input.charCodeAt(pos + 2) === charCodes.greaterThan &&\n              (spaceStart === 0 || this.state.lineStart > spaceStart)\n            ) {\n              // A `-->` line comment\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (\n            ch === charCodes.lessThan &&\n            !this.inModule &&\n            this.options.annexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &&\n              this.input.charCodeAt(pos + 2) === charCodes.dash &&\n              this.input.charCodeAt(pos + 3) === charCodes.dash\n            ) {\n              // `<!--`, an XML-style comment that should be interpreted as a line comment\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace: CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null,\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `canStartJSXElement`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val?: any): void {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type: TokenType): void {\n    this.state.type = type;\n    // @ts-expect-error the prevType of updateContext is required\n    // only when the new type is tt.slash/tt.jsxTagEnd\n    this.updateContext();\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n          { at: this.state.curPosition() },\n        );\n      }\n\n      this.state.pos += 2;\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1(next));\n    } else if (next === charCodes.backslash) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1());\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.slashAssign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%' or '*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    // Exponentiation operator '**'\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    // '%=' or '*='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      width++;\n      // `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.braceBarR);\n        return;\n      }\n\n      // '|]'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.bracketBarR);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '^='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      // `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      this.finishOp(tt.xorAssign, 2);\n    }\n    // '^^'\n    else if (\n      next === charCodes.caret &&\n      // If the ^^ token is not enabled, we don't throw but parse two single ^s\n      // because it could be a ^ hack token followed by a ^ binary operator.\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"^^\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleCaret, 2);\n\n      // `^^^` is forbidden and must be separated by a space.\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === charCodes.caret) {\n        this.unexpected();\n      }\n    }\n    // '^'\n    else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_atSign(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '@@'\n    if (\n      next === charCodes.atSign &&\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"@@\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleAt, 2);\n    }\n    // '@'\n    else {\n      this.finishOp(tt.at, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt(): void {\n    // '<'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.lessThan) {\n      if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n        return;\n      }\n      this.finishOp(tt.bitShiftL, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.lt, 1);\n  }\n\n  readToken_gt(): void {\n    // '>'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.greaterThan) {\n      const size =\n        this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShiftR, size);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.gt, 1);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // [|\n          this.state.pos += 2;\n          this.finishToken(tt.bracketBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // {|\n          this.state.pos += 2;\n          this.finishToken(tt.braceBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        this.readTemplateToken();\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n        this.readToken_lt();\n        return;\n\n      case charCodes.greaterThan:\n        this.readToken_gt();\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        this.readToken_atSign();\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code),\n    });\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let { pos } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        // FIXME: explain\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === charCodes.leftSquareBracket) {\n          inClass = true;\n        } else if (ch === charCodes.rightSquareBracket && inClass) {\n          inClass = false;\n        } else if (ch === charCodes.slash && !inClass) {\n          break;\n        }\n        escaped = ch === charCodes.backslash;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n\n    let mods = \"\";\n\n    const nextPos = () =>\n      // (pos + 1) + 1 - start\n      createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      // It doesn't matter if cp > 0xffff, the loop will either throw or break because we check on cp\n      const char = String.fromCharCode(cp);\n\n      // @ts-expect-error VALID_REGEX_FLAGS.has should accept expanded type: number\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === charCodes.lowercaseV) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        } else if (cp === charCodes.lowercaseU) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, { at: nextPos() });\n        }\n      } else if (isIdentifierChar(cp) || cp === charCodes.backslash) {\n        this.raise(Errors.MalformedRegExpFlags, { at: nextPos() });\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen: boolean = false,\n    allowNumSeparator: boolean | \"bail\" = true,\n  ): number | null {\n    const { n, pos } = readInt(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      radix,\n      len,\n      forceLen,\n      allowNumSeparator,\n      this.errorHandlers_readInt,\n      /* bailOnError */ false,\n    );\n    this.state.pos = pos;\n    return n;\n  }\n\n  readRadixNumber(radix: number): void {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        // Numeric literals can't have newlines, so this is safe to do.\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix,\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(Errors.InvalidDecimal, { at: startLoc });\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (isBigInt) {\n      const str = this.input\n        .slice(startLoc.index, this.state.pos)\n        .replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, { at: this.state.curPosition() });\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, { at: startLoc });\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          // Numeric literals can't have newlines, so this is safe to do.\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos),\n          });\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, { at: startLoc });\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, { at: startLoc });\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, { at: startLoc });\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const { code, pos } = readCodePoint(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      throwOnInvalid,\n      this.errorHandlers_readCodePoint,\n    );\n    this.state.pos = pos;\n    return code;\n  }\n\n  readString(quote: number): void {\n    const { str, pos, curLine, lineStart } = readStringContents(\n      quote === charCodes.quotationMark ? \"double\" : \"single\",\n      this.input,\n      this.state.pos + 1, // skip the quote\n      this.state.lineStart,\n      this.state.curLine,\n      this.errorHandlers_readStringContents_string,\n    );\n    this.state.pos = pos + 1; // skip the quote\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(tt.string, str);\n  }\n\n  // Reads template continuation `}...`\n  readTemplateContinuation(): void {\n    if (!this.match(tt.braceR)) {\n      this.unexpected(null, tt.braceR);\n    }\n    // rewind pos to `}`\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  // Reads template string tokens.\n  readTemplateToken(): void {\n    const opening = this.input[this.state.pos];\n    const { str, firstInvalidLoc, pos, curLine, lineStart } =\n      readStringContents(\n        \"template\",\n        this.input,\n        this.state.pos + 1, // skip '`' or `}`\n        this.state.lineStart,\n        this.state.curLine,\n        this.errorHandlers_readStringContents_template,\n      );\n    this.state.pos = pos + 1; // skip '`' or `$`\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(\n        firstInvalidLoc.curLine,\n        firstInvalidLoc.pos - firstInvalidLoc.lineStart,\n        firstInvalidLoc.pos,\n      );\n    }\n\n    if (this.input.codePointAt(pos) === charCodes.graveAccent) {\n      this.finishToken(\n        tt.templateTail,\n        firstInvalidLoc ? null : opening + str + \"`\",\n      );\n    } else {\n      this.state.pos++; // skip '{'\n      this.finishToken(\n        tt.templateNonTail,\n        firstInvalidLoc ? null : opening + str + \"${\",\n      );\n    }\n  }\n\n  recordStrictModeErrors(\n    toParseError: DeferredStrictError,\n    { at }: { at: Position },\n  ) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, { at });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n  //\n  // When `firstCode` is given, it assumes it is always an identifier start and\n  // will skip reading start position again\n\n  readWord1(firstCode?: number): string {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition(),\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, { at: escStart });\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(firstCode?: number): void {\n    const word = this.readWord1(firstCode);\n    const type = keywordTypes.get(word);\n    if (type !== undefined) {\n      // We don't use word as state.value here because word is a dynamic string\n      // while token label is a shared constant string\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(tt.name, word);\n    }\n  }\n\n  checkKeywordEscapes(): void {\n    const { type } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type),\n      });\n    }\n  }\n\n  /**\n   * Raise a `ParseError` given the appropriate properties. If passed a\n   * `Position` for the `at` property, raises the `ParseError` at that location.\n   * Otherwise, if passed a `Node`, raises the `ParseError` at the start\n   * location of that `Node`.\n   *\n   * If `errorRecovery` is `true`, the error is pushed to the errors array and\n   * returned. If `errorRecovery` is `false`, the error is instead thrown.\n   */\n  raise<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    // @ts-expect-error: refine details typing\n    const error = toParseError({ loc, details });\n\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n\n    return error;\n  }\n\n  /**\n   * If `errorRecovery` is `false`, this method behaves identically to `raise`.\n   * If `errorRecovery` is `true`, this method will first see if there is\n   * already an error stored at the same `Position`, and replaces it with the\n   * one generated here.\n   */\n  raiseOverwrite<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> | never {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        // @ts-expect-error: refine details typing\n        return (errors[i] = toParseError({ loc, details }));\n      }\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  // updateContext is used by the jsx plugin\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateContext(prevType: TokenType): void {}\n\n  // Raise an unexpected token error. Can take the expected token type.\n  unexpected(loc?: Position | null, type?: TokenType): void {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc,\n    });\n  }\n\n  expectPlugin(pluginName: Plugin, loc?: Position): true {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName],\n    });\n  }\n\n  expectOnePlugin(pluginNames: Plugin[]): void {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames,\n      });\n    }\n  }\n\n  errorBuilder(error: ParseErrorConstructor<{}>) {\n    return (pos: number, lineStart: number, curLine: number) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    };\n  }\n\n  errorHandlers_readInt: IntErrorHandlers = {\n    invalidDigit: (pos, lineStart, curLine, radix) => {\n      if (!this.options.errorRecovery) return false;\n\n      this.raise(Errors.InvalidDigit, {\n        at: buildPosition(pos, lineStart, curLine),\n        radix,\n      });\n      // Continue parsing the number as if there was no invalid digit.\n      return true;\n    },\n    numericSeparatorInEscapeSequence: this.errorBuilder(\n      Errors.NumericSeparatorInEscapeSequence,\n    ),\n    unexpectedNumericSeparator: this.errorBuilder(\n      Errors.UnexpectedNumericSeparator,\n    ),\n  };\n\n  errorHandlers_readCodePoint: CodePointErrorHandlers = {\n    ...this.errorHandlers_readInt,\n    invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n    invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),\n  };\n\n  errorHandlers_readStringContents_string: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: (pos, lineStart, curLine) => {\n      this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedString, {\n        // Report the error at the string quote\n        at: buildPosition(pos - 1, lineStart, curLine),\n      });\n    },\n  };\n\n  errorHandlers_readStringContents_template: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedTemplate, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n  };\n}\n", "import { ClassElementType } from \"./scopeflags.ts\";\nimport type { Position } from \"./location.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\nexport class ClassScope {\n  // A list of private named declared in the current class\n  privateNames: Set<string> = new Set();\n\n  // A list of private getters of setters without their counterpart\n  loneAccessors: Map<string, ClassElementType> = new Map();\n\n  // A list of private names used before being defined, mapping to\n  // their position.\n  undefinedPrivateNames: Map<string, Position> = new Map();\n}\n\nexport default class ClassScopeHandler {\n  parser: Tokenizer;\n  stack: Array<ClassScope> = [];\n  undefinedPrivateNames: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer) {\n    this.parser = parser;\n  }\n\n  current(): ClassScope {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n\n    // Migrate the usage of not yet defined private names to the outer\n    // class scope, or raise an error if we reached the top-level scope.\n\n    const current = this.current();\n\n    // Array.from is needed because this is compiled to an array-like for loop\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name,\n        });\n      }\n    }\n  }\n\n  declarePrivateName(\n    name: string,\n    elementType: ClassElementType,\n    loc: Position,\n  ) {\n    const { privateNames, loneAccessors, undefinedPrivateNames } =\n      this.current();\n    let redefined = privateNames.has(name);\n\n    if (elementType & ClassElementType.KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & ClassElementType.FLAG_STATIC;\n        const newStatic = elementType & ClassElementType.FLAG_STATIC;\n\n        const oldKind = accessor & ClassElementType.KIND_ACCESSOR;\n        const newKind = elementType & ClassElementType.KIND_ACCESSOR;\n\n        // The private name can be duplicated only if it is used by\n        // two accessors with different kind (get and set), and if\n        // they have the same placement (static or not).\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name: string, loc: Position) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      // top-level\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name,\n      });\n    }\n  }\n}\n", "import { Errors, type ParseErrorConstructor } from \"../parse-error.ts\";\nimport type { Position } from \"./location.ts\";\nimport type { Node } from \"../types.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\n/**\n * @module util/expression-scope\n\nExpressionScope is used to track declaration errors in these ambiguous patterns:\n\n- CoverParenthesizedExpressionAndArrowParameterList\n  e.g. we don't know if `({ x })` is an parenthesized expression or an\n  arrow function parameters until we see an `=>` after `)`.\n\n- CoverCallExpressionAndAsyncArrowHead\n  e.g. we don't know if `async({ x })` is a call expression or an async arrow\n  function parameters until we see an `=>` after `)`\n\nThe following declaration errors (@see parser-errors/standard) will be recorded in\nsome expression scopes and thrown later when we know what the ambiguous pattern is\n\n- AwaitBindingIdentifier\n- AwaitExpressionFormalParameter\n- YieldInParameter\n- InvalidParenthesizedAssignment when parenthesized is an identifier\n\nThere are four different expression scope\n- Expression\n  A general scope that represents program / function body / static block. No errors\n  will be recorded nor thrown in this scope.\n\n- MaybeArrowParameterDeclaration\n  A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded\n  alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`\n  is called.\n\n- MaybeAsyncArrowParameterDeclaration\n  A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will\n  be recorded alongside parent scopes and thrown when\n  `ExpressionScopeHandler#validateAsPattern` is called.\n\n- ParameterDeclaration\n  A scope that represents unambiguous function parameters `function(x)`. Errors\n  recorded in this scope will be thrown immediately. No errors will be recorded in\n  this scope.\n\n// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}\n */\n\nconst enum ExpressionScopeType {\n  kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3,\n}\n\nclass ExpressionScope {\n  declare type: ExpressionScopeType;\n\n  constructor(type: ExpressionScopeType = ExpressionScopeType.kExpression) {\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration(): this is ArrowHeadParsingScope {\n    return (\n      this.type === ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration ||\n      this.type === ExpressionScopeType.kMaybeArrowParameterDeclaration\n    );\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === ExpressionScopeType.kParameterDeclaration;\n  }\n}\n\ntype ArrowHeadParsingParameterInitializerError =\n  | typeof Errors.AwaitExpressionFormalParameter\n  | typeof Errors.YieldInParameter;\ntype ArrowHeadParsingDeclarationError =\n  | ArrowHeadParsingParameterInitializerError\n  | typeof Errors.InvalidParenthesizedAssignment\n  | typeof Errors.AwaitBindingIdentifier;\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  declarationErrors: Map<number, [ParseErrorConstructor<{}>, Position]> =\n    new Map();\n  constructor(\n    type:\n      | ExpressionScopeType.kMaybeArrowParameterDeclaration\n      | ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration,\n  ) {\n    super(type);\n  }\n  recordDeclarationError(\n    ParsingErrorClass: ParseErrorConstructor<{}>,\n    {\n      at,\n    }: {\n      at: Position;\n    },\n  ) {\n    const index = at.index;\n\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index: number) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(\n    iterator: (a: [ArrowHeadParsingDeclarationError, Position]) => void,\n  ) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\n\nexport default class ExpressionScopeHandler {\n  parser: Tokenizer;\n  stack: Array<ExpressionScope> = [new ExpressionScope()];\n\n  constructor(parser: Tokenizer) {\n    this.parser = parser;\n  }\n  enter(scope: ExpressionScope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  /**\n   * Record likely parameter initializer errors\n   *\n   * When current scope is a ParameterDeclaration, the error will be thrown immediately,\n   * otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and\n   * MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.\n   */\n  recordParameterInitializerError(\n    toParseError: ArrowHeadParsingParameterInitializerError,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const origin = { at: node.loc.start };\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        /*:: invariant(scope.type == ExpressionScopeType.kExpression) */\n        // Type-Expression is the boundary where initializer error can populate to\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n\n  /**\n   * Record errors that must be thrown if the current pattern ends up being an arrow\n   * function parameter. This is used to record parenthesized identifiers, and to record\n   * \"a as T\" and \"<T> a\" type assertions when parsing typescript.\n   *\n   * A parenthesized identifier (or type assertion) in LHS can be ambiguous because the assignment\n   * can be transformed to an assignable later, but not vice versa:\n   * For example, in `([(a) = []] = []) => {}`, we think `(a) = []` is an LHS in `[(a) = []]`,\n   * an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,\n   * and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the\n   * location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration\n   * and MaybeAsyncArrowParameterDeclaration\n   *\n   * Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we\n   * validate arrow head parsing scope before exit, and then the LHS will be unambiguous:\n   * For example, in `( x = ( [(a) = []] = [] ) ) => {}`, we should not record `(a)` in `( x = ... ) =>`\n   * arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment\n   * expression and can not be cast to pattern\n   */\n  recordArrowParameterBindingError(\n    error: ParseErrorConstructor<{}>,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const { stack } = this;\n    const scope: ExpressionScope = stack[stack.length - 1];\n    const origin = { at: node.loc.start };\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Record likely async arrow parameter errors\n   *\n   * Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration\n   * scope until an Expression scope is seen.\n   */\n  recordAsyncArrowParametersError({ at }: { at: Position }): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (\n        scope.type === ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration\n      ) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at });\n      }\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern(): void {\n    const { stack } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, { at: loc });\n      // iterate from parent scope\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\n\nexport function newParameterDeclarationScope() {\n  return new ExpressionScope(ExpressionScopeType.kParameterDeclaration);\n}\n\nexport function newArrowHeadScope() {\n  return new ArrowHeadParsingScope(\n    ExpressionScopeType.kMaybeArrowParameterDeclaration,\n  );\n}\n\nexport function newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(\n    ExpressionScopeType.kMaybeAsyncArrowParameterDeclaration,\n  );\n}\n\nexport function newExpressionScope() {\n  return new ExpressionScope();\n}\n", "// ProductionParameterHandler is a stack fashioned production parameter tracker\n// https://tc39.es/ecma262/#sec-grammar-notation\n// The tracked parameters are defined above.\n//\n// Whenever [+Await]/[+Yield] appears in the right-hand sides of a production,\n// we must enter a new tracking stack. For example when parsing\n//\n// AsyncFunctionDeclaration [Yield, Await]:\n//   async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await]\n//     ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }\n//\n// we must follow such process:\n//\n// 1. parse async keyword\n// 2. parse function keyword\n// 3. parse bindingIdentifier <= inherit current parameters: [?Await]\n// 4. enter new stack with (PARAM_AWAIT)\n// 5. parse formal parameters <= must have [Await] parameter [+Await]\n// 6. parse function body\n// 7. exit current stack\n\nexport const enum ParamKind {\n  // Initial Parameter flags\n  PARAM = 0b0000,\n  // track [Yield] production parameter\n  PARAM_YIELD = 0b0001,\n  // track [Await] production parameter\n  PARAM_AWAIT = 0b0010,\n  // track [Return] production parameter\n  PARAM_RETURN = 0b0100,\n  // track [In] production parameter\n  PARAM_IN = 0b1000,\n}\n\n// todo(flow->ts) - check if more granular type can be used,\n//  type below is not good because things like PARAM_AWAIT|PARAM_YIELD are not included\n// export type ParamKind =\n//   | typeof PARAM\n//   | typeof PARAM_AWAIT\n//   | typeof PARAM_IN\n//   | typeof PARAM_RETURN\n//   | typeof PARAM_YIELD;\n\nexport default class ProductionParameterHandler {\n  stacks: Array<ParamKind> = [];\n  enter(flags: ParamKind) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags(): ParamKind {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_AWAIT) > 0;\n  }\n\n  get hasYield(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_YIELD) > 0;\n  }\n\n  get hasReturn(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_RETURN) > 0;\n  }\n\n  get hasIn(): boolean {\n    return (this.currentFlags() & ParamKind.PARAM_IN) > 0;\n  }\n}\n\nexport function functionFlags(\n  isAsync: boolean,\n  isGenerator: boolean,\n): ParamKind {\n  return (\n    (isAsync ? ParamKind.PARAM_AWAIT : 0) |\n    (isGenerator ? ParamKind.PARAM_YIELD : 0)\n  );\n}\n", "import type { Position } from \"../util/location.ts\";\nimport {\n  tokenIsLiteralPropertyName,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport Tokenizer from \"../tokenizer/index.ts\";\nimport type State from \"../tokenizer/state.ts\";\nimport type {\n  EstreePropertyDefinition,\n  Node,\n  ObjectProperty,\n} from \"../types.ts\";\nimport { lineBreak, skipWhiteSpaceToLineBreak } from \"../util/whitespace.ts\";\nimport { isIdentifierChar } from \"../util/identifier.ts\";\nimport ClassScopeHandler from \"../util/class-scope.ts\";\nimport ExpressionScopeHandler from \"../util/expression-scope.ts\";\nimport { ScopeFlag } from \"../util/scopeflags.ts\";\nimport ProductionParameterHandler, {\n  ParamKind,\n} from \"../util/production-parameter.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n} from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nimport type ScopeHandler from \"../util/scope.ts\";\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node;\n  error: Error;\n  thrown: Thrown;\n  aborted: Aborted;\n  failState: FailState;\n};\n\n// ## Parser utilities\n\nexport default abstract class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  abstract getScopeHandler(): { new (...args: any): ScopeHandler };\n\n  addExtra(\n    node: Partial<Node>,\n    key: string,\n    value: any,\n    enumerable: boolean = true,\n  ): void {\n    if (!node) return;\n\n    const extra = (node.extra = node.extra || {});\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, { enumerable, value });\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(token: TokenType): boolean {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(\n        isIdentifierChar(nextCh) ||\n        // check if `nextCh is between 0xd800 - 0xdbff,\n        // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n        // returns true\n        (nextCh & 0xfc00) === 0xd800\n      );\n    }\n    return false;\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(token: TokenType): boolean {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(\n    token: TokenType,\n    toParseError?: ParseErrorConstructor<any>,\n  ): void {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, { at: this.state.startLoc });\n      }\n      this.unexpected(null, token);\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.lastTokEndLoc.index, this.state.start),\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(Errors.MissingSemicolon, { at: this.state.lastTokEndLoc });\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, loc?: Position | null): void {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T extends Node | ReadonlyArray<Node>>(\n    fn: (abort: (node?: T) => never) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, ParseError<any>, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: {\n      node: T | null;\n    } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        // tokensLength should be preserved during error recovery mode\n        // since the parser does not halt and will instead parse the\n        // remaining tokens\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        // @ts-expect-error casting general syntax error to parse error\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ExpressionErrors | undefined | null,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n    } = refExpressionErrors;\n\n    const hasErrors =\n      !!shorthandAssignLoc ||\n      !!doubleProtoLoc ||\n      !!optionalParametersLoc ||\n      !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc,\n      });\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, { at: doubleProtoLoc });\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc });\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  /**\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): boolean {\n    return node.type === \"PrivateName\";\n  }\n\n  /**\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: Node): string {\n    return node.id.name;\n  }\n\n  /**\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isObjectProperty(\n    node: Node,\n  ): node is ObjectProperty | EstreePropertyDefinition {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): boolean {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    this: Parser,\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = ParamKind.PARAM;\n    if (this.inModule) {\n      paramFlags |= ParamKind.PARAM_AWAIT;\n    }\n    this.scope.enter(ScopeFlag.PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors: ExpressionErrors) {\n    const { privateKeyLoc } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track ambiguous patterns\n * When we are sure the parsed pattern is a RHS, which means it is not a pattern,\n * we will throw on this position on invalid assign syntax, otherwise it will be reset to -1\n *\n * Types of ExpressionErrors:\n *\n * - **shorthandAssignLoc**: track initializer `=` position\n * - **doubleProtoLoc**: track the duplicate `__proto__` key position\n * - **privateKey**: track private key `#p` position\n * - **optionalParametersLoc**: track the optional parameter (`?`).\n * It's only used by typescript and flow plugins\n */\nexport class ExpressionErrors {\n  shorthandAssignLoc: Position | undefined | null = null;\n  doubleProtoLoc: Position | undefined | null = null;\n  privateKeyLoc: Position | undefined | null = null;\n  optionalParametersLoc: Position | undefined | null = null;\n}\n", "import type Parser from \"./index.ts\";\nimport UtilParser from \"./util.ts\";\nimport { SourceLocation, type Position } from \"../util/location.ts\";\nimport type { Comment, Node as NodeType, NodeBase } from \"../types.ts\";\n\n// Start an AST node, attaching a start offset.\n\nclass Node implements NodeBase {\n  constructor(parser: Parser, pos: number, loc: Position) {\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser?.options.ranges) this.range = [pos, 0];\n    if (parser?.filename) this.loc.filename = parser.filename;\n  }\n\n  type: string = \"\";\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n  declare range: [number, number];\n  declare leadingComments: Array<Comment>;\n  declare trailingComments: Array<Comment>;\n  declare innerComments: Array<Comment>;\n  declare extra: {\n    [key: string]: any;\n  };\n}\nconst NodePrototype = Node.prototype;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error __clone is not defined in Node prototype\n  NodePrototype.__clone = function (): Node {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this) as (keyof Node)[];\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // Do not clone comments that are already attached to the node\n      if (\n        key !== \"leadingComments\" &&\n        key !== \"trailingComments\" &&\n        key !== \"innerComments\"\n      ) {\n        // @ts-expect-error cloning this to newNode\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node: any): any {\n  return cloneIdentifier(node);\n}\n\nexport function cloneIdentifier(node: any): any {\n  // We don't need to clone `typeAnnotations` and `optional`: because\n  // cloneIdentifier is only used in object shorthand and named import/export.\n  // Neither of them allow type annotations after the identifier or optional identifier\n  const { type, start, end, loc, range, extra, name } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\n\nexport function cloneStringLiteral(node: any): any {\n  const { type, start, end, loc, range, extra } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    // estree set node.raw instead of node.extra\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\n\nexport type Undone<T extends NodeType> = Omit<T, \"type\">;\n\nexport abstract class NodeUtils extends UtilParser {\n  startNode<T extends NodeType>(): Undone<T> {\n    // @ts-expect-error cast Node as Undone<T>\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt<T extends NodeType>(loc: Position): Undone<T> {\n    // @ts-expect-error cast Node as Undone<T>\n    return new Node(this, loc.index, loc);\n  }\n\n  /** Start a new node with a previous node's location. */\n  startNodeAtNode<T extends NodeType>(type: Undone<NodeType>): Undone<T> {\n    return this.startNodeAt(type.loc.start);\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  finishNode<T extends NodeType>(node: Undone<T>, type: T[\"type\"]): T {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  // Finish node at given position\n\n  finishNodeAt<T extends NodeType>(\n    node: Omit<T, \"type\">,\n    type: T[\"type\"],\n    endLoc: Position,\n  ): T {\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\n      throw new Error(\n        \"Do not call finishNode*() twice on the same node.\" +\n          \" Instead use resetEndLocation() or change type directly.\",\n      );\n    }\n    // @ts-expect-error migrate to Babel types AST typings\n    node.type = type;\n    // @ts-expect-error migrate to Babel types AST typings\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node as T);\n    return node as T;\n  }\n\n  resetStartLocation(node: NodeBase, startLoc: Position): void {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n\n  resetEndLocation(\n    node: NodeBase,\n    endLoc: Position = this.state.lastTokEndLoc,\n  ): void {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\n", "/*:: declare var invariant; */\n\nimport type Parser from \"../../parser/index.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier.ts\";\nimport FlowScopeHandler from \"./scope.ts\";\nimport { BindingFlag, ScopeFlag } from \"../../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  // TODO: When we get proper string enums in typescript make this ReservedType.\n  // Not really worth it to do the whole $Values dance with reservedTypes set.\n  AssignReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports:\n    \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =>\n    `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName,\n  }: {\n    invalidEnumType: string;\n    enumName: string;\n  }) =>\n    `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n\n  // TODO: When moving to typescript, we should either have each of the\n  // following errors only accept the specific strings they want:\n  //\n  // ...PrimaryType: explicitType: \"string\" | \"number\" | \"boolean\"\n  // ...SymbolType: explicitType: \"symbol\"\n  // ...UnknownType: explicitType: null\n  //\n  // Or, alternatively, merge these three errors together into one\n  // `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`\n  // without alteration, and then just have its message change based on the\n  // explicitType.\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion,\n  }: {\n    enumName: string;\n    memberName: string;\n    suggestion: string;\n  }) =>\n    `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n  }) =>\n    `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: {\n    message:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    // For consistency in TypeScript and Flow error codes\n    ...(!process.env.BABEL_8_BREAKING\n      ? { reasonCode: \"OptionalBindingPattern\" }\n      : {}),\n  },\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion,\n  }: {\n    unsupportedExportKind: string;\n    suggestion: string;\n  }) =>\n    `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (c: T, b: number, a: T[]) => boolean | undefined | null,\n): [T[], T[]] {\n  const list1: T[] = [];\n  const list2: T[] = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\n\ntype EnumContext = {\n  enumName: string;\n  explicitType: EnumExplicitType;\n  memberName: string;\n};\n\ntype EnumMemberInit =\n  | {\n      type: \"number\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"string\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"boolean\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"invalid\";\n      loc: Position;\n    }\n  | {\n      type: \"none\";\n      loc: Position;\n    };\n\nexport default (superClass: typeof Parser) =>\n  class FlowParserMixin extends superClass implements Parser {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): {\n      new (...args: any): FlowScopeHandler;\n    } {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowPredicate {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStart > moduloLoc.index + 1) {\n        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n          at: moduloLoc,\n        });\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = super.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [\n      N.FlowType | undefined | null,\n      N.FlowPredicate | undefined | null,\n    ] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(\n      node: Undone<N.FlowDeclareClass>,\n    ): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: Undone<N.FlowDeclareFunction>,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode<N.TypeAnnotation>();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [typeNode.returnType, node.predicate] =\n        this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_FLOW_DECLARE_FN,\n        node.id.loc.start,\n      );\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: Undone<N.FlowDeclare>,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(FlowErrors.NestedDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: Undone<N.FlowDeclareVariable>,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_VAR,\n        node.id.loc.start,\n      );\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(\n      node: Undone<N.FlowDeclareModule>,\n    ): N.FlowDeclareModule {\n      this.scope.enter(ScopeFlag.OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = super.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      // @ts-expect-error refine typings\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode<N.ImportDeclaration>();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          super.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n          // @ts-expect-error refine typings\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind: \"CommonJS\" | \"ES\" | null = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n              at: bodyElement,\n            });\n          }\n          if (kind === \"ES\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: Undone<N.FlowDeclareExportDeclaration>,\n      insideModule?: boolean | null,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value as\n            | \"const\"\n            | \"let\"\n            | \"type\"\n            | \"interface\";\n          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n            at: this.state.startLoc,\n            unsupportedExportKind: label,\n            suggestion: exportSuggestions[label],\n          });\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(\n            node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n            /* decorators */ null,\n          );\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n\n          return node as N.Node;\n        }\n      }\n\n      this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: Undone<N.FlowDeclareModuleExports>,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: Undone<N.FlowDeclareTypeAlias>,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      const finished = this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareTypeAlias\";\n      return finished;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: Undone<N.FlowDeclareOpaqueType>,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      const finished = this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareOpaqueType\";\n      return finished;\n    }\n\n    flowParseDeclareInterface(\n      node: Undone<N.FlowDeclareInterface>,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(node: Undone<N.FlowDeclare>, isClass: boolean): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BindingFlag.TYPE_FUNCTION : BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (isClass) {\n        node.implements = [];\n        node.mixins = [];\n\n        if (this.eatContextual(tt._mixins)) {\n          do {\n            node.mixins.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n\n        if (this.eatContextual(tt._implements)) {\n          do {\n            node.implements.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: Undone<N.FlowInterface>): N.FlowInterface {\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n          at: this.state.startLoc,\n        });\n      }\n    }\n\n    checkReservedType(word: string, startLoc: Position, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        {\n          at: startLoc,\n          reservedType: word,\n        },\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(\n        this.state.value,\n        this.state.startLoc,\n        declaration,\n      );\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: Undone<N.FlowTypeAlias>): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: Undone<N.FlowOpaqueType>,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {\n      const nodeStartLoc = this.state.startLoc;\n\n      const node = this.startNode<N.TypeParameter>();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      // @ts-expect-error migrate to Babel types\n      node.variance = variance;\n      // @ts-expect-error migrate to Babel types\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        // @ts-expect-error migrate to Babel types\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc });\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode<N.TypeParameterDeclaration>();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode<N.FlowInterfaceType>();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? super.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: Undone<N.FlowObjectTypeIndexer>,\n      isStatic: boolean,\n      variance?: N.FlowVariance | null,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: Undone<N.FlowObjectTypeInternalSlot>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: Undone<N.FlowFunctionTypeAnnotation>,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: Undone<N.FlowObjectTypeCallProperty>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean;\n      allowExact: boolean;\n      allowSpread: boolean;\n      allowProto: boolean;\n      allowInexact: boolean;\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStartLoc: Position | undefined | null = null;\n        let inexactStartLoc: Position | undefined | null = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStartLoc = this.state.startLoc;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.loc.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStartLoc,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStartLoc = this.state.lastTokStartLoc;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStartLoc &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n            at: inexactStartLoc,\n          });\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: Undone<N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty>,\n      isStatic: boolean,\n      protoStartLoc: Position | undefined | null,\n      variance: N.FlowVariance | undefined | null,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(FlowErrors.InexactInsideNonObject, {\n              at: this.state.lastTokStartLoc,\n            });\n          } else if (!allowInexact) {\n            this.raise(FlowErrors.InexactInsideExact, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (variance) {\n            this.raise(FlowErrors.InexactVariance, { at: variance });\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(FlowErrors.UnexpectedSpreadType, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.SpreadVariance, { at: variance });\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStartLoc != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(FlowErrors.ThisParamBannedInConstructor, {\n              at: node.value.this,\n            });\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: Undone<\n        N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty\n      >,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n          { at: property.value.this },\n        );\n      }\n\n      if (length !== paramCount) {\n        this.raise(\n          property.kind === \"get\"\n            ? Errors.BadGetterArity\n            : Errors.BadSetterArity,\n          { at: property },\n        );\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(Errors.BadSetterRestParameter, { at: property });\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startLoc ??= this.state.startLoc;\n      let node: N.Identifier | N.FlowQualifiedTypeIdentifier =\n        id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt<N.FlowQualifiedTypeIdentifier>(startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode<N.FlowFunctionTypeParam>();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node });\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node });\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[];\n      rest: N.FlowFunctionTypeParam | undefined | null;\n      _this: N.FlowFunctionTypeParam | undefined | null;\n    } {\n      let rest: N.FlowFunctionTypeParam | undefined | null = null;\n      let _this: N.FlowFunctionTypeParam | undefined | null = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startLoc: Position,\n      node: Undone<N.FlowTypeAnnotation>,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt:\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(\n            node as Undone<N.BooleanLiteralTypeAnnotation>,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n              at: this.state.startLoc,\n            });\n          }\n          this.unexpected();\n          return;\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node as Undone<N.Identifier>, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt(startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode<N.FlowTypeAnnotation>();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    flowParseVariance(): N.FlowVariance | undefined | null {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode<N.FlowVariance>();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        return this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n        return;\n      }\n\n      super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode<N.TypeAnnotation>();\n\n        [\n          typeNode.typeAnnotation,\n          // @ts-expect-error predicate may not exist\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatementLike(flags: ParseStatementFlag): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode<N.FlowInterface>();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatementLike(flags);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            // @ts-expect-error: refine typings\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(FlowErrors.AmbiguousConditionalArrow, {\n            at: state.startLoc,\n          });\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression;\n      failed: boolean;\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            // @ts-expect-error: refine typings\n            this.finishArrowValidation(node);\n          } else {\n            // @ts-expect-error: refine typings\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        node.params as any as N.Expression[],\n        node.extra?.trailingCommaLoc,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(\n      node: Undone<N.Node>,\n      parse: () => T,\n    ): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          super.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          // @ts-expect-error: refine typings\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        // @ts-expect-error: refine typings\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(node)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const { startLoc } = this.state;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(startLoc);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n    ) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const { startLoc } = this.state;\n      if (this.isContextual(tt._declare)) {\n        if (super.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(FlowErrors.DeclareClassElement, { at: startLoc });\n        } else if (member.value) {\n          this.raise(FlowErrors.DeclareClassFieldInitializer, {\n            at: member.value,\n          });\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(Errors.InvalidIdentifier, {\n          at: this.state.curPosition(),\n          identifierName: fullWord,\n        });\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          this.finishOp(tt.questionDot, 2);\n        } else {\n          // allow double nullable types in Flow: ??string\n          this.finishOp(tt.question, 1);\n        }\n      } else if (\n        isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))\n      ) {\n        this.state.pos += 2; // eat \"@@\"\n        this.readIterator();\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (\n        !isLHS &&\n        node.type === \"AssignmentExpression\" &&\n        node.left.type === \"TypeCastExpression\"\n      ) {\n        node.left = this.typeCastToParameter(node.left);\n      }\n      super.toAssignable(node, isLHS);\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: ReadonlyArray<N.Expression | undefined | null>,\n      isParenthesizedExpr?: boolean,\n    ): ReadonlyArray<N.Expression | undefined | null> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(FlowErrors.TypeCastInPattern, {\n            at: expr.typeAnnotation,\n          });\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingFlag) {\n      return (\n        type === \"TypeCastExpression\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n        // estree support\n      } else if (\n        // @ts-expect-error TS does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        // @ts-expect-error estree\n        method.value.params\n      ) {\n        // @ts-expect-error estree\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param });\n        } else if (this.isThisParam(param)) {\n          this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectMethod | N.ObjectProperty {\n      if ((prop as any).variance) {\n        this.unexpected((prop as any).variance.loc.start);\n      }\n      delete (prop as any).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      const result = super.parseObjPropValue(\n        prop,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        // @ts-expect-error: refine typings\n        (result.value || result).typeParameters = typeParameters;\n      }\n      return result;\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(FlowErrors.PatternIsOptional, { at: param });\n        }\n        if (this.isThisParam(param)) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param });\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param });\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamNoDefault, { at: param });\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: N.Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(FlowErrors.TypeBeforeInitializer, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(FlowErrors.ImportReflectionHasImportType, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n\n    parseImportSpecifierLocal<\n      T extends\n        | N.ImportSpecifier\n        | N.ImportDefaultSpecifier\n        | N.ImportNamespaceSpecifier,\n    >(node: N.ImportDeclaration, specifier: Undone<T>, type: T[\"type\"]): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      node.specifiers.push(this.finishImportSpecifier(specifier, type));\n    }\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        if (!isExport) return true;\n        const ch = this.lookaheadCharCode();\n        return ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        if (!phase && this.match(tt._default)) {\n          // TODO: Align with our TS AST and always add .exportKind\n          return;\n        }\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? phase : \"value\";\n      } else {\n        if (phase === \"type\" && this.match(tt.star)) this.unexpected();\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingFlag | undefined,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(Errors.ImportBindingIsString, {\n              at: specifier,\n              importName: firstIdent.value,\n            });\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n          at: specifier,\n        });\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.loc.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.loc.start,\n          true,\n          true,\n        );\n      }\n\n      return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(\n      node: Undone<N.Function>,\n      isConstructor: boolean,\n    ): void {\n      // @ts-expect-error kind may not index node\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        // @ts-expect-error refine typings\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters: N.TypeParameterDeclaration;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression:\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n          | undefined\n          | null = null;\n\n        if (\n          arrow.node &&\n          // @ts-expect-error: refine tryParse typings\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            // @ts-expect-error: refine tryParse typings\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n                { at: typeParameters },\n              );\n            }\n            // @ts-expect-error: refine tryParse typings\n            return arrow.node;\n          }\n\n          // @ts-expect-error: refine typings\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n          at: typeParameters,\n        });\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error todo(flow->ts)\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode<N.TypeAnnotation>();\n\n          [\n            typeNode.typeAnnotation,\n            // @ts-expect-error (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        // @ts-expect-error todo(flow->ts)\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Pattern[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction?: boolean | null,\n      strictModeChanged: boolean = true,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });\n        }\n      }\n\n      super.checkParams(\n        node,\n        allowDuplicates,\n        isArrowFunction,\n        strictModeChanged,\n      );\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls?: boolean | null,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startLoc.index) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startLoc);\n        node.callee = base;\n        node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        // @ts-expect-error: refine tryParse typings\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          // @ts-expect-error: refine tryParse typings\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node = this.startNodeAt<N.OptionalCallExpression>(startLoc);\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (!noCalls && this.shouldParseTypes() && this.match(tt.lt)) {\n        const node = this.startNodeAt<\n          N.OptionalCallExpression | N.CallExpression\n        >(startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) {\n            (node as Undone<N.OptionalCallExpression>).optional = false;\n          }\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n      this.parseFunctionParams(node, false);\n      if (!this.parseArrow(node)) return;\n      return super.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(FlowErrors.UnterminatedFlowComment, {\n          at: this.state.curPosition(),\n        });\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | undefined {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          throw this.raise(FlowErrors.NestedFlowComment, {\n            at: this.state.startLoc,\n          });\n        }\n        this.hasFlowCommentCompletion();\n        const commentSkip = this.skipFlowComment();\n        if (commentSkip) {\n          this.state.pos += commentSkip;\n          this.state.hasFlowComment = true;\n        }\n        return;\n      }\n\n      return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n    }\n\n    skipFlowComment(): number | false {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          // @ts-expect-error testing whether a number is included\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition(),\n        });\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n        at: loc,\n        memberName,\n        enumName,\n      });\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      loc: Position,\n      enumContext: EnumContext,\n    ) {\n      return this.raise(\n        !enumContext.explicitType\n          ? FlowErrors.EnumInvalidMemberInitializerUnknownType\n          : enumContext.explicitType === \"symbol\"\n            ? FlowErrors.EnumInvalidMemberInitializerSymbolType\n            : FlowErrors.EnumInvalidMemberInitializerPrimaryType,\n        {\n          at: loc,\n          ...enumContext,\n        },\n      );\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n        at: loc,\n        enumName,\n        memberName,\n      });\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitialized(\n      node: N.Node,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {\n        at: node,\n        enumName,\n      });\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startLoc = this.state.startLoc;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        default:\n          return { type: \"invalid\", loc: startLoc };\n      }\n    }\n\n    flowEnumMemberRaw(): {\n      id: N.Node;\n      init: EnumMemberInit;\n    } {\n      const loc = this.state.startLoc;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\" as const, loc };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      loc: Position,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(loc, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string;\n      explicitType: EnumExplicitType;\n    }): {\n      members: {\n        booleanMembers: Array<N.Node>;\n        numberMembers: Array<N.Node>;\n        stringMembers: Array<N.Node>;\n        defaultedMembers: Array<N.Node>;\n      };\n      hasUnknownMembers: boolean;\n    } {\n      const seenNames = new Set();\n      const members = {\n        // @ts-expect-error: migrate to Babel types\n        booleanMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        numberMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        stringMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.raise(FlowErrors.EnumInvalidMemberName, {\n            at: id,\n            memberName,\n            suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n            enumName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.raise(FlowErrors.EnumDuplicateMemberName, {\n            at: id,\n            memberName,\n            enumName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.loc,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.loc,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string;\n    }): EnumExplicitType {\n      if (!this.eatContextual(tt._of)) return null;\n\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n          at: this.state.startLoc,\n          enumName,\n        });\n      }\n\n      const { value } = this.state;\n      this.next();\n\n      if (\n        value !== \"boolean\" &&\n        value !== \"number\" &&\n        value !== \"string\" &&\n        value !== \"symbol\"\n      ) {\n        this.raise(FlowErrors.EnumInvalidExplicitType, {\n          at: this.state.startLoc,\n          enumName,\n          invalidEnumType: value,\n        });\n      }\n\n      return value;\n    }\n\n    flowEnumBody(node: Undone<N.Node>, id: N.Node): N.Node {\n      const enumName = id.name;\n      const nameLoc = id.loc.start;\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName,\n            });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: Undone<N.Node>): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), id);\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n", "const entities: {\n  __proto__: null;\n  [name: string]: string;\n} = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n} as const;\nexport default entities;\n", "import * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport {\n  tokenComesBeforeExpression,\n  tokenIsKeyword,\n  tokenLabelName,\n  type TokenType,\n  tt,\n} from \"../../tokenizer/types.ts\";\nimport type { TokContext } from \"../../tokenizer/context.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { isNewLine } from \"../../util/whitespace.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport type { Undone } from \"../../parser/node.ts\";\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty:\n    \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({ openingTagName }: { openingTagName: string }) =>\n    `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression:\n    \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  // FIXME: Unify with Errors.UnexpectedToken\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity,\n  }: {\n    unexpected: string;\n    HTMLEntity: string;\n  }) =>\n    `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue:\n    \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements:\n    \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n});\n\n/* eslint-disable sort-keys */\n\nfunction isFragment(object?: N.JSXElement | null): boolean {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport interface IJSXParserMixin {\n  jsxParseOpeningElementAfterName(\n    node: N.JSXOpeningElement,\n  ): N.JSXOpeningElement;\n}\n\nexport default (superClass: typeof Parser) =>\n  class JSXParserMixin extends superClass implements Parser, IJSXParserMixin {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(JsxErrors.UnterminatedJsxContent, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.canStartJSXElement) {\n                ++this.state.pos;\n                this.finishToken(tt.jsxTagStart);\n              } else {\n                super.getTokenFromCode(ch);\n              }\n              return;\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            this.finishToken(tt.jsxText, out);\n            return;\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              this.raise(JsxErrors.UnexpectedToken, {\n                at: this.state.curPosition(),\n                unexpected: this.input[this.state.pos],\n                HTMLEntity:\n                  ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\",\n              });\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(Errors.UnterminatedString, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      const startPos = ++this.state.pos;\n      if (this.codePointAtPos(this.state.pos) === charCodes.numberSign) {\n        ++this.state.pos;\n\n        let radix = 10;\n        if (this.codePointAtPos(this.state.pos) === charCodes.lowercaseX) {\n          radix = 16;\n          ++this.state.pos;\n        }\n\n        const codePoint = this.readInt(\n          radix,\n          /* len */ undefined,\n          /* forceLen */ false,\n          /* allowNumSeparator */ \"bail\",\n        );\n        if (\n          codePoint !== null &&\n          this.codePointAtPos(this.state.pos) === charCodes.semicolon\n        ) {\n          ++this.state.pos;\n          return String.fromCodePoint(codePoint);\n        }\n      } else {\n        let count = 0;\n        let semi = false;\n        while (\n          count++ < 10 &&\n          this.state.pos < this.length &&\n          !(semi = this.codePointAtPos(this.state.pos) == charCodes.semicolon)\n        ) {\n          ++this.state.pos;\n        }\n\n        if (semi) {\n          const desc = this.input.slice(startPos, this.state.pos);\n          const entity = XHTMLEntities[desc];\n          ++this.state.pos;\n\n          if (entity) {\n            return entity;\n          }\n        }\n      }\n\n      // Not a valid entity\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      this.finishToken(tt.jsxName, this.input.slice(start, this.state.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode();\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (tokenIsKeyword(this.state.type)) {\n        node.name = tokenLabelName(this.state.type);\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName(): N.JSXNamespacedName {\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt(startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression {\n      const startLoc = this.state.startLoc;\n      let node = this.jsxParseNamespacedName();\n      if (node.type === \"JSXNamespacedName\") {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt(startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue(): N.Expression {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.setContext(tc.brace);\n          this.next();\n          node = this.jsxParseExpressionContainer(node, tc.j_oTag);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(JsxErrors.AttributeIsEmpty, { at: node });\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(JsxErrors.UnsupportedJsxValue, {\n            at: this.state.startLoc,\n          });\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(this.state.lastTokEndLoc);\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: Undone<N.JSXSpreadChild>): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.setContext(tc.j_expr);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: Undone<N.JSXExpressionContainer>,\n      previousContext: TokContext,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(JsxErrors.UnexpectedSequenceExpression, {\n              at: expression.expressions[1],\n            });\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.setContext(previousContext);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute(): N.JSXAttribute {\n      const node = this.startNode();\n      if (this.match(tt.braceL)) {\n        this.setContext(tc.brace);\n        this.next();\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.setContext(tc.j_oTag);\n        this.state.canStartJSXElement = true;\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(startLoc: Position): N.JSXOpeningElement {\n      const node = this.startNodeAt<N.JSXOpeningElement | N.JSXOpeningFragment>(\n        startLoc,\n      );\n      if (this.eat(tt.jsxTagEnd)) {\n        // @ts-expect-error migrate to Babel types\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(\n        node as Undone<N.JSXOpeningElement>,\n      );\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: Undone<N.JSXOpeningElement>,\n    ): N.JSXOpeningElement {\n      const attributes: N.JSXAttribute[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(startLoc: Position): N.JSXClosingElement {\n      const node = this.startNodeAt(startLoc);\n      if (this.eat(tt.jsxTagEnd)) {\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startLoc: Position): N.JSXElement {\n      const node = this.startNodeAt(startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(startLoc);\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode<\n                N.JSXSpreadChild | N.JSXExpressionContainer\n              >();\n              this.setContext(tc.brace);\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(\n                  this.jsxParseExpressionContainer(node, tc.j_expr),\n                );\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              this.unexpected();\n          }\n        }\n\n        if (\n          isFragment(openingElement) &&\n          !isFragment(closingElement) &&\n          closingElement !== null\n        ) {\n          this.raise(JsxErrors.MissingClosingTagFragment, {\n            at: closingElement,\n          });\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name),\n          });\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(JsxErrors.MissingClosingTagElement, {\n              at: closingElement,\n              openingTagName: getQualifiedJSXName(openingElement.name),\n            });\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.match(tt.lt)) {\n        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n          at: this.state.startLoc,\n        });\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement {\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startLoc);\n    }\n\n    setContext(newContext: TokContext) {\n      const { context } = this.state;\n      context[context.length - 1] = newContext;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      if (this.match(tt.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.match(tt.lt) &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.replaceToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    skipSpace() {\n      const curContext = this.curContext();\n      if (!curContext.preserveSpace) super.skipSpace();\n    }\n\n    getTokenFromCode(code: number): void {\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        this.jsxReadToken();\n        return;\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          this.jsxReadWord();\n          return;\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          this.finishToken(tt.jsxTagEnd);\n          return;\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          this.jsxReadString(code);\n          return;\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.canStartJSXElement &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        this.finishToken(tt.jsxTagStart);\n        return;\n      }\n\n      super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      const { context, type } = this.state;\n      if (type === tt.slash && prevType === tt.jsxTagStart) {\n        // do not consider JSX expr -> JSX open tag -> ... anymore\n        // reconsider as closing tag context\n        context.splice(-2, 2, tc.j_cTag);\n        this.state.canStartJSXElement = false;\n      } else if (type === tt.jsxTagStart) {\n        // start opening tag context\n        context.push(tc.j_oTag);\n      } else if (type === tt.jsxTagEnd) {\n        const out = context[context.length - 1];\n        if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n          context.pop();\n          this.state.canStartJSXElement =\n            context[context.length - 1] === tc.j_expr;\n        } else {\n          this.setContext(tc.j_expr);\n          this.state.canStartJSXElement = true;\n        }\n      } else {\n        this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n      }\n    }\n  };\n", "import type { Position } from \"../../util/location.ts\";\nimport ScopeHandler, { Scope } from \"../../util/scope.ts\";\nimport { BindingFlag, ScopeFlag } from \"../../util/scopeflags.ts\";\nimport type * as N from \"../../types.ts\";\nimport { Errors } from \"../../parse-error.ts\";\n\nclass TypeScriptScope extends Scope {\n  types: Set<string> = new Set();\n\n  // enums (which are also in .types)\n  enums: Set<string> = new Set();\n\n  // const enums (which are also in .enums and .types)\n  constEnums: Set<string> = new Set();\n\n  // classes (which are also in .lexical) and interface (which are also in .types)\n  classes: Set<string> = new Set();\n\n  // namespaces and ambient functions (or classes) are too difficult to track,\n  // especially without type analysis.\n  // We need to track them anyway, to avoid \"X is not defined\" errors\n  // when exporting them.\n  exportOnlyBindings: Set<string> = new Set();\n}\n\n// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an\n// explanation of how typescript handles scope.\n\nexport default class TypeScriptScopeHandler extends ScopeHandler<TypeScriptScope> {\n  importsStack: Set<string>[] = [];\n\n  createScope(flags: ScopeFlag): TypeScriptScope {\n    this.importsStack.push(new Set()); // Always keep the top-level scope for export checks.\n\n    return new TypeScriptScope(flags);\n  }\n\n  enter(flags: ScopeFlag): void {\n    if (flags == ScopeFlag.TS_MODULE) {\n      this.importsStack.push(new Set());\n    }\n\n    super.enter(flags);\n  }\n\n  exit() {\n    const flags = super.exit();\n\n    if (flags == ScopeFlag.TS_MODULE) {\n      this.importsStack.pop();\n    }\n\n    return flags;\n  }\n\n  hasImport(name: string, allowShadow?: boolean) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n\n  declareName(name: string, bindingType: BindingFlag, loc: Position) {\n    if (bindingType & BindingFlag.FLAG_TS_IMPORT) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, {\n          at: loc,\n          identifierName: name,\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n\n    const scope = this.currentScope();\n    if (bindingType & BindingFlag.FLAG_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n\n    if (bindingType & BindingFlag.KIND_TYPE) {\n      if (!(bindingType & BindingFlag.KIND_VALUE)) {\n        // \"Value\" bindings have already been registered by the superclass.\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.add(name);\n    }\n    if (bindingType & BindingFlag.FLAG_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BindingFlag.FLAG_TS_CONST_ENUM) {\n      scope.constEnums.add(name);\n    }\n    if (bindingType & BindingFlag.FLAG_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(\n    scope: TypeScriptScope,\n    name: string,\n    bindingType: BindingFlag,\n  ): boolean {\n    if (scope.enums.has(name)) {\n      if (bindingType & BindingFlag.FLAG_TS_ENUM) {\n        // Enums can be merged with other enums if they are both\n        //  const or both non-const.\n        const isConst = !!(bindingType & BindingFlag.FLAG_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BindingFlag.FLAG_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        // Classes can be merged with interfaces\n        return !!(bindingType & BindingFlag.KIND_VALUE);\n      } else {\n        // Interface can be merged with other classes or interfaces\n        return false;\n      }\n    }\n    if (bindingType & BindingFlag.KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n\n    if (this.hasImport(name)) return;\n\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;\n    }\n\n    super.checkLocalExport(id);\n  }\n}\n", "import * as charCodes from \"charcodes\";\nimport { tt, type TokenType } from \"../tokenizer/types.ts\";\nimport type {\n  AssignmentPattern,\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Identifier,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  ObjectOrClassMember,\n  ClassMember,\n  ObjectMember,\n  TsNamedTypeElementBase,\n  PrivateName,\n  ObjectExpression,\n  ObjectPattern,\n  ArrayExpression,\n  ArrayPattern,\n} from \"../types.ts\";\nimport type { Pos, Position } from \"../util/location.ts\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier.ts\";\nimport { NodeUtils, type Undone } from \"./node.ts\";\nimport { BindingFlag } from \"../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"./util.ts\";\nimport { Errors, type LValAncestor } from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport const enum ParseBindingListFlags {\n  ALLOW_EMPTY = 1 << 0,\n  IS_FUNCTION_PARAMS = 1 << 1,\n  IS_CONSTRUCTOR_PARAMS = 1 << 2,\n}\n\nexport default abstract class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  abstract parseIdentifier(liberal?: boolean): Identifier;\n  abstract parseMaybeAssign(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseMaybeAssignAllowIn(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseObjectLike<T extends ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): T;\n  abstract parseObjPropValue(\n    prop: any,\n    startLoc: Position | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void;\n  abstract parsePropertyName(\n    prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,\n  ): Expression | Identifier;\n  abstract parsePrivateName(): PrivateName;\n  // Forward-declaration: defined in statement.js\n  abstract parseDecorator(): Decorator;\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n   *\n   * - Parenthesized Destructuring patterns\n   * - RestElement is not the last element\n   * - Missing `=` in assignment pattern\n   *\n   * NOTE: There is a corresponding \"isAssignable\" method.\n   * When this one is updated, please check if also that one needs to be updated.\n   *\n   * @param node The expression atom\n   * @param isLHS Whether we are parsing a LeftHandSideExpression.\n   *              If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`\n   *              If isLHS is `false`, we are in an arrow function parameters list.\n   */\n  toAssignable(node: Node, isLHS: boolean = false): void {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordArrowParameterBindingError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(\n            Errors.InvalidParenthesizedAssignment,\n            { at: node },\n          );\n        } else if (\n          parenthesized.type !== \"MemberExpression\" &&\n          !this.isOptionalMemberExpression(parenthesized)\n        ) {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            prop.type === \"RestElement\" &&\n            node.extra?.trailingCommaLoc\n          ) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc,\n            });\n          }\n        }\n        break;\n\n      case \"ObjectProperty\": {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n\n      case \"SpreadElement\": {\n        throw new Error(\n          \"Internal @babel/parser error (this is a bug, please report it).\" +\n            \" SpreadElement should be converted by .toAssignable's caller.\",\n        );\n      }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(\n          node.elements,\n          node.extra?.trailingCommaLoc,\n          isLHS,\n        );\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end });\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod,\n        { at: prop.key },\n      );\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, /* allowPattern */ false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, { at: prop });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: Expression[],\n    trailingCommaLoc: Position | undefined | null,\n    isLHS: boolean,\n  ): void {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, /* allowPattern */ true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, { at: elt });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc });\n        }\n      }\n    }\n  }\n\n  isAssignable(node: Node, isBinding?: boolean): boolean {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return (node.properties as ObjectExpression[\"properties\"]).every(\n          (prop, i) => {\n            return (\n              prop.type !== \"ObjectMethod\" &&\n              (i === last || prop.type !== \"SpreadElement\") &&\n              this.isAssignable(prop)\n            );\n          },\n        );\n      }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return (node as ArrayExpression).elements.every(\n          element => element === null || this.isAssignable(element),\n        );\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isParenthesizedExpr?: boolean,\n  ): ReadonlyArray<Expression | undefined | null> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): SpreadElement {\n    const node = this.startNode<SpreadElement>();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(this: Parser): RestElement {\n    const node = this.startNode<RestElement>();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(this: Parser): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode<ArrayPattern>();\n        this.next();\n        // @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          ParseBindingListFlags.ALLOW_EMPTY,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    this: Parser,\n    close: TokenType,\n    closeCharCode: (typeof charCodes)[keyof typeof charCodes],\n    flags: ParseBindingListFlags,\n  ): Array<Pattern | TSParameterProperty> {\n    const allowEmpty = flags & ParseBindingListFlags.ALLOW_EMPTY;\n\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        elts.push(\n          this.parseAssignableListItemTypes(this.parseRestBinding(), flags),\n        );\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc,\n          });\n        }\n        // invariant: hasPlugin(\"decorators-legacy\")\n        while (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  parseBindingRestProperty(\n    this: Parser,\n    prop: Undone<RestElement>,\n  ): RestElement {\n    this.next(); // eat '...'\n    // Don't use parseRestBinding() as we only allow Identifier here.\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingProperty\n  parseBindingProperty(this: Parser): ObjectMember | RestElement {\n    const prop = this.startNode<ObjectMember | RestElement>();\n    const { type, startLoc } = this.state;\n    if (type === tt.ellipsis) {\n      return this.parseBindingRestProperty(prop as Undone<RestElement>);\n    } else if (type === tt.privateName) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      (prop as Undone<ObjectMember>).key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop as Undone<ObjectMember>);\n    }\n    (prop as Undone<ObjectMember>).method = false;\n    return this.parseObjPropValue(\n      prop as Undone<ObjectMember>,\n      startLoc,\n      false /* isGenerator */,\n      false /* isAsync */,\n      true /* isPattern */,\n      false /* isAccessor */,\n    );\n  }\n\n  parseAssignableListItem(\n    this: Parser,\n    flags: ParseBindingListFlags,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left, flags);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseAssignableListItemTypes(\n    param: Pattern,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    flags: ParseBindingListFlags,\n  ): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    this: Parser,\n    startLoc?: Position | null,\n    left?: Pattern | null,\n  ): Pattern {\n    startLoc ??= this.state.startLoc;\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt<AssignmentPattern>(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  /**\n   * Return information use in determining whether a Node of a given type is an LVal,\n   * possibly given certain additional context information.\n   *\n   * Subclasser notes: This method has kind of a lot of mixed, but related,\n   * responsibilities. If we can definitively determine with the information\n   * provided that this either *is* or *isn't* a valid `LVal`, then the return\n   * value is easy: just return `true` or `false`. However, if it is a valid\n   * LVal *ancestor*, and thus its descendants must be subsequently visited to\n   * continue the \"investigation\", then this method should return the relevant\n   * child key as a `string`. In some special cases, you additionally want to\n   * convey that this node should be treated as if it were parenthesized. In\n   * that case, a tuple of [key: string, parenthesized: boolean] is returned.\n   * The `string`-only return option is actually just a shorthand for:\n   * `[key: string, parenthesized: false]`.\n   *\n   * @param type A Node `type` string\n   * @param isUnparenthesizedInAssign\n   *        Whether the node in question is unparenthesized and its parent\n   *        is either an assignment pattern or an assignment expression.\n   * @param binding\n   *        The binding operation that is being considered for this potential\n   *        LVal.\n   * @returns `true` or `false` if we can immediately determine whether the node\n   *          type in question can be treated as an `LVal`.\n   *          A `string` key to traverse if we must check this child.\n   *          A `[string, boolean]` tuple if we need to check this child and\n   *          treat is as parenthesized.\n   */\n  isValidLVal(\n    type: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isUnparenthesizedInAssign: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    binding: BindingFlag,\n  ): string | boolean {\n    return getOwn(\n      {\n        AssignmentPattern: \"left\",\n        RestElement: \"argument\",\n        ObjectProperty: \"value\",\n        ParenthesizedExpression: \"expression\",\n        ArrayPattern: \"elements\",\n        ObjectPattern: \"properties\",\n      },\n      // @ts-expect-error refine string to enum\n      type,\n    );\n  }\n\n  // Overridden by the estree plugin\n  isOptionalMemberExpression(expression: Node) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n\n  /**\n   * Verify that a target expression is an lval (something that can be assigned to).\n   *\n   * @param expression The expression in question to check.\n   * @param options A set of options described below.\n   * @param options.in\n   *        The relevant ancestor to provide context information for the error\n   *        if the check fails.\n   * @param options.binding\n   *        The desired binding type. If the given expression is an identifier\n   *        and `binding` is not `BindingFlag.TYPE_NONE`, `checkLVal` will register binding\n   *        to the parser scope See also `src/util/scopeflags.js`\n   * @param options.checkClashes\n   *        An optional string set to check if an identifier name is included.\n   *        `checkLVal` will add checked identifier name to `checkClashes` It is\n   *        used in tracking duplicates in function parameter lists. If it is\n   *        false, `checkLVal` will skip duplicate checks\n   * @param options.strictModeChanged\n   *        Whether an identifier has been parsed in a sloppy context but should\n   *        be reinterpreted as strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @param options.hasParenthesizedAncestor\n   *        This is only used internally during recursive calls, and you should\n   *        not have to set it yourself.\n   */\n\n  checkLVal(\n    expression: Expression | ObjectMember | RestElement,\n    {\n      in: ancestor,\n      binding = BindingFlag.TYPE_NONE,\n      checkClashes = false,\n      strictModeChanged = false,\n      hasParenthesizedAncestor = false,\n    }: {\n      in: LValAncestor;\n      binding?: BindingFlag;\n      checkClashes?: Set<string> | false;\n      strictModeChanged?: boolean;\n      hasParenthesizedAncestor?: boolean;\n    },\n  ): void {\n    const type = expression.type;\n\n    // If we find here an ObjectMethod, it's because this was originally\n    // an ObjectExpression which has then been converted.\n    // toAssignable already reported this error with a nicer message.\n    if (this.isObjectMethod(expression)) return;\n\n    const isOptionalMemberExpression =\n      this.isOptionalMemberExpression(expression);\n\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, {\n            at: expression,\n            ancestor,\n          });\n        }\n      }\n\n      if (binding !== BindingFlag.TYPE_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, { at: expression });\n      }\n      return;\n    }\n\n    if (type === \"Identifier\") {\n      this.checkIdentifier(\n        expression as Identifier,\n        binding,\n        strictModeChanged,\n      );\n\n      const { name } = expression as Identifier;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, { at: expression });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(\n      type,\n      !(hasParenthesizedAncestor || expression.extra?.parenthesized) &&\n        ancestor.type === \"AssignmentExpression\",\n      binding,\n    );\n\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass =\n        binding === BindingFlag.TYPE_NONE\n          ? Errors.InvalidLhs\n          : Errors.InvalidLhsBinding;\n\n      this.raise(ParseErrorClass, { at: expression, ancestor });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity)\n      ? validity\n      : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor =\n      type === \"ArrayPattern\" || type === \"ObjectPattern\"\n        ? ({ type } as const)\n        : ancestor;\n\n    // @ts-expect-error key may not index expression.\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression,\n        });\n      }\n    }\n  }\n\n  checkIdentifier(\n    at: Identifier,\n    bindingType: BindingFlag,\n    strictModeChanged: boolean = false,\n  ) {\n    if (\n      this.state.strict &&\n      (strictModeChanged\n        ? isStrictBindReservedWord(at.name, this.inModule)\n        : isStrictBindOnlyReservedWord(at.name))\n    ) {\n      if (bindingType === BindingFlag.TYPE_NONE) {\n        this.raise(Errors.StrictEvalArguments, { at, referenceName: at.name });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name,\n        });\n      }\n    }\n\n    if (bindingType & BindingFlag.FLAG_NO_LET_IN_LEXICAL && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, { at });\n    }\n\n    if (!(bindingType & BindingFlag.TYPE_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier: Identifier, binding: BindingFlag) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node: Node, allowPattern: boolean): void {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      /* falls through */\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, { at: node });\n    }\n  }\n\n  checkCommaAfterRest(\n    close: (typeof charCodes)[keyof typeof charCodes],\n  ): boolean {\n    if (!this.match(tt.comma)) {\n      return false;\n    }\n\n    this.raise(\n      this.lookaheadCharCode() === close\n        ? Errors.RestTrailingComma\n        : Errors.ElementAfterRest,\n      { at: this.state.startLoc },\n    );\n\n    return true;\n  }\n}\n", "/*:: declare var invariant; */\n\nimport type State from \"../../tokenizer/state.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsTSDeclarationStart,\n  tokenIsTSTypeOperator,\n  tokenOperatorPrecedence,\n  tokenIsKeywordOrIdentifier,\n  tt,\n  type TokenType,\n  tokenIsTemplate,\n  tokenCanStartExpression,\n} from \"../../tokenizer/types.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../../util/location.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport { ScopeFlag, BindingFlag } from \"../../util/scopeflags.ts\";\nimport TypeScriptScopeHandler from \"./scope.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { ParamKind } from \"../../util/production-parameter.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\nimport type { Pattern } from \"../../types.ts\";\nimport type { Expression } from \"../../types.ts\";\nimport type { IJSXParserMixin } from \"../jsx/index.ts\";\nimport { ParseBindingListFlags } from \"../../parser/lval.ts\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | \"override\"\n  | \"const\"\n  | N.Accessibility\n  | N.VarianceAnnotations;\n\nfunction nonNull<T>(x?: T | null): T {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\ntype ModifierBase = {\n  accessibility?: N.Accessibility;\n} & {\n  [key in TsModifier]?: boolean | undefined | null;\n};\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({ methodName }: { methodName: string }) =>\n    `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName,\n  }: {\n    propertyName: string;\n  }) =>\n    `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  // TODO: Accesor -> Accessor\n  AccesorCannotDeclareThisParameter:\n    \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  AccessorCannotBeOptional:\n    \"An 'accessor' property cannot be declared optional.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:\n    \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters:\n    \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer:\n    \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation:\n    \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier:\n    // `Accessibility modifier already seen: ${modifier}` would be more helpful.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ({ modifier }: { modifier: N.Accessibility }) =>\n      `Accessibility modifier already seen.`,\n  DuplicateModifier: ({ modifier }: { modifier: TsModifier }) =>\n    `Duplicate modifier: '${modifier}'.`,\n  // `token` matches the terminology used by typescript:\n  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915\n  EmptyHeritageClauseType: ({ token }: { token: \"extends\" | \"implements\" }) =>\n    `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare:\n    \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers,\n  }: {\n    modifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract:\n    \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare:\n    \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride:\n    \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic:\n    \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext:\n    \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier,\n  }: {\n    modifier: TsModifier;\n  }) =>\n    `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers,\n  }: {\n    orderedModifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression:\n    \"Invalid property access after an instantiation expression. \" +\n    \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel:\n    \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName:\n    \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod:\n    \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer:\n    \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired:\n    \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass:\n    \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract:\n    \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature:\n    \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam:\n    \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion:\n    \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  // TODO: Accesor -> Accessor\n  SetAccesorCannotHaveOptionalParameter:\n    \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter:\n    \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType:\n    \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName,\n  }: {\n    typeParameterName: string;\n  }) =>\n    `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier:\n    \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType:\n    \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed:\n    \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports:\n    \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports:\n    \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier:\n    \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly:\n    \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument:\n    \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind:\n    \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({ type }: { type: string }) =>\n    `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n});\n\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(value: string): N.TsKeywordTypeType | undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): modifier is N.Accessibility {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nfunction tsIsVarianceAnnotations(\n  modifier: string,\n): modifier is N.VarianceAnnotations {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\ntype ClassWithMixin<\n  T extends new (...args: any) => any,\n  M extends object,\n> = T extends new (...args: infer P) => infer I\n  ? new (...args: P) => I & M\n  : never;\n\nexport default (superClass: ClassWithMixin<typeof Parser, IJSXParserMixin>) =>\n  class TypeScriptParserMixin extends superClass implements Parser {\n    getScopeHandler(): {\n      new (...args: any): TypeScriptScopeHandler;\n    } {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return tokenIsIdentifier(this.state.type);\n    }\n\n    tsTokenCanFollowModifier() {\n      return (\n        (this.match(tt.bracketL) ||\n          this.match(tt.braceL) ||\n          this.match(tt.star) ||\n          this.match(tt.ellipsis) ||\n          this.match(tt.privateName) ||\n          this.isLiteralPropertyName()) &&\n        !this.hasPrecedingLineBreak()\n      );\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T extends TsModifier>(\n      allowedModifiers: T[],\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): T | undefined | null {\n      if (\n        !tokenIsIdentifier(this.state.type) &&\n        this.state.type !== tt._in &&\n        this.state.type !== tt._const\n      ) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (allowedModifiers.indexOf(modifier) !== -1) {\n        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n          return undefined;\n        }\n        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"public\"] });\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"abstract\", \"readonly\"] });\n     */\n    tsParseModifiers<N extends ModifierBase>(\n      {\n        allowedModifiers,\n        disallowedModifiers,\n        stopOnStartOfClassStaticBlock,\n        errorTemplate = TSErrors.InvalidModifierOnTypeMember,\n      }: {\n        allowedModifiers: readonly TsModifier[];\n        disallowedModifiers?: TsModifier[];\n        stopOnStartOfClassStaticBlock?: boolean;\n        errorTemplate?: typeof TSErrors.InvalidModifierOnTypeMember;\n      },\n      modified: N,\n    ): void {\n      const enforceOrder = (\n        loc: Position,\n        modifier: TsModifier,\n        before: TsModifier,\n        after: TsModifier,\n      ) => {\n        if (modifier === before && modified[after]) {\n          this.raise(TSErrors.InvalidModifiersOrder, {\n            at: loc,\n            orderedModifiers: [before, after],\n          });\n        }\n      };\n      const incompatible = (\n        loc: Position,\n        modifier: TsModifier,\n        mod1: TsModifier,\n        mod2: TsModifier,\n      ) => {\n        if (\n          (modified[mod1] && modifier === mod2) ||\n          (modified[mod2] && modifier === mod1)\n        ) {\n          this.raise(TSErrors.IncompatibleModifiers, {\n            at: loc,\n            modifiers: [mod1, mod2],\n          });\n        }\n      };\n\n      for (;;) {\n        const { startLoc } = this.state;\n        const modifier: TsModifier | undefined | null = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n          stopOnStartOfClassStaticBlock,\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(TSErrors.DuplicateAccessibilityModifier, {\n              at: startLoc,\n              modifier,\n            });\n          } else {\n            enforceOrder(startLoc, modifier, modifier, \"override\");\n            enforceOrder(startLoc, modifier, modifier, \"static\");\n            enforceOrder(startLoc, modifier, modifier, \"readonly\");\n\n            modified.accessibility = modifier;\n          }\n        } else if (tsIsVarianceAnnotations(modifier)) {\n          if (modified[modifier]) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          }\n          modified[modifier] = true;\n\n          enforceOrder(startLoc, modifier, \"in\", \"out\");\n        } else {\n          if (Object.hasOwnProperty.call(modified, modifier)) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          } else {\n            enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"static\", \"override\");\n            enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n\n            incompatible(startLoc, modifier, \"declare\", \"override\");\n            incompatible(startLoc, modifier, \"static\", \"abstract\");\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(errorTemplate, {\n            at: startLoc,\n            modifier,\n          });\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.match(tt.gt);\n      }\n    }\n\n    tsParseList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n    ): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n          refTrailingCommaPos,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T | undefined | null,\n      expectSuccess: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] | undefined | null {\n      const result = [];\n      let trailingCommaPos = -1;\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n        trailingCommaPos = -1;\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          trailingCommaPos = this.state.lastTokStart;\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      if (refTrailingCommaPos) {\n        refTrailingCommaPos.value = trailingCommaPos;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expect(tt.lt);\n        }\n      }\n\n      const result = this.tsParseDelimitedList(\n        kind,\n        parseElement,\n        refTrailingCommaPos,\n      );\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expect(tt.gt);\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node = this.startNode<N.TsImportType>();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(TSErrors.UnsupportedImportTypeArgument, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.argument = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        // In this instance, the entity name will actually itself be a\n        // qualifier, so allow it to be a reserved word as well.\n        node.qualifier = this.tsParseEntityName();\n      }\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(allowReservedWords: boolean = true): N.TsEntityName {\n      let entity: N.TsEntityName = this.parseIdentifier(allowReservedWords);\n      while (this.eat(tt.dot)) {\n        const node: Undone<N.TsQualifiedName> =\n          this.startNodeAtNode<N.TsQualifiedName>(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node = this.startNode<N.TsTypeReference>();\n      node.typeName = this.tsParseEntityName();\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node = this.startNodeAtNode<N.TsTypePredicate>(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node = this.startNode<N.TsThisType>();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node = this.startNode<N.TsTypeQuery>();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        node.exprName = this.tsParseEntityName();\n      }\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\n        \"const\",\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      // for better error recovery\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n    });\n\n    tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseTypeParameter(\n      parseModifiers: (node: Undone<N.TsTypeParameter>) => void,\n    ): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n\n      parseModifiers(node);\n\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(\n      parseModifiers: (node: N.TsTypeParameter) => void,\n    ): N.TsTypeParameterDeclaration | undefined | null {\n      if (this.match(tt.lt)) {\n        return this.tsParseTypeParameters(parseModifiers);\n      }\n    }\n\n    tsParseTypeParameters(parseModifiers: (node: N.TsTypeParameter) => void) {\n      const node = this.startNode<N.TsTypeParameterDeclaration>();\n\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      const refTrailingCommaPos = { value: -1 };\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        // @ts-expect-error refine typings\n        this.tsParseTypeParameter.bind(this, parseModifiers),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n        refTrailingCommaPos,\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeParameters, { at: node });\n      }\n      if (refTrailingCommaPos.value !== -1) {\n        this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: Undone<N.TsSignatureDeclaration>,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n\n      // https://github.com/babel/babel/issues/9231\n      const paramsKey = process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\";\n      const returnTypeKey = process.env.BABEL_8_BREAKING\n        ? \"returnType\"\n        : \"typeAnnotation\";\n\n      signature.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      this.expect(tt.parenL);\n      signature[paramsKey] = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    }\n\n    tsParseBindingListForSignature(): Array<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern\n    > {\n      const list = super.parseBindingList(\n        tt.parenR,\n        charCodes.rightParenthesis,\n        ParseBindingListFlags.IS_FUNCTION_PARAMS,\n      );\n      for (const pattern of list) {\n        const { type } = pattern;\n        if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n          this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n            at: pattern,\n            type,\n          });\n        }\n      }\n      return list as Exclude<\n        (typeof list)[0],\n        N.AssignmentPattern | N.TSParameterProperty\n      >[];\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n        this.expect(tt.semi);\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: Undone<\n        N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration\n      >,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      if (tokenIsIdentifier(this.state.type)) {\n        this.next();\n        return this.match(tt.colon);\n      }\n      return false;\n    }\n\n    tsTryParseIndexSignature(\n      node: Undone<N.TsIndexSignature>,\n    ): N.TsIndexSignature | undefined {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        if (readonly) {\n          this.raise(TSErrors.ReadonlyForMethodSignature, { at: node });\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        if (method.kind && this.match(tt.lt)) {\n          this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        const paramsKey = process.env.BABEL_8_BREAKING\n          ? \"params\"\n          : \"parameters\";\n        const returnTypeKey = process.env.BABEL_8_BREAKING\n          ? \"returnType\"\n          : \"typeAnnotation\";\n        if (method.kind === \"get\") {\n          if (method[paramsKey].length > 0) {\n            this.raise(Errors.BadGetterArity, { at: this.state.curPosition() });\n            if (this.isThisParam(method[paramsKey][0])) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n        } else if (method.kind === \"set\") {\n          if (method[paramsKey].length !== 1) {\n            this.raise(Errors.BadSetterArity, { at: this.state.curPosition() });\n          } else {\n            const firstParameter = method[paramsKey][0];\n            if (this.isThisParam(firstParameter)) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (\n              firstParameter.type === \"Identifier\" &&\n              firstParameter.optional\n            ) {\n              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (firstParameter.type === \"RestElement\") {\n              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n          if (method[returnTypeKey]) {\n            this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n              at: method[returnTypeKey],\n            });\n          }\n        } else {\n          method.kind = \"method\";\n        }\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id = this.startNode<N.Identifier>();\n        this.next();\n        if (this.match(tt.parenL) || this.match(tt.lt)) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\"readonly\"],\n          disallowedModifiers: [\n            \"declare\",\n            \"abstract\",\n            \"private\",\n            \"protected\",\n            \"public\",\n            \"static\",\n            \"override\",\n          ],\n        },\n        node,\n      );\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      super.parsePropertyName(node);\n      if (\n        !node.computed &&\n        node.key.type === \"Identifier\" &&\n        (node.key.name === \"get\" || node.key.name === \"set\") &&\n        this.tsTokenCanFollowModifier()\n      ) {\n        node.kind = node.key.name;\n        super.parsePropertyName(node);\n      }\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node = this.startNode<N.TsTypeLiteral>();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): Array<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(tt._readonly);\n      }\n      if (this.isContextual(tt._readonly)) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsExpectThenParseType(tt._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node = this.startNode<N.TsMappedType>();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(tt._readonly);\n      } else if (this.eatContextual(tt._readonly)) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node = this.startNode<N.TsTupleType>();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      node.elementTypes.forEach(elementNode => {\n        const { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(TSErrors.OptionalTypeBeforeRequired, {\n            at: elementNode,\n          });\n        }\n\n        seenOptionalElement ||=\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsNamedTupleMember | N.TsType {\n      // parses `...TsType[]`\n\n      const { startLoc } = this.state;\n\n      const rest = this.eat(tt.ellipsis);\n\n      let labeled: boolean;\n      let label: N.Identifier;\n      let optional: boolean;\n      let type: N.TsNamedTupleMember | N.TsType;\n\n      const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n      const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n      if (chAfterWord === charCodes.colon) {\n        labeled = true;\n        optional = false;\n        label = this.parseIdentifier(true);\n        this.expect(tt.colon);\n        type = this.tsParseType();\n      } else if (chAfterWord === charCodes.questionMark) {\n        optional = true;\n        const startLoc = this.state.startLoc;\n        const wordName = this.state.value;\n        const typeOrLabel = this.tsParseNonArrayType();\n\n        if (this.lookaheadCharCode() === charCodes.colon) {\n          labeled = true;\n          label = this.createIdentifier(\n            this.startNodeAt<N.Identifier>(startLoc),\n            wordName,\n          );\n          this.expect(tt.question);\n          this.expect(tt.colon);\n          type = this.tsParseType();\n        } else {\n          labeled = false;\n          type = typeOrLabel;\n          this.expect(tt.question);\n        }\n      } else {\n        type = this.tsParseType();\n        optional = this.eat(tt.question);\n        // In this case (labeled === true) could be only in invalid label.\n        // E.g. [x.y:type]\n        // An error is raised while processing node.\n        labeled = this.eat(tt.colon);\n      }\n\n      if (labeled) {\n        let labeledNode: Undone<N.TsNamedTupleMember>;\n        if (label) {\n          labeledNode = this.startNodeAtNode<N.TsNamedTupleMember>(label);\n          labeledNode.optional = optional;\n          labeledNode.label = label;\n          labeledNode.elementType = type;\n\n          if (this.eat(tt.question)) {\n            labeledNode.optional = true;\n            this.raise(TSErrors.TupleOptionalAfterType, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n        } else {\n          labeledNode = this.startNodeAtNode<N.TsNamedTupleMember>(type);\n          labeledNode.optional = optional;\n          this.raise(TSErrors.InvalidTupleMemberLabel, { at: type });\n          // @ts-expect-error This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          labeledNode.label = type;\n          labeledNode.elementType = this.tsParseType();\n        }\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode = this.startNodeAtNode<N.TsOptionalType>(type);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode = this.startNodeAt<N.TsRestType>(startLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode<N.TsParenthesizedType>();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node = this.startNode<\n        N.TsFunctionOrConstructorType | N.TsConstructorType\n      >();\n      if (type === \"TSConstructorType\") {\n        (node as Undone<N.TsConstructorType>).abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsInAllowConditionalTypesContext(() =>\n        this.tsFillSignature(tt.arrow, node),\n      );\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node = this.startNode<N.TsLiteralType>();\n      switch (this.state.type) {\n        case tt.num:\n        case tt.bigint:\n        case tt.string:\n        case tt._true:\n        case tt._false:\n          // For compatibility to estree we cannot call parseLiteral directly here\n          // @ts-expect-error refine typings\n          node.literal = super.parseExprAtom();\n          break;\n        default:\n          this.unexpected();\n      }\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsType {\n      const node = this.startNode<N.TsLiteralType>();\n      node.literal = super.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    parseTemplateSubstitution(): N.TsType | N.Node {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node = this.startNode<N.TsLiteralType>();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              this.unexpected();\n            }\n            // @ts-expect-error: parseMaybeUnary must returns unary expression\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (!this.options.createParenthesizedExpressions) {\n              const startLoc = this.state.startLoc;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startLoc.index);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.templateNonTail:\n        case tt.templateTail:\n          return this.tsParseTemplateLiteralType();\n        default: {\n          const { type } = this.state;\n          if (\n            tokenIsIdentifier(type) ||\n            type === tt._void ||\n            type === tt._null\n          ) {\n            const nodeType =\n              type === tt._void\n                ? \"TSVoidKeyword\"\n                : type === tt._null\n                  ? \"TSNullKeyword\"\n                  : keywordTypeFromName(this.state.value);\n            if (\n              nodeType !== undefined &&\n              this.lookaheadCharCode() !== charCodes.dot\n            ) {\n              const node = this.startNode<N.TsKeywordType>();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n      }\n\n      this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node = this.startNodeAtNode<N.TsArrayType>(type);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node = this.startNodeAtNode<N.TsIndexedAccessType>(type);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(): N.TsTypeOperator {\n      const node = this.startNode<N.TsTypeOperator>();\n      const operator = this.state.value;\n      this.next(); // eat operator\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(\n          // @ts-expect-error todo(flow->ts)\n          node,\n        );\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(TSErrors.UnexpectedReadonly, { at: node });\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode<N.TsInferType>();\n      this.expectContextual(tt._infer);\n      const typeParameter = this.startNode<N.TsTypeParameter>();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsTryParse(() =>\n        this.tsParseConstraintForInferType(),\n      );\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseConstraintForInferType() {\n      if (this.eat(tt._extends)) {\n        const constraint = this.tsInDisallowConditionalTypesContext(() =>\n          this.tsParseType(),\n        );\n        if (\n          this.state.inDisallowConditionalTypesContext ||\n          !this.match(tt.question)\n        ) {\n          return constraint;\n        }\n      }\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const isTypeOperator =\n        tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n      return isTypeOperator\n        ? this.tsParseTypeOperator()\n        : this.isContextual(tt._infer)\n          ? this.tsParseInferType()\n          : this.tsInAllowConditionalTypesContext(() =>\n              this.tsParseArrayTypeOrHigher(),\n            );\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node = this.startNode<N.TsUnionType | N.TsIntersectionType>();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.match(tt.lt)) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        // Return true if we can parse an object pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          this.parseObjectLike(tt.braceR, true);\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      if (this.match(tt.bracketL)) {\n        this.next();\n        // Return true if we can parse an array pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          super.parseBindingList(\n            tt.bracketR,\n            charCodes.rightSquareBracket,\n            ParseBindingListFlags.ALLOW_EMPTY,\n          );\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t = this.startNode<N.TsTypeAnnotation>();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = thisTypePredicate;\n            node.asserts = true;\n            (node as N.TsTypePredicate).typeAnnotation = null;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            thisTypePredicate.asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          (node as N.TsTypePredicate).typeAnnotation = null;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n    }\n\n    tsTryParseTypeAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeAnnotation();\n      }\n    }\n\n    tsTryParseType(): N.TsType | undefined {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): N.Identifier | undefined {\n      const id = this.parseIdentifier();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (this.state.type !== tt._asserts) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!tokenIsIdentifier(this.state.type) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(Errors.InvalidEscapedReservedWord, {\n          at: this.state.lastTokStartLoc,\n          reservedWord: \"asserts\",\n        });\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: Undone<N.TsTypeAnnotation> = this.startNode<N.TsTypeAnnotation>(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n\n      if (\n        this.state.inDisallowConditionalTypesContext ||\n        this.hasPrecedingLineBreak() ||\n        !this.eat(tt._extends)\n      ) {\n        return type;\n      }\n      const node = this.startNodeAtNode<N.TsConditionalType>(type);\n      node.checkType = type;\n\n      node.extendsType = this.tsInDisallowConditionalTypesContext(() =>\n        this.tsParseNonConditionalType(),\n      );\n\n      this.expect(tt.question);\n      node.trueType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      this.expect(tt.colon);\n      node.falseType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._new\n      );\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n        this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });\n      }\n\n      const node = this.startNode<N.TsTypeAssertion>();\n      node.typeAnnotation = this.tsInType(() => {\n        this.next(); // \"<\"\n        return this.match(tt._const)\n          ? this.tsParseTypeReference()\n          : this.tsParseType();\n      });\n      this.expect(tt.gt);\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(\n      token: \"extends\" | \"implements\",\n    ): Array<N.TsExpressionWithTypeArguments> {\n      const originalStartLoc = this.state.startLoc;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        () => {\n          const node = this.startNode<N.TsExpressionWithTypeArguments>();\n          node.expression = this.tsParseEntityName();\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.tsParseTypeArguments();\n          }\n\n          return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n        },\n      );\n\n      if (!delimitedList.length) {\n        this.raise(TSErrors.EmptyHeritageClauseType, {\n          at: originalStartLoc,\n          token,\n        });\n      }\n\n      return delimitedList;\n    }\n\n    tsParseInterfaceDeclaration(\n      node: Undone<N.TsInterfaceDeclaration>,\n      properties: {\n        declare?: true;\n      } = {},\n    ): N.TsInterfaceDeclaration | null {\n      if (this.hasFollowingLineBreak()) return null;\n      this.expectContextual(tt._interface);\n      if (properties.declare) node.declare = true;\n      if (tokenIsIdentifier(this.state.type)) {\n        node.id = this.parseIdentifier();\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_INTERFACE);\n      } else {\n        node.id = null;\n        this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc });\n      }\n\n      node.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body = this.startNode<N.TSInterfaceBody>();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_TYPE);\n\n      node.typeAnnotation = this.tsInType(() => {\n        node.typeParameters = this.tsTryParseTypeParameters(\n          this.tsParseInOutModifiers,\n        );\n\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(tt._intrinsic) &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node = this.startNode<N.TsKeywordType>();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    tsInNoContext<T>(cb: () => T): T {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsInDisallowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsInAllowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = false;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | undefined {\n      if (this.match(token)) {\n        return this.tsNextThenParseType();\n      }\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsInType(() => {\n        this.expect(token);\n        return this.tsParseType();\n      });\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsInType(() => {\n        this.next();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node = this.startNode<N.TsEnumMember>();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? super.parseStringLiteral(this.state.value)\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = super.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: Undone<N.TsEnumDeclaration>,\n      properties: {\n        const?: true;\n        declare?: true;\n      } = {},\n    ): N.TsEnumDeclaration {\n      if (properties.const) node.const = true;\n      if (properties.declare) node.declare = true;\n      this.expectContextual(tt._enum);\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(\n        node.id,\n        node.const ? BindingFlag.TYPE_TS_CONST_ENUM : BindingFlag.TYPE_TS_ENUM,\n      );\n\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node = this.startNode<N.TsModuleBlock>();\n      this.scope.enter(ScopeFlag.OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      super.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: Undone<N.TsModuleDeclaration>,\n      nested: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = this.parseIdentifier();\n\n      if (!nested) {\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_NAMESPACE);\n      }\n\n      if (this.eat(tt.dot)) {\n        const inner = this.startNode<N.TsModuleDeclaration>();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        // @ts-expect-error Fixme: refine typings\n        node.body = inner;\n      } else {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(tt._global)) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.id = super.parseStringLiteral(this.state.value);\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: Undone<N.TsImportEqualsDeclaration>,\n      maybeDefaultIdentifier?: N.Identifier | null,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      node.isExport = isExport || false;\n      node.id = maybeDefaultIdentifier || this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_VALUE_IMPORT);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(TSErrors.ImportAliasHasImportType, {\n          at: moduleReference,\n        });\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(tt._require) &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(/* allowReservedWords */ false);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node = this.startNode<N.TsExternalModuleReference>();\n      this.expectContextual(tt._require);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T extends N.NodeBase | undefined | null>(\n      f: () => T,\n    ): T | undefined | null {\n      const result = this.tryParse(\n        abort =>\n          // @ts-expect-error todo(flow->ts)\n          f() || abort(),\n      );\n\n      if (result.aborted || !result.node) return;\n      if (result.error) this.state = result.failState;\n      // @ts-expect-error refine typings\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => T | undefined | false): T | undefined {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      }\n      this.state = state;\n    }\n\n    tsTryParseDeclare(nany: any): N.Declaration | undefined {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let startType = this.state.type;\n      let kind: \"let\" | null;\n\n      if (this.isContextual(tt._let)) {\n        startType = tt._var;\n        kind = \"let\";\n      }\n\n      // @ts-expect-error refine typings\n      return this.tsInAmbientContext(() => {\n        switch (startType) {\n          case tt._function:\n            nany.declare = true;\n            return super.parseFunctionStatement(\n              nany,\n              /* async */ false,\n              /* isHangingDeclaration */ false,\n            );\n          case tt._class:\n            // While this is also set by tsParseExpressionStatement, we need to set it\n            // before parsing the class declaration to know how to register it in the scope.\n            nany.declare = true;\n            return this.parseClass(\n              nany,\n              /* isStatement */ true,\n              /* optionalId */ false,\n            );\n          case tt._enum:\n            return this.tsParseEnumDeclaration(nany, { declare: true });\n          case tt._global:\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          case tt._const:\n          case tt._var:\n            if (!this.match(tt._const) || !this.isLookaheadContextual(\"enum\")) {\n              nany.declare = true;\n              return this.parseVarStatement(\n                nany,\n                kind || this.state.value,\n                true,\n              );\n            }\n\n            // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n            this.expect(tt._const);\n            return this.tsParseEnumDeclaration(nany, {\n              const: true,\n              declare: true,\n            });\n          case tt._interface: {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true,\n            });\n            if (result) return result;\n          }\n          // fallthrough\n          default:\n            if (tokenIsIdentifier(startType)) {\n              return this.tsParseDeclaration(\n                nany,\n                this.state.value,\n                /* next */ true,\n                /* decorators */ null,\n              );\n            }\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): N.Declaration | undefined {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n        /* decorators */ null,\n      );\n    }\n\n    tsParseExpressionStatement(\n      node: Undone<N.TsModuleDeclaration>,\n      expr: N.Identifier,\n      decorators: N.Decorator[] | null,\n    ): N.Declaration | undefined {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(ScopeFlag.TS_MODULE);\n            this.prodParam.enter(ParamKind.PARAM);\n            const mod = node;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(\n            node,\n            expr.name,\n            /* next */ false,\n            decorators,\n          );\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n      decorators: N.Decorator[] | null,\n    ): N.Declaration | undefined | null {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || tokenIsIdentifier(this.state.type))\n          ) {\n            return this.tsParseAbstractDeclaration(node, decorators);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (tokenIsIdentifier(this.state.type)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined {\n      if (!this.match(tt.lt)) return;\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: Undone<N.ArrowFunctionExpression> | undefined =\n        this.tsTryParseAndCatch(() => {\n          const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n          node.typeParameters = this.tsParseTypeParameters(\n            this.tsParseConstModifier,\n          );\n          // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n          super.parseFunctionParams(node);\n          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n          this.expect(tt.arrow);\n          return node;\n        });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) return;\n\n      return super.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    // Used when parsing type arguments from ES productions, where the first token\n    // has been created without state.inType. Thus we need to rescan the lt token.\n    tsParseTypeArgumentsInExpression(): N.TsTypeParameterInstantiation | void {\n      if (this.reScan_lt() !== tt.lt) return;\n      return this.tsParseTypeArguments();\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode<N.TsTypeParameterInstantiation>();\n      node.params = this.tsInType(() =>\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n        this.tsInNoContext(() => {\n          this.expect(tt.lt);\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeArguments, { at: node });\n      } else if (!this.state.inType && this.curContext() === tc.brace) {\n        // rescan `>` when we are no longer in type context and JSX parsing context\n        // since it was tokenized when `inType` is `true`.\n        this.reScan_lt_gt();\n      }\n      this.expect(tt.gt);\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      return tokenIsTSDeclarationStart(this.state.type);\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseAssignableListItem(\n      flags: ParseBindingListFlags,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location to include modifiers in range\n      const startLoc = this.state.startLoc;\n\n      const modified: ModifierBase = {};\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\n            \"public\",\n            \"private\",\n            \"protected\",\n            \"override\",\n            \"readonly\",\n          ],\n        },\n        modified,\n      );\n      const accessibility = modified.accessibility;\n      const override = modified.override;\n      const readonly = modified.readonly;\n      if (\n        !(flags & ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS) &&\n        (accessibility || readonly || override)\n      ) {\n        this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });\n      }\n\n      const left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left, flags);\n      const elt = this.parseMaybeDefault(left.loc.start, left);\n      if (accessibility || readonly || override) {\n        const pp = this.startNodeAt<N.TSParameterProperty>(startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (override) pp.override = override;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(TSErrors.UnsupportedParameterPropertyKind, { at: pp });\n        }\n        pp.parameter = elt as any as N.Identifier | N.AssignmentPattern;\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n      return (\n        (node.type === \"TSParameterProperty\" &&\n          super.isSimpleParameter(node.parameter)) ||\n        super.isSimpleParameter(node)\n      );\n    }\n\n    tsDisallowOptionalPattern(node: Undone<N.Function>) {\n      for (const param of node.params) {\n        if (\n          param.type !== \"Identifier\" &&\n          (param as any).optional &&\n          !this.state.isAmbientContext\n        ) {\n          this.raise(TSErrors.PatternIsOptional, { at: param });\n        }\n      }\n    }\n\n    setArrowFunctionParameters(\n      node: Undone<N.ArrowFunctionExpression>,\n      params: N.Expression[],\n      trailingCommaLoc?: Position | null,\n    ): void {\n      super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n      this.tsDisallowOptionalPattern(node);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\" || type === \"ClassPrivateMethod\"\n            ? \"TSDeclareMethod\"\n            : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        return this.finishNode(node, bodilessType);\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n        this.raise(TSErrors.DeclareFunctionHasImplementation, { at: node });\n        if ((node as Undone<N.FunctionDeclaration>).declare) {\n          return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        }\n      }\n      this.tsDisallowOptionalPattern(node);\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodiless function, we need to do it here.\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(node);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: Array<N.Expression | undefined | null>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(TSErrors.UnexpectedTypeAnnotation, {\n            at: node.typeAnnotation,\n          });\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: Array<N.Expression | undefined | null>,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isInParens?: boolean,\n    ): Array<N.Expression | undefined | null> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        // When ! is consumed as a postfix operator (non-null assertion),\n        // disallow JSX tag forming after. e.g. When parsing `p! < n.p!`\n        // `<n.p` can not be a start of JSX tag\n        this.state.canStartJSXElement = false;\n        this.next();\n\n        const nonNullExpression =\n          this.startNodeAt<N.TsNonNullExpression>(startLoc);\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      let isOptionalCall = false;\n      if (\n        this.match(tt.questionDot) &&\n        this.lookaheadCharCode() === charCodes.lessThan\n      ) {\n        if (noCalls) {\n          state.stop = true;\n          return base;\n        }\n        state.optionalChainMember = isOptionalCall = true;\n        this.next();\n      }\n\n      // handles 'f<<T>'\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        let missingParenErrorLoc;\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn =\n              this.tsTryParseGenericAsyncArrowFunction(startLoc);\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const typeArguments = this.tsParseTypeArgumentsInExpression();\n          if (!typeArguments) return;\n\n          if (isOptionalCall && !this.match(tt.parenL)) {\n            missingParenErrorLoc = this.state.curPosition();\n            return;\n          }\n\n          if (tokenIsTemplate(this.state.type)) {\n            const result = super.parseTaggedTemplateExpression(\n              base,\n\n              startLoc,\n              state,\n            );\n            result.typeParameters = typeArguments;\n            return result;\n          }\n\n          if (!noCalls && this.eat(tt.parenL)) {\n            const node = this.startNodeAt<\n              N.CallExpression | N.OptionalCallExpression\n            >(startLoc);\n            node.callee = base;\n            // possibleAsync always false here, because we would have handled it above.\n            // @ts-expect-error (won't be any undefined arguments)\n            node.arguments = this.parseCallExpressionArguments(\n              tt.parenR,\n              /* possibleAsync */ false,\n            );\n\n            // Handles invalid case: `f<T>(a:b)`\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n\n            node.typeParameters = typeArguments;\n            if (state.optionalChainMember) {\n              (node as Undone<N.OptionalCallExpression>).optional =\n                isOptionalCall;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          }\n\n          const tokenType = this.state.type;\n          if (\n            // a<b>>c is not (a<b>)>c, but a<(b>>c)\n            tokenType === tt.gt ||\n            // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)\n            tokenType === tt.bitShiftR ||\n            // a<b>c is (a<b)>c\n            (tokenType !== tt.parenL &&\n              tokenCanStartExpression(tokenType) &&\n              !this.hasPrecedingLineBreak())\n          ) {\n            // Bail out.\n            return;\n          }\n\n          const node = this.startNodeAt<N.TsInstantiationExpression>(startLoc);\n          node.expression = base;\n          node.typeParameters = typeArguments;\n          return this.finishNode(node, \"TSInstantiationExpression\");\n        });\n\n        if (missingParenErrorLoc) {\n          this.unexpected(missingParenErrorLoc, tt.parenL);\n        }\n\n        if (result) {\n          if (\n            result.type === \"TSInstantiationExpression\" &&\n            (this.match(tt.dot) ||\n              (this.match(tt.questionDot) &&\n                this.lookaheadCharCode() !== charCodes.leftParenthesis))\n          ) {\n            this.raise(\n              TSErrors.InvalidPropertyAccessAfterInstantiationExpression,\n              { at: this.state.startLoc },\n            );\n          }\n          return result;\n        }\n      }\n\n      return super.parseSubscript(base, startLoc, noCalls, state);\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      const { callee } = node;\n      if (\n        callee.type === \"TSInstantiationExpression\" &&\n        !callee.extra?.parenthesized\n      ) {\n        node.typeParameters = callee.typeParameters;\n        node.callee = callee.expression;\n      }\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartLoc: Position,\n      minPrec: number,\n    ): N.Expression {\n      let isSatisfies: boolean;\n      if (\n        tokenOperatorPrecedence(tt._in) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        (this.isContextual(tt._as) ||\n          (isSatisfies = this.isContextual(tt._satisfies)))\n      ) {\n        const node = this.startNodeAt<\n          N.TsAsExpression | N.TsSatisfiesExpression\n        >(leftStartLoc);\n        node.expression = left;\n        node.typeAnnotation = this.tsInType(() => {\n          this.next(); // \"as\" or \"satisfies\"\n          if (this.match(tt._const)) {\n            if (isSatisfies) {\n              this.raise(Errors.UnexpectedKeyword, {\n                at: this.state.startLoc,\n                keyword: \"const\",\n              });\n            }\n            return this.tsParseTypeReference();\n          }\n\n          return this.tsParseType();\n        });\n        this.finishNode(\n          node,\n          isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\",\n        );\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(\n          // @ts-expect-error todo(flow->ts)\n          node,\n          leftStartLoc,\n          minPrec,\n        );\n      }\n\n      return super.parseExprOp(left, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ): void {\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n      if (!this.state.isAmbientContext) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(TSErrors.ImportReflectionHasImportType, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        const ch = this.lookaheadCharCode();\n        return isExport\n          ? ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk\n          : ch !== charCodes.equalsTo;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? \"type\" : \"value\";\n      } else {\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    ): N.AnyImport {\n      if (this.match(tt.string)) {\n        node.importKind = \"value\";\n        return super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      let importNode;\n      if (\n        tokenIsIdentifier(this.state.type) &&\n        this.lookaheadCharCode() === charCodes.equalsTo\n      ) {\n        node.importKind = \"value\";\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n        );\n      } else if (this.isContextual(tt._type)) {\n        const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n          node as Undone<N.ImportDeclaration>,\n          /* isExport */ false,\n        );\n        if (this.lookaheadCharCode() === charCodes.equalsTo) {\n          return this.tsParseImportEqualsDeclaration(\n            node as Undone<N.TsImportEqualsDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        } else {\n          importNode = super.parseImportSpecifiersAndAfter(\n            node as Undone<N.ImportDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        }\n      } else {\n        importNode = super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        // @ts-expect-error refine typings\n        importNode.specifiers.length > 1 &&\n        // @ts-expect-error refine typings\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n          at: importNode,\n        });\n      }\n\n      return importNode;\n    }\n\n    parseExport(\n      node: Undone<N.Node>,\n      decorators: N.Decorator[] | null,\n    ): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        this.next(); // eat `tt._import`\n        let maybeDefaultIdentifier: N.Identifier | null = null;\n        if (\n          this.isContextual(tt._type) &&\n          // We pass false here, because we are parsing an `import ... =`\n          this.isPotentialImportPhase(/* isExport */ false)\n        ) {\n          maybeDefaultIdentifier = this.parseMaybeImportPhase(\n            node as Undone<N.TsImportEqualsDeclaration>,\n            /* isExport */ false,\n          );\n        } else {\n          node.importKind = \"value\";\n        }\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n          maybeDefaultIdentifier,\n          /* isExport */ true,\n        );\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign = node as Undone<N.TsExportAssignment>;\n        assign.expression = super.parseExpression();\n        this.semicolon();\n        this.sawUnambiguousESM = true;\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(tt._as)) {\n        // `export as namespace A;`\n        const decl = node as Undone<N.TsNamespaceExportDeclaration>;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(tt._namespace);\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        return super.parseExport(\n          node as Undone<N.ExportAllDeclaration | N.ExportDefaultDeclaration>,\n          decorators,\n        );\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode<N.Class>();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        return this.parseClass(cls, true, true);\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.match(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(\n          this.startNode<N.TsInterfaceDeclaration>(),\n        );\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseVarStatement(\n      node: N.VariableDeclaration,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n      allowMissingInitializer: boolean = false,\n    ) {\n      const { isAmbientContext } = this.state;\n      const declaration = super.parseVarStatement(\n        node,\n        kind,\n        allowMissingInitializer || isAmbientContext,\n      );\n\n      if (!isAmbientContext) return declaration;\n\n      for (const { id, init } of declaration.declarations) {\n        // Empty initializer is the easy case that we want.\n        if (!init) continue;\n\n        // var and let aren't ever allowed initializers.\n        if (kind !== \"const\" || !!id.typeAnnotation) {\n          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n            at: init,\n          });\n        } else if (\n          !isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))\n        ) {\n          this.raise(\n            TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,\n            { at: init },\n          );\n        }\n      }\n\n      return declaration;\n    }\n\n    parseStatementContent(\n      flags: ParseStatementFlag,\n      decorators?: N.Decorator[] | null,\n    ): N.Statement {\n      if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n        const node = this.startNode<N.TsEnumDeclaration>();\n        this.expect(tt._const); // eat 'const'\n        return this.tsParseEnumDeclaration(node, { const: true });\n      }\n\n      if (this.isContextual(tt._enum)) {\n        return this.tsParseEnumDeclaration(\n          this.startNode<N.TsEnumDeclaration>(),\n        );\n      }\n\n      if (this.isContextual(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(this.startNode());\n        if (result) return result;\n      }\n\n      return super.parseStatementContent(flags, decorators);\n    }\n\n    parseAccessModifier(): N.Accessibility | undefined | null {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    tsHasSomeModifiers(member: any, modifiers: readonly TsModifier[]): boolean {\n      return modifiers.some(modifier => {\n        if (tsIsAccessModifier(modifier)) {\n          return member.accessibility === modifier;\n        }\n        return !!member[modifier];\n      });\n    }\n\n    tsIsStartOfStaticBlocks() {\n      return (\n        this.isContextual(tt._static) &&\n        this.lookaheadCharCode() === charCodes.leftCurlyBrace\n      );\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const modifiers = [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n        \"override\",\n        \"abstract\",\n        \"readonly\",\n        \"static\",\n      ] as const;\n      this.tsParseModifiers(\n        {\n          allowedModifiers: modifiers,\n          disallowedModifiers: [\"in\", \"out\"],\n          stopOnStartOfClassStaticBlock: true,\n          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n        },\n        member,\n      );\n\n      const callParseClassMemberWithIsStatic = () => {\n        if (this.tsIsStartOfStaticBlocks()) {\n          this.next(); // eat \"static\"\n          this.next(); // eat \"{\"\n          if (this.tsHasSomeModifiers(member, modifiers)) {\n            this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n              at: this.state.curPosition(),\n            });\n          }\n          super.parseClassStaticBlock(classBody, member as N.StaticBlock);\n        } else {\n          this.parseClassMemberWithIsStatic(\n            classBody,\n            member,\n            state,\n            !!member.static,\n          );\n        }\n      };\n      if (member.declare) {\n        this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n      } else {\n        callParseClassMemberWithIsStatic();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: Undone<N.ClassMember | N.TsIndexSignature>,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      const idx = this.tsTryParseIndexSignature(\n        member as Undone<N.TsIndexSignature>,\n      );\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member as any).abstract) {\n          this.raise(TSErrors.IndexSignatureHasAbstract, { at: member });\n        }\n        if ((member as any).accessibility) {\n          this.raise(TSErrors.IndexSignatureHasAccessibility, {\n            at: member,\n            modifier: (member as any).accessibility,\n          });\n        }\n        if ((member as any).declare) {\n          this.raise(TSErrors.IndexSignatureHasDeclare, { at: member });\n        }\n        if ((member as any).override) {\n          this.raise(TSErrors.IndexSignatureHasOverride, { at: member });\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member as any).abstract) {\n        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n          at: member,\n        });\n      }\n\n      if ((member as any).override) {\n        if (!state.hadSuperClass) {\n          this.raise(TSErrors.OverrideNotInSubClass, { at: member });\n        }\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(\n        classBody,\n        member as Undone<N.ClassMember>,\n        state,\n        isStatic,\n      );\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp as any).readonly && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasReadonly, { at: methodOrProp });\n      }\n\n      if ((methodOrProp as any).declare && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasDeclare, { at: methodOrProp });\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    // @ts-expect-error plugin overrides interfaces\n    parseExpressionStatement(\n      node: Undone<N.ExpressionStatement>,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? // @ts-expect-error refine typings\n            this.tsParseExpressionStatement(node, expr, decorators)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (!this.state.maybeInArrowParameters || !this.match(tt.question)) {\n        return super.parseConditional(\n          expr,\n\n          startLoc,\n          refExpressionErrors,\n        );\n      }\n\n      const result = this.tryParse(() =>\n        super.parseConditional(expr, startLoc),\n      );\n\n      if (!result.node) {\n        if (result.error) {\n          /*:: invariant(refExpressionErrors != null) */\n          super.setOptionalParametersError(refExpressionErrors, result.error);\n        }\n\n        return expr;\n      }\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem(\n      node: N.Expression,\n\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt<N.TsTypeCastExpression>(startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (!this.state.isAmbientContext && this.isContextual(tt._declare)) {\n        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n      }\n\n      // Store original location\n      const startLoc = this.state.startLoc;\n\n      const isDeclare = this.eatContextual(tt._declare);\n\n      if (\n        isDeclare &&\n        (this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n          at: this.state.startLoc,\n        });\n      }\n\n      const isIdentifier = tokenIsIdentifier(this.state.type);\n      const declaration: N.Declaration | undefined | null =\n        (isIdentifier && this.tsTryParseExportDeclaration()) ||\n        super.parseExportDeclaration(node);\n\n      if (!declaration) return null;\n\n      if (\n        declaration.type === \"TSInterfaceDeclaration\" ||\n        declaration.type === \"TSTypeAliasDeclaration\" ||\n        isDeclare\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (isDeclare) {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType?: BindingFlag,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(tt._implements)) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node as any).declare\n          ? BindingFlag.TYPE_TS_AMBIENT\n          : BindingFlag.TYPE_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty,\n    ): void {\n      if (!node.optional) {\n        if (this.eat(tt.bang)) {\n          node.definite = true;\n        } else if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (\n        this.state.isAmbientContext &&\n        !(node.readonly && !node.typeAnnotation) &&\n        this.match(tt.eq)\n      ) {\n        this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n          at: this.state.startLoc,\n        });\n      }\n      if (node.abstract && this.match(tt.eq)) {\n        const { key } = node;\n        this.raise(TSErrors.AbstractPropertyHasInitializer, {\n          at: this.state.startLoc,\n          propertyName:\n            key.type === \"Identifier\" && !node.computed\n              ? key.name\n              : `[${this.input.slice(key.start, key.end)}]`,\n        });\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      // @ts-expect-error abstract may not index node\n      if (node.abstract) {\n        this.raise(TSErrors.PrivateElementHasAbstract, { at: node });\n      }\n\n      // @ts-expect-error accessibility may not index node\n      if (node.accessibility) {\n        this.raise(TSErrors.PrivateElementHasAccessibility, {\n          at: node,\n          // @ts-expect-error refine typings\n          modifier: node.accessibility,\n        });\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    parseClassAccessorProperty(\n      node: N.ClassAccessorProperty,\n    ): N.ClassAccessorProperty {\n      this.parseClassPropertyAnnotation(node);\n      if (node.optional) {\n        this.raise(TSErrors.AccessorCannotBeOptional, { at: node });\n      }\n      return super.parseClassAccessorProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters && isConstructor) {\n        this.raise(TSErrors.ConstructorHasTypeParameters, {\n          at: typeParameters,\n        });\n      }\n\n      // @ts-expect-error declare does not exist in ClassMethod\n      const { declare = false, kind } = method;\n\n      if (declare && (kind === \"get\" || kind === \"set\")) {\n        this.raise(TSErrors.DeclareAccessor, { at: method, kind });\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    declareClassPrivateMethodInScope(\n      node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,\n      kind: number,\n    ) {\n      if (node.type === \"TSDeclareMethod\") return;\n      // This happens when using the \"estree\" plugin.\n      if (node.type === \"MethodDefinition\" && !node.value.body) return;\n\n      super.declareClassPrivateMethodInScope(node, kind);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      // handle `extends f<<T>\n      if (node.superClass && (this.match(tt.lt) || this.match(tt.bitShiftL))) {\n        // @ts-expect-error refine typings\n        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n      }\n      if (this.eatContextual(tt._implements)) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ) {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      return super.parseObjPropValue(\n        prop,\n\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n    }\n\n    parseFunctionParams(node: N.Function, isConstructor: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (\n        decl.id.type === \"Identifier\" &&\n        !this.hasPrecedingLineBreak() &&\n        this.eat(tt.bang)\n      ) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: State | undefined | null;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` or `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (!jsx?.error && !this.match(tt.lt)) {\n        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      // If the state was cloned in the JSX parsing branch above but there\n      // have been any error in the tryParse call, this.state is set to state\n      // so we still need to clone it.\n      if (!state || state === this.state) state = this.state.clone();\n\n      let typeParameters: N.TsTypeParameterDeclaration | undefined | null;\n      const arrow = this.tryParse(abort => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n        const expr = super.parseMaybeAssign(\n          refExpressionErrors,\n          afterLeftParse,\n        );\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            this.hasPlugin(\"jsx\") &&\n            expr.typeParameters.params.length === 1 &&\n            !expr.typeParameters.extra?.trailingComma\n          ) {\n            // report error if single type parameter used without trailing comma.\n            const parameter = expr.typeParameters.params[0];\n            if (!parameter.constraint) {\n              // A single type parameter must either have constraints\n              // or a trailing comma, otherwise it's ambiguous with JSX.\n              this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, {\n                at: createPositionWithColumnOffset(parameter.loc.end, 1),\n                typeParameterName: parameter.name.name,\n              });\n            }\n          }\n        }\n\n        return expr;\n      }, state);\n\n      /*:: invariant(arrow.node != null) */\n      if (!arrow.error && !arrow.aborted) {\n        // This error is reported outside of the this.tryParse call so that\n        // in case of <T>(x) => 2, we don't consider <T>(x) as a type assertion\n        // because of this error.\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n        /*:: invariant(!typeCast.aborted) */\n        /*:: invariant(typeCast.node != null) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    reportReservedArrowTypeParam(node: any) {\n      if (\n        node.params.length === 1 &&\n        !node.params[0].constraint &&\n        !node.extra?.trailingComma &&\n        this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")\n      ) {\n        this.raise(TSErrors.ReservedArrowTypeParam, { at: node });\n      }\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(\n      refExpressionErrors?: ExpressionErrors | null,\n      sawUnary?: boolean,\n    ): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.match(tt.lt)) {\n        return this.tsParseTypeAssertion();\n      }\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          // @ts-expect-error refine typings\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseAssignableListItemTypes(\n      param: N.Pattern,\n      flags: ParseBindingListFlags,\n    ) {\n      if (!(flags & ParseBindingListFlags.IS_FUNCTION_PARAMS)) return param;\n\n      if (this.eat(tt.question)) {\n        (param as any as N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return this.isAssignable(node.expression, isBinding);\n        case \"TSParameterProperty\":\n          return true;\n        default:\n          return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      switch (node.type) {\n        case \"ParenthesizedExpression\":\n          this.toAssignableParenthesizedExpression(node, isLHS);\n          break;\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          if (isLHS) {\n            this.expressionScope.recordArrowParameterBindingError(\n              TSErrors.UnexpectedTypeCastInParameter,\n              { at: node },\n            );\n          } else {\n            this.raise(TSErrors.UnexpectedTypeCastInParameter, { at: node });\n          }\n          this.toAssignable(node.expression, isLHS);\n          break;\n        case \"AssignmentExpression\":\n          if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n            node.left = this.typeCastToParameter(node.left);\n          }\n        /* fall through */\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean): void {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          this.toAssignable(node.expression, isLHS);\n          break;\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkToRestConversion(node: N.Node, allowPattern: boolean): void {\n      switch (node.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSTypeAssertion\":\n        case \"TSNonNullExpression\":\n          this.checkToRestConversion(node.expression, false);\n          break;\n        default:\n          super.checkToRestConversion(node, allowPattern);\n      }\n    }\n\n    // @ts-expect-error plugin overrides interfaces\n    isValidLVal(\n      type:\n        | \"TSTypeCastExpression\"\n        | \"TSParameterProperty\"\n        | \"TSNonNullExpression\"\n        | \"TSAsExpression\"\n        | \"TSSatisfiesExpression\"\n        | \"TSTypeAssertion\",\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingFlag,\n    ) {\n      return (\n        getOwn(\n          {\n            // Allow \"typecasts\" to appear on the left of assignment expressions,\n            // because it may be in an arrow function.\n            // e.g. `const f = (foo: number = 0) => foo;`\n            TSTypeCastExpression: true,\n            TSParameterProperty: \"parameter\",\n            TSNonNullExpression: \"expression\",\n            TSAsExpression: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n            TSSatisfiesExpression: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n            TSTypeAssertion: (binding !== BindingFlag.TYPE_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n          },\n          type,\n        ) || super.isValidLVal(type, isUnparenthesizedInAssign, binding)\n      );\n    }\n\n    parseBindingAtom(): N.Pattern {\n      if (this.state.type === tt._this) {\n        return this.parseIdentifier(/* liberal */ true);\n      }\n      return super.parseBindingAtom();\n    }\n\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n      // handles `@f<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(expr);\n          call.typeParameters = typeArguments;\n          return call;\n        }\n\n        this.unexpected(null, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr);\n    }\n\n    checkCommaAfterRest(\n      close: (typeof charCodes)[keyof typeof charCodes],\n    ): boolean {\n      if (\n        this.state.isAmbientContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n        return false;\n      }\n      return super.checkCommaAfterRest(close);\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(TSErrors.TypeAnnotationAfterAssign, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (this.state.inType) {\n        if (code === charCodes.greaterThan) {\n          this.finishOp(tt.gt, 1);\n          return;\n        }\n        if (code === charCodes.lessThan) {\n          this.finishOp(tt.lt, 1);\n          return;\n        }\n      }\n      super.getTokenFromCode(code);\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    reScan_lt() {\n      const { type } = this.state;\n      if (type === tt.bitShiftL) {\n        this.state.pos -= 2;\n        this.finishOp(tt.lt, 1);\n        return tt.lt;\n      }\n      return type;\n    }\n\n    toAssignableList(\n      exprList: Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TSTypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(\n            expr as N.TsTypeCastExpression,\n          );\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    shouldParseArrow(params: Array<N.Node>) {\n      if (this.match(tt.colon)) {\n        return params.every(expr => this.isAssignable(expr, true));\n      }\n      return super.shouldParseArrow(params);\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      // handles `<Component<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          // @ts-expect-error: refine typings\n          this.tsParseTypeArgumentsInExpression(),\n        );\n        // @ts-expect-error: refine typings\n        if (typeArguments) node.typeParameters = typeArguments;\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam = firstParam && this.isThisParam(firstParam);\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInAmbientContext<T>(cb: () => T): T {\n      const oldIsAmbientContext = this.state.isAmbientContext;\n      this.state.isAmbientContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.isAmbientContext = oldIsAmbientContext;\n      }\n    }\n\n    parseClass<T extends N.Class>(\n      node: Undone<T>,\n      isStatement: boolean,\n      optionalId?: boolean,\n    ): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node as any).abstract;\n      try {\n        return super.parseClass(node, isStatement, optionalId);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n      decorators: N.Decorator[] | null,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | undefined | null {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.maybeTakeDecorators(\n          decorators,\n          this.parseClass<N.ClassDeclaration>(\n            node as N.ClassDeclaration,\n            /* isStatement */ true,\n            /* optionalId */ false,\n          ),\n        );\n      } else if (this.isContextual(tt._interface)) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n            at: node,\n          });\n          return this.tsParseInterfaceDeclaration(\n            node as N.TsInterfaceDeclaration,\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod<\n      T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope?: boolean,\n    ) {\n      const method = super.parseMethod<T>(\n        node,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error todo(flow->ts) property not defined for all types in union\n      if (method.abstract) {\n        const hasBody = this.hasPlugin(\"estree\")\n          ? // @ts-expect-error estree typings\n            !!method.value.body\n          : !!method.body;\n        if (hasBody) {\n          const { key } = method;\n          this.raise(TSErrors.AbstractMethodHasImplementation, {\n            at: method,\n            methodName:\n              key.type === \"Identifier\" && !method.computed\n                ? key.name\n                : `[${this.input.slice(key.start, key.end)}]`,\n          });\n        }\n      }\n      return method;\n    }\n\n    tsParseTypeParameterName(): N.Identifier | string {\n      const typeName: N.Identifier = this.parseIdentifier();\n      return process.env.BABEL_8_BREAKING ? typeName : typeName.name;\n    }\n\n    shouldParseAsAmbientContext(): boolean {\n      return !!this.getPluginOption(\"typescript\", \"dts\");\n    }\n\n    parse() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.parse();\n    }\n\n    getExpression() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.getExpression();\n    }\n\n    parseExportSpecifier(\n      node: Undone<N.ExportSpecifier>,\n      isString: boolean,\n      isInTypeExport: boolean,\n      isMaybeTypeOnly: boolean,\n    ) {\n      if (!isString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          node,\n          /* isImport */ false,\n          isInTypeExport,\n        );\n        return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n      }\n      node.exportKind = \"value\";\n      return super.parseExportSpecifier(\n        node,\n        isString,\n        isInTypeExport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseImportSpecifier(\n      specifier: Undone<N.ImportSpecifier>,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingFlag | undefined,\n    ): N.ImportSpecifier {\n      if (!importedIsString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          specifier,\n          /* isImport */ true,\n          isInTypeOnlyImport,\n        );\n        return this.finishNode<N.ImportSpecifier>(specifier, \"ImportSpecifier\");\n      }\n      specifier.importKind = \"value\";\n      return super.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        isInTypeOnlyImport,\n        isMaybeTypeOnly,\n        isInTypeOnlyImport\n          ? BindingFlag.TYPE_TS_TYPE_IMPORT\n          : BindingFlag.TYPE_TS_VALUE_IMPORT,\n      );\n    }\n\n    parseTypeOnlyImportExportSpecifier(\n      node: any,\n      isImport: boolean,\n      isInTypeOnlyImportExport: boolean,\n    ): void {\n      const leftOfAsKey = isImport ? \"imported\" : \"local\";\n      const rightOfAsKey = isImport ? \"local\" : \"exported\";\n\n      let leftOfAs = node[leftOfAsKey];\n      let rightOfAs;\n\n      let hasTypeSpecifier = false;\n      let canParseAsKeyword = true;\n\n      const loc = leftOfAs.loc.start;\n\n      // https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456\n      // import { type } from \"mod\";          - hasTypeSpecifier: false, leftOfAs: type\n      // import { type as } from \"mod\";       - hasTypeSpecifier: true,  leftOfAs: as\n      // import { type as as } from \"mod\";    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as\n      // import { type as as as } from \"mod\"; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as\n      if (this.isContextual(tt._as)) {\n        // { type as ...? }\n        const firstAs = this.parseIdentifier();\n        if (this.isContextual(tt._as)) {\n          // { type as as ...? }\n          const secondAs = this.parseIdentifier();\n          if (tokenIsKeywordOrIdentifier(this.state.type)) {\n            // { type as as something }\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n            rightOfAs = isImport\n              ? this.parseIdentifier()\n              : this.parseModuleExportName();\n            canParseAsKeyword = false;\n          } else {\n            // { type as as }\n            rightOfAs = secondAs;\n            canParseAsKeyword = false;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          // { type as something }\n          canParseAsKeyword = false;\n          rightOfAs = isImport\n            ? this.parseIdentifier()\n            : this.parseModuleExportName();\n        } else {\n          // { type as }\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        // { type something ...? }\n        hasTypeSpecifier = true;\n        if (isImport) {\n          leftOfAs = this.parseIdentifier(true);\n          if (!this.isContextual(tt._as)) {\n            this.checkReservedWord(\n              leftOfAs.name,\n              leftOfAs.loc.start,\n              true,\n              true,\n            );\n          }\n        } else {\n          leftOfAs = this.parseModuleExportName();\n        }\n      }\n      if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n        this.raise(\n          isImport\n            ? TSErrors.TypeModifierIsUsedInTypeImports\n            : TSErrors.TypeModifierIsUsedInTypeExports,\n          { at: loc },\n        );\n      }\n\n      node[leftOfAsKey] = leftOfAs;\n      node[rightOfAsKey] = rightOfAs;\n\n      const kindKey = isImport ? \"importKind\" : \"exportKind\";\n      node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n      if (canParseAsKeyword && this.eatContextual(tt._as)) {\n        node[rightOfAsKey] = isImport\n          ? this.parseIdentifier()\n          : this.parseModuleExportName();\n      }\n      if (!node[rightOfAsKey]) {\n        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n      }\n      if (isImport) {\n        this.checkIdentifier(\n          node[rightOfAsKey],\n          hasTypeSpecifier\n            ? BindingFlag.TYPE_TS_TYPE_IMPORT\n            : BindingFlag.TYPE_TS_VALUE_IMPORT,\n        );\n      }\n    }\n  };\n\nfunction isPossiblyLiteralEnum(expression: N.Expression): boolean {\n  if (expression.type !== \"MemberExpression\") return false;\n\n  const { computed, property } = expression;\n\n  if (\n    computed &&\n    property.type !== \"StringLiteral\" &&\n    (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)\n  ) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\n// If a const declaration has no type annotation and is initialized to\n// a string literal, numeric literal, or enum reference, then it is\n// allowed. In an ideal world, we'd check whether init was *actually* an\n// enum reference, but we allow anything that \"could be\" a literal enum\n// in `isPossiblyLiteralEnum` since we don't have all the information\n// that the typescript compiler has.\nfunction isValidAmbientConstInitializer(\n  expression: N.Expression,\n  estree: boolean,\n): boolean {\n  const { type } = expression;\n  if (expression.extra?.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const { value } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\n\nfunction isNumber(expression: N.Expression, estree: boolean): boolean {\n  if (estree) {\n    return (\n      expression.type === \"Literal\" &&\n      (typeof expression.value === \"number\" || \"bigint\" in expression)\n    );\n  }\n  return (\n    expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\"\n  );\n}\n\nfunction isNegativeNumber(expression: N.Expression, estree: boolean): boolean {\n  if (expression.type === \"UnaryExpression\") {\n    const { operator, argument } = expression as N.UnaryExpression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isUncomputedMemberExpressionChain(expression: N.Expression): boolean {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n", "import * as charCodes from \"charcodes\";\n\nimport { tokenLabelName, tt } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type * as N from \"../types.ts\";\nimport { ParseErrorEnum } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type { BindingFlag } from \"../util/scopeflags.ts\";\nimport type { Position } from \"../util/location.ts\";\n\ntype PossiblePlaceholders = {\n  Identifier: N.Identifier;\n  StringLiteral: N.StringLiteral;\n  Expression: N.Expression;\n  Statement: N.Statement;\n  Declaration: N.Declaration;\n  BlockStatement: N.BlockStatement;\n  ClassBody: N.ClassBody;\n  Pattern: N.Pattern;\n};\nexport type PlaceholderTypes = keyof PossiblePlaceholders;\n\ntype NodeOf<T extends keyof PossiblePlaceholders> = PossiblePlaceholders[T];\n// todo: when there  is proper union type for Node\n// type NodeOf<T extends PlaceholderTypes> = Extract<N.Node, { type: T }>;\n\n// todo: Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T extends PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\n/* eslint sort-keys: \"error\" */\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\",\n});\n\n/* eslint-disable sort-keys */\n\nexport default (superClass: typeof Parser) =>\n  class PlaceholdersParserMixin extends superClass implements Parser {\n    parsePlaceholder<T extends PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ MaybePlaceholder<T> | undefined | null {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode();\n        this.next();\n        this.assertNoSpace();\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace();\n        this.expect(tt.placeholder);\n        // @ts-expect-error placeholder typings\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T extends PlaceholderTypes>(\n      node: N.Node,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n      node.expectedNode = expectedNode;\n\n      // @ts-expect-error todo(flow->ts)\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        this.finishOp(tt.placeholder, 2);\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(\n      refExpressionErrors?: ExpressionErrors | null,\n    ): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") ||\n        super.parseExprAtom(refExpressionErrors)\n      );\n    }\n\n    parseIdentifier(liberal?: boolean): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal)\n      );\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ) {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingFlag) {\n      return (\n        type === \"Placeholder\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean): void {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    chStartsBindingIdentifier(ch: number, pos: number): boolean {\n      if (super.chStartsBindingIdentifier(ch, pos)) {\n        return true;\n      }\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(\n      node: N.BreakStatement | N.ContinueStatement,\n      isBreak: boolean,\n    ) {\n      // @ts-expect-error: node.label could be Placeholder\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(node, isBreak);\n    }\n\n    // @ts-expect-error Plugin will override parser interface\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: N.Expression,\n    ): MaybePlaceholder<\"Statement\"> {\n      if (expr.type !== \"Placeholder\" || expr.extra?.parenthesized) {\n        // @ts-expect-error placeholder typings\n        return super.parseExpressionStatement(node, expr);\n      }\n\n      if (this.match(tt.colon)) {\n        // @ts-expect-error placeholder typings\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n      node.name = expr.name;\n      return this.finishPlaceholder(node, \"Statement\");\n    }\n\n    parseBlock(\n      allowDirectives?: boolean,\n      createNewLexicalScope?: boolean,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(\n          allowDirectives,\n          createNewLexicalScope,\n          afterBlockParse,\n        )\n      );\n    }\n\n    parseFunctionId(\n      requireId?: boolean,\n    ): MaybePlaceholder<\"Identifier\"> | undefined | null {\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId)\n      );\n    }\n    // @ts-expect-error Plugin will override parser interface\n    parseClass<T extends N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n            at: this.state.startLoc,\n          });\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      super.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        super.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(node: N.Node, decorators: N.Decorator[] | null): N.AnyExport {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(node, decorators);\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node.specifiers = [];\n        node.source = null;\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = placeholder;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node, decorators);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tokenLabelName(tt.placeholder),\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(\n      node: Undone<\n        | N.ExportDefaultDeclaration\n        | N.ExportAllDeclaration\n        | N.ExportNamedDeclaration\n      >,\n      maybeDefaultIdentifier: N.Identifier | null,\n    ): node is Undone<N.ExportNamedDeclaration> {\n      if ((node as N.ExportNamedDeclaration).specifiers?.length) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(\n        node,\n        maybeDefaultIdentifier,\n      );\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          // @ts-expect-error placeholder typings\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration>,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(node);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier =\n        this.startNodeAtNode<N.ImportDefaultSpecifier>(placeholder);\n      specifier.local = placeholder;\n      node.specifiers.push(\n        this.finishNode(specifier, \"ImportDefaultSpecifier\"),\n      );\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(tt._from);\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource()\n      );\n    }\n\n    // Throws if the current token and the prev one are separated by a space.\n    assertNoSpace(): void {\n      if (this.state.start > this.state.lastTokEndLoc.index) {\n        this.raise(PlaceholderErrors.UnexpectedSpace, {\n          at: this.state.lastTokEndLoc,\n        });\n      }\n    }\n  };\n", "import type Parser from \"../parser/index.ts\";\nimport { tokenIsIdentifier, tt } from \"../tokenizer/types.ts\";\nimport type * as N from \"../types.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\n\nexport default (superClass: typeof Parser) =>\n  class V8IntrinsicMixin extends superClass implements Parser {\n    parseV8Intrinsic(): N.Expression {\n      if (this.match(tt.modulo)) {\n        const v8IntrinsicStartLoc = this.state.startLoc;\n        // let the `loc` of Identifier starts from `%`\n        const node = this.startNode<N.Identifier>();\n        this.next(); // eat '%'\n        if (tokenIsIdentifier(this.state.type)) {\n          const name = this.parseIdentifierName();\n          const identifier = this.createIdentifier(node, name);\n          // @ts-expect-error: avoid mutating AST types\n          identifier.type = \"V8IntrinsicIdentifier\";\n          if (this.match(tt.parenL)) {\n            return identifier;\n          }\n        }\n        this.unexpected(v8IntrinsicStartLoc);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      return (\n        this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors)\n      );\n    }\n  };\n", "import type Parser from \"./parser/index.ts\";\nimport type {\n  ParserPluginWithOptions,\n  PluginConfig,\n  PluginOptions,\n} from \"./typings.ts\";\n\nexport type Plugin = PluginConfig;\n\nexport type PluginList = PluginConfig[];\n\nexport type MixinPlugin = (superClass: { new (...args: any): Parser }) => {\n  new (...args: any): Parser;\n};\n\n// This function’s second parameter accepts either a string (plugin name) or an\n// array pair (plugin name and options object). If an options object is given,\n// then each value is non-recursively checked for identity with the actual\n// option value of each plugin in the first argument (which is an array of\n// plugin names or array pairs).\nexport function hasPlugin(\n  plugins: PluginList,\n  expectedConfig: PluginConfig,\n): boolean {\n  // The expectedOptions object is by default an empty object if the given\n  // expectedConfig argument does not give an options object (i.e., if it is a\n  // string).\n  const [expectedName, expectedOptions] =\n    typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n\n  const expectedKeys = Object.keys(expectedOptions);\n\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        // @ts-expect-error key may not exist in plugin options\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\n\nexport function getPluginOption<\n  PluginName extends ParserPluginWithOptions[0],\n  OptionName extends keyof PluginOptions<PluginName>,\n>(plugins: PluginList, name: PluginName, option: OptionName) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return (plugin[1] as PluginOptions<PluginName>)[option];\n  }\n\n  return null;\n}\n\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n\nexport function validatePlugins(plugins: PluginList) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\n        \"Cannot use the decorators and decorators-legacy plugin together\",\n      );\n    }\n\n    const decoratorsBeforeExport = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"decoratorsBeforeExport\",\n    );\n    if (\n      decoratorsBeforeExport != null &&\n      typeof decoratorsBeforeExport !== \"boolean\"\n    ) {\n      throw new Error(\n        \"'decoratorsBeforeExport' must be a boolean, if specified.\",\n      );\n    }\n\n    const allowCallParenthesized = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"allowCallParenthesized\",\n    );\n    if (\n      allowCallParenthesized != null &&\n      typeof allowCallParenthesized !== \"boolean\"\n    ) {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(\n        `\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`,\n      );\n    }\n\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\n      \"recordAndTuple\",\n      { syntaxType: \"hash\" },\n    ]);\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\n          \"Cannot combine placeholders plugin and Hack-style pipes.\",\n        );\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\n          \"Cannot combine v8intrinsic plugin and Hack-style pipes.\",\n        );\n      }\n\n      const topicToken = getPluginOption(\n        plugins,\n        \"pipelineOperator\",\n        \"topicToken\",\n      );\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n\n        throw new Error(\n          `\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`,\n        );\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error(\n          'Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n        );\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error(\n        'Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n      );\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (process.env.BABEL_8_BREAKING) {\n      throw new Error(\n        \"`moduleAttributes` has been removed in Babel 8, please use `importAttributes` parser plugin, or `@babel/plugin-syntax-import-attributes`.\",\n      );\n    } else {\n      if (\n        hasPlugin(plugins, \"importAssertions\") ||\n        hasPlugin(plugins, \"importAttributes\")\n      ) {\n        throw new Error(\n          \"Cannot combine importAssertions, importAttributes and moduleAttributes plugins.\",\n        );\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(\n        plugins,\n        \"moduleAttributes\",\n        \"version\",\n      );\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\n          \"The 'moduleAttributes' plugin requires a 'version' option,\" +\n            \" representing the last proposal update. Currently, the\" +\n            \" only supported value is 'may-2020'.\",\n        );\n      }\n    }\n  }\n  if (\n    hasPlugin(plugins, \"importAssertions\") &&\n    hasPlugin(plugins, \"importAttributes\")\n  ) {\n    throw new Error(\n      \"Cannot combine importAssertions and importAttributes plugins.\",\n    );\n  }\n\n  if (\n    hasPlugin(plugins, \"recordAndTuple\") &&\n    getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null &&\n    !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(\n      getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"),\n    )\n  ) {\n    throw new Error(\n      \"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" +\n        RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"),\n    );\n  }\n\n  if (\n    hasPlugin(plugins, \"asyncDoExpressions\") &&\n    !hasPlugin(plugins, \"doExpressions\")\n  ) {\n    const error = new Error(\n      \"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\",\n    );\n    // @ts-expect-error so @babel/core can provide better error message\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n\n  if (\n    hasPlugin(plugins, \"optionalChainingAssign\") &&\n    getPluginOption(plugins, \"optionalChainingAssign\", \"version\") !== \"2023-07\"\n  ) {\n    throw new Error(\n      \"The 'optionalChainingAssign' plugin requires a 'version' option,\" +\n        \" representing the last proposal update. Currently, the\" +\n        \" only supported value is '2023-07'.\",\n    );\n  }\n}\n\n// These plugins are defined using a mixin which extends the parser class.\n\nimport estree from \"./plugins/estree.ts\";\nimport flow from \"./plugins/flow/index.ts\";\nimport jsx from \"./plugins/jsx/index.ts\";\nimport typescript from \"./plugins/typescript/index.ts\";\nimport placeholders from \"./plugins/placeholders.ts\";\nimport v8intrinsic from \"./plugins/v8intrinsic.ts\";\n\n// NOTE: order is important. estree must come first; placeholders must come last.\nexport const mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders,\n};\n\nexport const mixinPluginNames = Object.keys(mixinPlugins) as ReadonlyArray<\n  \"estree\" | \"jsx\" | \"flow\" | \"typescript\" | \"v8intrinsic\" | \"placeholders\"\n>;\n", "import type { PluginList } from \"./plugin-utils.ts\";\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport type SourceType = \"script\" | \"module\" | \"unambiguous\";\n\nexport type Options = {\n  sourceType: SourceType;\n  sourceFilename?: string;\n  startColumn: number;\n  startLine: number;\n  allowAwaitOutsideFunction: boolean;\n  allowReturnOutsideFunction: boolean;\n  allowNewTargetOutsideFunction: boolean;\n  allowImportExportEverywhere: boolean;\n  allowSuperOutsideMethod: boolean;\n  allowUndeclaredExports: boolean;\n  plugins: PluginList;\n  strictMode: boolean | undefined | null;\n  ranges: boolean;\n  tokens: boolean;\n  createImportExpressions: boolean;\n  createParenthesizedExpressions: boolean;\n  errorRecovery: boolean;\n  attachComment: boolean;\n  annexB: boolean;\n};\n\nexport const defaultOptions: Options = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Column (0-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startColumn: 0,\n  // Line (1-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, await at the top level is not considered an\n  // error.\n  allowAwaitOutsideFunction: false,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, new.target outside a function or class is not\n  // considered an error.\n  allowNewTargetOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // When enabled, export statements can reference undeclared variables.\n  allowUndeclaredExports: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // Adds all parsed tokens to a `tokens` property on the `File` node\n  tokens: false,\n  // Whether to create ImportExpression AST nodes (if false\n  // `import(foo)` will be parsed as CallExpression(Import, [Identifier(foo)])\n  createImportExpressions: process.env.BABEL_8_BREAKING ? true : false,\n  // Whether to create ParenthesizedExpression AST nodes (if false\n  // the parser sets extra.parenthesized on the expression nodes instead).\n  createParenthesizedExpressions: false,\n  // When enabled, errors are attached to the AST instead of being directly thrown.\n  // Some errors will still throw, because @babel/parser can't always recover.\n  errorRecovery: false,\n  // When enabled, comments will be attached to adjacent AST nodes as one of\n  // `leadingComments`, `trailingComments` and `innerComments`. The comment attachment\n  // is vital to preserve comments after transform. If you don't print AST back,\n  // consider set this option to `false` for performance\n  attachComment: true,\n  // When enabled, the parser will support Annex B syntax.\n  // https://tc39.es/ecma262/#sec-additional-ecmascript-features-for-web-browsers\n  annexB: true,\n};\n\n// Interpret and default an options object\n\nexport function getOptions(opts?: Options | null): Options {\n  if (opts == null) {\n    return { ...defaultOptions };\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n\n  const options: any = {};\n  for (const key of Object.keys(defaultOptions) as (keyof Options)[]) {\n    options[key] = opts[key] ?? defaultOptions[key];\n  }\n  return options;\n}\n", "// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenIsTemplate,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport type * as N from \"../types.ts\";\nimport LValParser from \"./lval.ts\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier.ts\";\nimport {\n  type Position,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport * as charCodes from \"charcodes\";\nimport { ScopeFlag, BindingFlag } from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope.ts\";\nimport { Errors, type ParseError } from \"../parse-error.ts\";\nimport { UnparenthesizedPipeBodyDescriptions } from \"../parse-error/pipeline-operator-errors.ts\";\nimport { setInnerComments } from \"./comments.ts\";\nimport { cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\n\nimport type { SourceType } from \"../options.ts\";\n\nexport default abstract class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  abstract parseBlock(\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement;\n  abstract parseClass(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ): N.Class;\n  abstract parseDecorators(allowExport?: boolean): void;\n  abstract parseFunction<T extends N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ): T;\n  abstract parseFunctionParams(node: N.Function, isConstructor?: boolean): void;\n  abstract parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: N.Directive[] | null | undefined,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void;\n  abstract parseProgram(\n    program: N.Program,\n    end: TokenType,\n    sourceType?: SourceType,\n  ): N.Program;\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean | undefined | null,\n    protoRef: {\n      used: boolean;\n    },\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // @ts-expect-error prop must be an ObjectProperty\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, { at: key });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, { at: key });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(this: Parser): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    // @ts-expect-error fixme: refine types\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    this: Parser,\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(\n    refExpressionErrors: ExpressionErrors,\n    resultError?: ParseError<any>,\n  ) {\n    refExpressionErrors.optionalParametersLoc =\n      resultError?.loc ?? this.state.startLoc;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt<N.AssignmentExpression>(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        this.toAssignable(left, /* isLHS */ true);\n        node.left = left;\n\n        const startIndex = startLoc.index;\n        if (\n          refExpressionErrors.doubleProtoLoc != null &&\n          refExpressionErrors.doubleProtoLoc.index >= startIndex\n        ) {\n          refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression\n        }\n        if (\n          refExpressionErrors.shorthandAssignLoc != null &&\n          refExpressionErrors.shorthandAssignLoc.index >= startIndex\n        ) {\n          refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly\n        }\n        if (\n          refExpressionErrors.privateKeyLoc != null &&\n          refExpressionErrors.privateKeyLoc.index >= startIndex\n        ) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\"),\n      });\n      // @ts-expect-error todo(flow->ts) improve node types\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    this: Parser,\n    expr: N.Expression,\n    startLoc: Position,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    this: Parser,\n    left: N.Expression | N.PrivateName,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value,\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt<N.LogicalExpression | N.BinaryExpression>(\n          leftStartLoc,\n        );\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.hasPlugin([\"pipelineOperator\", { proposal: \"minimal\" }])\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc,\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc,\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startLoc,\n              );\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(this: Parser): N.Expression {\n    const { startLoc } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n      // @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '\"ArrowFunctionExpression\" | \"YieldExpression\" | \"AssignmentExpression\" | \"ConditionalExpression\"'.\n      body.type,\n    );\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (requiredParentheses && !body.extra?.parenthesized) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        // @ts-expect-error TS2322: Type 'string' is not assignable to type '\"AssignmentExpression\" | \"ArrowFunctionExpression\" | \"ConditionalExpression\" | \"YieldExpression\"'.\n        type: body.type,\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(Errors.PipeTopicUnused, { at: startLoc });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(\n    node: N.AwaitExpression | Undone<N.UnaryExpression>,\n  ) {\n    if (this.match(tt.exponent)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument,\n      });\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode<N.UnaryExpression | N.UpdateExpression>();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, { at: node });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, { at: node });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node as Undone<N.UnaryExpression>);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(\n      // @ts-expect-error using \"Undone\" node as \"done\"\n      node,\n      update,\n      refExpressionErrors,\n    );\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc });\n        return this.parseAwait(startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    this: Parser,\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (update) {\n      // @ts-expect-error Type 'Node' is missing the following properties from type 'Undone<UpdateExpression>': prefix, operator, argument\n      const updateExpressionNode = node as Undone<N.UpdateExpression>;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\"),\n      });\n      return node;\n    }\n\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt<N.UpdateExpression>(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: (expr = this.finishNode(node, \"UpdateExpression\")),\n      });\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startLoc);\n  }\n\n  parseSubscripts(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls?: boolean | null,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const { type } = this.state;\n    if (!noCalls && type === tt.doubleColon) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === tt.questionDot) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, {\n          at: this.state.startLoc,\n        });\n        if (this.lookaheadCharCode() === charCodes.leftParenthesis) {\n          // stop at `?.` when parsing `new a?.()`\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt<\n      N.OptionalMemberExpression | N.MemberExpression\n    >(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(tt.bracketR);\n    } else if (this.match(tt.privateName)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, { at: startLoc });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      (node as N.OptionalMemberExpression).optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next(); // eat '::'\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors: ExpressionErrors | null = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    const node = this.startNodeAt<N.CallExpression | N.OptionalCallExpression>(\n      startLoc,\n    );\n    node.callee = base;\n    const { maybeAsyncArrow, optionalChainMember } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      // @ts-expect-error when optionalChainMember is true, node must be an optional call\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        // @ts-expect-error todo(flow->ts)\n        node,\n        refExpressionErrors,\n      );\n    }\n    let finishedNode:\n      | N.CallExpression\n      | N.OptionalCallExpression\n      | N.ArrowFunctionExpression = this.finishCallExpression(\n      node,\n      optionalChainMember,\n    );\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      /*:: invariant(refExpressionErrors != null) */\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt<N.ArrowFunctionExpression>(startLoc),\n        finishedNode as N.CallExpression,\n      );\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return finishedNode;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node = this.startNodeAt<N.TaggedTemplateExpression>(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEndLoc.index === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n\n  finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n    node: Undone<T>,\n    optional: boolean,\n  ): T {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (process.env.BABEL_8_BREAKING) {\n          this.expectImportAttributesPlugin();\n        } else {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount:\n            this.hasPlugin(\"importAttributes\") ||\n            this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n              ? 2\n              : 1,\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, { at: arg });\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    this: Parser,\n    close: TokenType,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: N.Node | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): Array<N.Expression | undefined | null> {\n    const elts: N.Expression[] = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAttributes\") &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingCommaLoc,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node as N.ArrowFunctionExpression;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(this: Parser): N.Expression {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    let node;\n    let decorators: N.Decorator[] | null = null;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode<N.MetaProperty | N.Import | N.ImportExpression>();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node as Undone<N.MetaProperty>);\n        }\n\n        if (this.match(tt.parenL)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node as Undone<N.ImportExpression>);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc,\n          });\n          return this.finishNode(node, \"Import\");\n        }\n\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.decimal:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        decorators = this.parseDecorators();\n      // fall through\n      case tt._class:\n        return this.parseClass(\n          this.maybeTakeDecorators(decorators, this.startNode()),\n          false,\n        );\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.templateNonTail:\n      case tt.templateTail:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, { at: callee });\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: this.state.startLoc,\n          identifierName: this.state.value,\n        });\n        return this.parsePrivateName();\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.doubleCaret:\n      case tt.doubleAt: {\n        return this.parseTopicReference(\"hack\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadInLineCharCode() === charCodes.leftCurlyBrace\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(\n                this.startNodeAtNode(id),\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the\n  // Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or\n  // % could be the topic token (e.g., in x |> ^==y or x |> ^===y), and so we\n  // reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that “topic token”.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the “topic token”, so that the\n      // following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      // This is safe to do since the preceding character was either ^ or %, and\n      // thus not a newline.\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token’s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode<N.TopicReference>();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin’s configuration matches the current token’s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin’s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin’s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference(\n    node: Undone<N.Node>,\n    startLoc: Position,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): N.Expression {\n    if (\n      this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)\n    ) {\n      // The token matches the plugin’s configuration.\n      // The token is therefore a topic reference.\n\n      // Determine the node type for the topic reference\n      // that is appropriate for the active pipe-operator proposal.\n      const nodeType =\n        pipeProposal === \"smart\"\n          ? \"PipelinePrimaryTopicReference\"\n          : // The proposal must otherwise be \"hack\",\n            // as enforced by testTopicReferenceConfiguration.\n            \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(\n          // The topic reference is not allowed in the current context:\n          // it is outside of a pipe body.\n          // Raise recoverable errors.\n          pipeProposal === \"smart\"\n            ? Errors.PrimaryTopicNotAllowed\n            : // In this case, `pipeProposal === \"hack\"` is true.\n              Errors.PipeTopicUnbound,\n          { at: startLoc },\n        );\n      }\n\n      // Register the topic reference so that its pipe body knows\n      // that its topic was used at least once.\n      this.registerTopicReference();\n\n      return this.finishNode(node, nodeType);\n    } else {\n      // The token does not match the plugin’s configuration.\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType),\n      });\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin’s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration’s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\" or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    startLoc: Position,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\n          \"pipelineOperator\",\n          {\n            // @ts-expect-error token must have a label\n            topicToken: tokenLabelName(tokenType),\n          },\n        ]);\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n  ): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition(),\n      });\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(\n    this: Parser,\n    node: Undone<N.DoExpression>,\n    isAsync: boolean,\n  ): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(ParamKind.PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode<N.Super>();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.SuperNotAllowed, { at: node });\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.UnexpectedSuper, { at: node });\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(Errors.UnsupportedSuper, { at: node });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode<N.PrivateName>();\n    const id = this.startNodeAt<N.Identifier>(\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      createPositionWithColumnOffset(this.state.startLoc, 1),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(\n    this: Parser,\n  ): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode<N.FunctionExpression | N.MetaProperty>();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"sent\",\n      );\n    }\n    return this.parseFunction(node as Undone<N.FunctionExpression>);\n  }\n\n  parseMetaProperty(\n    node: Undone<N.MetaProperty>,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName,\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(\n    this: Parser,\n    node: Undone<N.MetaProperty | N.ImportExpression>,\n  ): N.MetaProperty | N.ImportExpression {\n    const id = this.createIdentifier(\n      this.startNodeAtNode<N.Identifier>(node),\n      \"import\",\n    );\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, { at: id });\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(tt._source) || this.isContextual(tt._defer)) {\n      const isSource = this.isContextual(tt._source);\n\n      // TODO: The proposal doesn't mention import.defer yet because it was\n      // pending on a decision for import.source. Wait to enable it until it's\n      // included in the proposal.\n      if (!isSource) this.unexpected();\n\n      this.expectPlugin(\n        isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\",\n      );\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {\n          at: this.state.startLoc,\n          phase: this.state.value,\n        });\n      }\n      this.next();\n      (node as Undone<N.ImportExpression>).phase = isSource\n        ? \"source\"\n        : \"defer\";\n      return this.parseImportCall(node as Undone<N.ImportExpression>);\n    }\n\n    return this.parseMetaProperty(node as Undone<N.MetaProperty>, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T extends N.Node>(\n    value: any,\n    type: T[\"type\"],\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T extends N.Node>(value: any, type: T[\"type\"]): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: {\n    value: any;\n    pattern: string;\n    flags: N.RegExpLiteral[\"flags\"];\n  }) {\n    const node = this.parseLiteral<N.RegExpLiteral>(\n      value.value,\n      \"RegExpLiteral\",\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode<N.BooleanLiteral>();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode<N.NullLiteral>();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(\n    this: Parser,\n    canBeArrow: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartLoc = this.state.startLoc;\n    const exprList: N.Expression[] = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParametersLoc === null\n            ? null\n            : refExpressionErrors.optionalParametersLoc,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(\n          this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc),\n        );\n\n        if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {\n          break;\n        }\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      // @ts-expect-error todo(flow->ts) improve node types\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt<N.SequenceExpression>(innerStartLoc);\n      val.expressions = exprList;\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(\n      startLoc,\n      // @ts-expect-error todo(flow->ts)\n      val,\n    );\n  }\n\n  wrapParenthesis(startLoc: Position, expression: N.Expression): N.Expression {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n\n      this.takeSurroundingComments(\n        expression,\n        startLoc.index,\n        this.state.lastTokEndLoc.index,\n      );\n\n      return expression;\n    }\n\n    const parenExpression =\n      this.startNodeAt<N.ParenthesizedExpression>(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(\n    node: Undone<N.ArrowFunctionExpression>,\n  ): Undone<N.ArrowFunctionExpression> | undefined {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoc: Position,\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {\n    const node = this.startNode<N.NewExpression | N.MetaProperty>();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"new\",\n      );\n      this.next();\n      const metaProp = this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"target\",\n      );\n\n      if (\n        !this.scope.inNonArrowFunction &&\n        !this.scope.inClass &&\n        !this.options.allowNewTargetOutsideFunction\n      ) {\n        this.raise(Errors.UnexpectedNewTarget, { at: metaProp });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node as Undone<N.NewExpression>);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(this: Parser, node: Undone<N.NewExpression>): N.NewExpression {\n    this.parseNewCallee(node);\n\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(this: Parser, node: Undone<N.NewExpression>): void {\n    const isImport = this.match(tt._import);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (\n      isImport &&\n      (callee.type === \"Import\" || callee.type === \"ImportExpression\")\n    ) {\n      this.raise(Errors.ImportCallNotNewExpression, { at: callee });\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const { start, startLoc, end, value } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt<N.TemplateElement>(\n      createPositionWithColumnOffset(startLoc, 1),\n    );\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          // FIXME: Adding 1 is probably wrong.\n          at: createPositionWithColumnOffset(\n            this.state.firstInvalidTemplateEscapePos,\n            1,\n          ),\n        });\n      }\n    }\n\n    const isTail = this.match(tt.templateTail);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset),\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(\n      finishedNode,\n      createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),\n    );\n    return finishedNode;\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode<N.TemplateLiteral>();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(this: Parser): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike(\n    close: TokenType,\n    isPattern: true,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectPattern;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: false | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectExpression;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: true,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.RecordExpression;\n  parseObjectLike<T extends N.ObjectPattern | N.ObjectExpression>(\n    this: Parser,\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode<\n      N.ObjectExpression | N.ObjectPattern | N.RecordExpression\n    >();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(\n            // @ts-expect-error todo(flow->ts) improve node types\n            node,\n          );\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(Errors.InvalidRecordProperty, { at: prop });\n      }\n\n      // @ts-expect-error shorthand may not index prop\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      // @ts-expect-error Fixme: refine typings\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    // @ts-expect-error type is well defined\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node: N.Node): void {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: Undone<N.ObjectProperty>): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode<N.ObjectProperty>();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName,\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(\n      prop,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(\n        method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity,\n        { at: method },\n      );\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(Errors.BadSetterRestParameter, { at: method });\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    this: Parser,\n    prop: Undone<N.ObjectMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): N.ObjectMethod | undefined | null {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      const finishedProp = this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    this: Parser,\n    prop: Undone<N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isPattern: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectProperty | undefined | null {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoverInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc,\n          });\n        }\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    this: Parser,\n    prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMethod | N.ObjectProperty {\n    const node =\n      this.parseObjectMethod(\n        prop as Undone<N.ObjectMethod>,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop as Undone<N.ObjectProperty>,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    return node;\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyName\n  // when refExpressionErrors presents, it will parse private name\n  // and record the position of the first private name\n  parsePropertyName(\n    this: Parser,\n    prop:\n      | Undone<N.ObjectOrClassMember | N.ClassMember>\n      | N.TsNamedTypeElementBase,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression | N.Identifier {\n    if (this.eat(tt.bracketL)) {\n      (prop as Undone<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      // We check if it's valid for it to be a private name when we push it.\n      const { type, value } = this.state;\n      let key;\n      // most un-computed property names are identifiers\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case tt.num:\n            key = this.parseNumericLiteral(value);\n            break;\n          case tt.string:\n            key = this.parseStringLiteral(value);\n            break;\n          case tt.bigint:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case tt.decimal:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case tt.privateName: {\n            // the class private key has been handled in parseClassElementName\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, {\n                at: privateKeyLoc,\n              });\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            this.unexpected();\n        }\n      }\n      (prop as any).key = key;\n      if (type !== tt.privateName) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  // Initialize empty function node.\n\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod>(\n    this: Parser,\n    node: Undone<T>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: T[\"type\"],\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(\n      ScopeFlag.FUNCTION |\n        ScopeFlag.SUPER |\n        (inClassScope ? ScopeFlag.CLASS : 0) |\n        (allowDirectSuper ? ScopeFlag.DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return finishedNode;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    this: Parser,\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode<N.ArrayExpression | N.TupleExpression>();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[] | undefined | null,\n    isAsync: boolean,\n    trailingCommaLoc?: Position | null,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody[In] :\n    //   [lookahead ≠ {] ExpressionBody[?In, ~Await]\n    //   { FunctionBody[~Yield, ~Await] }\n    if (!this.match(tt.braceL) && this.prodParam.hasIn) {\n      flags |= ParamKind.PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[],\n    trailingCommaLoc?: Position | null,\n  ): void {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params as (N.Pattern | N.TSParameterProperty)[];\n  }\n\n  parseFunctionBodyAndFinish<\n    T extends\n      | N.Function\n      | N.TSDeclareMethod\n      | N.TSDeclareFunction\n      | N.ClassPrivateMethod,\n  >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n    // @ts-expect-error (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    this: Parser,\n    node: Undone<N.Function>,\n    allowExpression?: boolean | null,\n    isMethod: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      (node as Undone<N.ArrowFunctionExpression>).body =\n        this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(\n        this.prodParam.currentFlags() | ParamKind.PARAM_RETURN,\n      );\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            this.raise(Errors.IllegalLanguageModeDirective, {\n              at:\n                // @ts-expect-error kind may not index node\n                (node.kind === \"method\" || node.kind === \"constructor\") &&\n                // @ts-expect-error key may not index node\n                !!node.key\n                  ? // @ts-expect-error node.key has been guarded\n                    node.key.loc.end\n                  : node,\n            });\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkIdentifier(\n              node.id,\n              BindingFlag.TYPE_OUTSIDE,\n              strictModeChanged,\n            );\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(\n    params: ReadonlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: Undone<N.Function>,\n    allowDuplicates: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isArrowFunction?: boolean | null,\n    strictModeChanged: boolean = true,\n  ): void {\n    const checkClashes = !allowDuplicates && new Set<string>();\n    // We create a fake node with the \"ephemeral\" type `FormalParameters`[1]\n    // since we just store an array of parameters. Perhaps someday we can have\n    // something like class FormalParameters extends Array { ... }, which would\n    // also be helpful when traversing this node.\n    //\n    // 1. https://tc39.es/ecma262/#prod-FormalParameters\n    const formalParameters = { type: \"FormalParameters\" } as const;\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BindingFlag.TYPE_VAR,\n        checkClashes,\n        strictModeChanged,\n      });\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    this: Parser,\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    nodeForExtra?: N.Node | null,\n  ): (N.Expression | null)[] {\n    const elts: (N.Expression | null)[] = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: false,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\",\n        });\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors),\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc,\n        });\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode<N.Identifier>();\n    const name = this.parseIdentifierName(liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(\n    node: Omit<N.Identifier, \"type\">,\n    name: string,\n  ): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(liberal?: boolean): string {\n    let name: string;\n\n    const { startLoc, type } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      if (tokenIsKeyword) {\n        this.replaceToken(tt.name);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: Position,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    // Every JavaScript reserved word is 10 characters or less.\n    if (word.length > 10) {\n      return;\n    }\n    // Most identifiers are not reservedWord-like, they don't need special\n    // treatments afterward, which very likely ends up throwing errors\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word,\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n        ? isStrictBindReservedWord\n        : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word,\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, { at: startLoc });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, { at: startLoc });\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc,\n        });\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError({ at: startLoc });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, { at: startLoc });\n        return;\n      }\n    }\n  }\n\n  isAwaitAllowed(): boolean {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(this: Parser, startLoc: Position): N.AwaitExpression {\n    const node = this.startNodeAt<N.AwaitExpression>(startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.AwaitExpressionFormalParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(Errors.ObsoleteAwaitStar, { at: node });\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    if (this.hasPrecedingLineBreak()) return true;\n    const { type } = this.state;\n    return (\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``, await of []\n      type === tt.plusMin ||\n      type === tt.parenL ||\n      type === tt.bracketL ||\n      tokenIsTemplate(type) ||\n      (type === tt._of && !this.state.containsEsc) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      type === tt.regexp ||\n      type === tt.slash ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && type === tt.modulo)\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(this: Parser): N.YieldExpression {\n    const node = this.startNode<N.YieldExpression>();\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.YieldInParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    this.next();\n    let delegating = false;\n    let argument: N.Expression | null = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(tt.star);\n      switch (this.state.type) {\n        case tt.semi:\n        case tt.eof:\n        case tt.braceR:\n        case tt.parenR:\n        case tt.bracketR:\n        case tt.braceBarR:\n        case tt.colon:\n        case tt.comma:\n          // The above is the complete set of tokens that can\n          // follow an AssignmentExpression, and none of them\n          // can start an AssignmentExpression\n          if (!delegating) break;\n        /* fallthrough */\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportCall\n  parseImportCall(\n    this: Parser,\n    node: Undone<N.ImportExpression>,\n  ): N.ImportExpression {\n    this.next(); // eat tt.parenL\n    node.source = this.parseMaybeAssignAllowIn();\n    if (\n      this.hasPlugin(\"importAttributes\") ||\n      this.hasPlugin(\"importAssertions\")\n    ) {\n      node.options = null;\n    }\n    if (this.eat(tt.comma)) {\n      this.expectImportAttributesPlugin();\n      if (!this.match(tt.parenR)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        this.eat(tt.comma);\n      }\n    }\n    this.expect(tt.parenR);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartLoc: Position) {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc,\n        });\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr: N.Expression, startLoc: Position) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt<N.PipelineBareFunction>(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt<N.PipelineTopicExpression>(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a topic-style smart-mix pipe body is parsed.\n  // The `startLoc` is the starting position of the pipe body.\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc: Position): void {\n    // If the following token is invalidly `=>`, then throw a human-friendly error\n    // instead of something like 'Unexpected token, expected \";\"'.\n    // For example, `x => x |> y => #` (assuming `#` is the topic reference)\n    // groups into `x => (x |> y) => #`,\n    // and `(x |> y) => #` is an invalid arrow function.\n    // This is because smart-mix `|>` has tighter precedence than `=>`.\n    if (this.match(tt.arrow)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, { at: this.state.startLoc });\n    }\n\n    // A topic-style smart-mix pipe body must use the topic reference at least once.\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, { at: startLoc });\n    }\n  }\n\n  // Enable topic references from outer contexts within Hack-style pipe bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references.\n  // The function then calls a callback, then resets the parser\n  // to the old topic-context state that it had before the function was called.\n\n  withTopicBindingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // This helper method is used only with the deprecated smart-mix pipe proposal.\n  // Disables topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withSmartMixTopicForbiddingContext<T>(callback: () => T): T {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      // Reset the parser’s topic context only if the smart-mix pipe proposal is active.\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        // Disable the use of the primary topic reference.\n        maxNumOfResolvableTopics: 0,\n        // Hide the use of any topic references from outer contexts.\n        maxTopicIndex: null,\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      // If the pipe proposal is \"minimal\", \"fsharp\", or \"hack\",\n      // or if no pipe proposal is active,\n      // then the callback result is returned\n      // without touching any extra parser state.\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = ParamKind.PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = ParamKind.PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a topic reference within the current\n  // topic-binding context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(this: Parser, prec: number): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(this: Parser): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    if (!this.match(tt.braceL)) {\n      this.unexpected(null, tt.braceL);\n    }\n    // start program node immediately after `{`\n    const program = this.startNodeAt<N.Program>(this.state.endLoc);\n    this.next(); // eat `{`\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n\n  // Used in Flow plugin\n  parsePropertyNamePrefixOperator(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prop: Undone<N.ObjectOrClassMember | N.ClassMember>,\n  ): void {}\n}\n", "import type * as N from \"../types.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLoop,\n  tokenIsTemplate,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types.ts\";\nimport ExpressionParser from \"./expression.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier.ts\";\nimport * as charCodes from \"charcodes\";\nimport {\n  ScopeFlag,\n  ClassElementType,\n  BindingFlag,\n} from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope.ts\";\nimport type { SourceType } from \"../options.ts\";\nimport { Token } from \"../tokenizer/index.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../util/location.ts\";\nimport { cloneStringLiteral, cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\nimport { ParseBindingListFlags } from \"./lval.ts\";\n\nconst loopLabel = { kind: \"loop\" } as const,\n  switchLabel = { kind: \"switch\" } as const;\n\nexport const enum ParseFunctionFlag {\n  Expression = 0b0000,\n  Declaration = 0b0001,\n  HangingDeclaration = 0b0010,\n  NullableId = 0b0100,\n  Async = 0b1000,\n}\n\nexport const enum ParseStatementFlag {\n  StatementOnly = 0b0000,\n  AllowImportExport = 0b0001,\n  AllowDeclaration = 0b0010,\n  AllowFunctionDeclaration = 0b0100,\n  AllowLabeledFunction = 0b1000,\n}\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tokens for backward Babel 7 compat.\n * tt.privateName => tt.hash + tt.name\n * tt.templateTail => tt.backquote/tt.braceR + tt.template + tt.backquote\n * tt.templateNonTail => tt.backquote/tt.braceR + tt.template + tt.dollarBraceL\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n */\nfunction babel7CompatTokens(tokens: (Token | N.Comment)[], input: string) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (typeof type === \"number\") {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (type === tt.privateName) {\n          const { loc, start, value, end } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(\n            i,\n            1,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.hash),\n              value: \"#\",\n              start: start,\n              end: hashEndPos,\n              startLoc: loc.start,\n              endLoc: hashEndLoc,\n            }),\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.name),\n              value: value,\n              start: hashEndPos,\n              end: end,\n              startLoc: hashEndLoc,\n              endLoc: loc.end,\n            }),\n          );\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const { loc, start, value, end } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === charCodes.graveAccent) {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          } else {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.braceR),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          }\n          let templateValue,\n            templateElementEnd,\n            templateElementEndLoc,\n            endToken;\n          if (type === tt.templateTail) {\n            // ends with '`'\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          } else {\n            // ends with `${`\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.dollarBraceL),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          }\n          tokens.splice(\n            i,\n            1,\n            startToken,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.template),\n              value: templateValue,\n              start: backquoteEnd,\n              end: templateElementEnd,\n              startLoc: backquoteEndLoc,\n              endLoc: templateElementEndLoc,\n            }),\n            endToken,\n          );\n          i += 2;\n          continue;\n        }\n      }\n      // @ts-expect-error: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default abstract class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(this: Parser, file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    this: Parser,\n    program: Undone<N.Program>,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, { at, localName });\n      }\n    }\n    let finishedProgram: N.Program;\n    if (end === tt.eof) {\n      // finish at eof for top level program\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      // finish immediately before the end token\n      finishedProgram = this.finishNodeAt(\n        program,\n        \"Program\",\n        createPositionWithColumnOffset(this.state.startLoc, -1),\n      );\n    }\n    return finishedProgram;\n  }\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = stmt as any;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode<N.InterpreterDirective>();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n\n  chStartsBindingIdentifier(ch: number, pos: number) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identifier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === charCodes.backslash) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  chStartsBindingPattern(ch: number) {\n    return (\n      ch === charCodes.leftSquareBracket || ch === charCodes.leftCurlyBrace\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `let` and declaration is allowed, check if it\n   * starts a variable declaration so that it should be interpreted as a keyword.\n   */\n  hasFollowingBindingAtom(): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return (\n      this.chStartsBindingPattern(nextCh) ||\n      this.chStartsBindingIdentifier(nextCh, next)\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `using` and declaration is allowed, check if it\n   * starts a variable declaration in the same line so that it should be interpreted as\n   * a keyword.\n   */\n  hasInLineFollowingBindingIdentifier(): boolean {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n\n  startsUsingForOf(): boolean {\n    const { type, containsEsc } = this.lookahead();\n    if (type === tt._of && !containsEsc) {\n      // `using of` must start a for-lhs-of statement\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n\n  startsAwaitUsing(): boolean {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleItem\n  parseModuleItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowImportExport |\n        ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        // This function is actually also used to parse StatementItems,\n        // which with Annex B enabled allows labeled functions.\n        ParseStatementFlag.AllowLabeledFunction,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-StatementListItem\n  parseStatementListItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        (!this.options.annexB || this.state.strict\n          ? 0\n          : ParseStatementFlag.AllowLabeledFunction),\n    );\n  }\n\n  parseStatementOrSloppyAnnexBFunctionDeclaration(\n    this: Parser,\n    allowLabeledFunction: boolean = false,\n  ) {\n    let flags: ParseStatementFlag = ParseStatementFlag.StatementOnly;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= ParseStatementFlag.AllowFunctionDeclaration;\n      if (allowLabeledFunction) {\n        flags |= ParseStatementFlag.AllowLabeledFunction;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  parseStatement(this: Parser) {\n    return this.parseStatementLike(ParseStatementFlag.StatementOnly);\n  }\n\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatementLike(\n    this: Parser,\n    flags: ParseStatementFlag,\n  ):\n    | N.Statement\n    | N.Declaration\n    | N.ImportDeclaration\n    | N.ExportDefaultDeclaration\n    | N.ExportNamedDeclaration\n    | N.ExportAllDeclaration {\n    let decorators: N.Decorator[] | null = null;\n\n    if (this.match(tt.at)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n\n  parseStatementContent(\n    this: Parser,\n    flags: ParseStatementFlag,\n    decorators?: N.Decorator[] | null,\n  ): N.Statement {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);\n    const allowFunctionDeclaration = !!(\n      flags & ParseStatementFlag.AllowFunctionDeclaration\n    );\n    const topLevel = flags & ParseStatementFlag.AllowImportExport;\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node as Undone<N.DebuggerStatement>);\n      case tt._do:\n        return this.parseDoWhileStatement(node as Undone<N.DoWhileStatement>);\n      case tt._for:\n        return this.parseForStatement(node as Undone<N.ForStatement>);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(\n            this.state.strict\n              ? Errors.StrictFunction\n              : this.options.annexB\n                ? Errors.SloppyFunctionAnnexB\n                : Errors.SloppyFunction,\n            { at: this.state.startLoc },\n          );\n        }\n        return this.parseFunctionStatement(\n          node as Undone<N.FunctionDeclaration>,\n          false,\n          !allowDeclaration && allowFunctionDeclaration,\n        );\n      case tt._class:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(\n          this.maybeTakeDecorators(\n            decorators,\n            node as Undone<N.ClassDeclaration>,\n          ),\n          true,\n        );\n\n      case tt._if:\n        return this.parseIfStatement(node as Undone<N.IfStatement>);\n      case tt._return:\n        return this.parseReturnStatement(node as Undone<N.ReturnStatement>);\n      case tt._switch:\n        return this.parseSwitchStatement(node as Undone<N.SwitchStatement>);\n      case tt._throw:\n        return this.parseThrowStatement(node as Undone<N.ThrowStatement>);\n      case tt._try:\n        return this.parseTryStatement(node as Undone<N.TryStatement>);\n\n      case tt._await:\n        // [+Await] await [no LineTerminator here] using [no LineTerminator here] BindingList[+Using]\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, { at: node });\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, {\n              at: node,\n            });\n          }\n          this.next(); // eat 'await'\n          return this.parseVarStatement(\n            node as Undone<N.VariableDeclaration>,\n            \"await using\",\n          );\n        }\n        break;\n      case tt._using:\n        // using [no LineTerminator here] BindingList[+Using]\n        if (\n          this.state.containsEsc ||\n          !this.hasInLineFollowingBindingIdentifier()\n        ) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, {\n            at: this.state.startLoc,\n          });\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          \"using\",\n        );\n      case tt._let: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        // `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== charCodes.leftSquareBracket) {\n          if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n          if (\n            !this.chStartsBindingIdentifier(nextCh, next) &&\n            nextCh !== charCodes.leftCurlyBrace\n          ) {\n            break;\n          }\n        }\n      }\n      // fall through\n      case tt._const: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n      }\n      // fall through\n      case tt._var: {\n        const kind = this.state.value;\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          kind,\n        );\n      }\n      case tt._while:\n        return this.parseWhileStatement(node as Undone<N.WhileStatement>);\n      case tt._with:\n        return this.parseWithStatement(node as Undone<N.WithStatement>);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node as Undone<N.EmptyStatement>);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node as Undone<N.ImportDeclaration>);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(\n            node as Undone<\n              | N.ExportAllDeclaration\n              | N.ExportDefaultDeclaration\n              | N.ExportDefaultDeclaration\n            >,\n            decorators,\n          );\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(result);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next(); // eat 'async'\n          return this.parseFunctionStatement(\n            node as Undone<N.FunctionDeclaration>,\n            true,\n            !allowDeclaration && allowFunctionDeclaration,\n          );\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(starttype) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(\n        node as Undone<N.LabeledStatement>,\n        maybeName,\n        // @ts-expect-error migrate to Babel types\n        expr,\n        flags,\n      );\n    } else {\n      return this.parseExpressionStatement(\n        node as Undone<N.ExpressionStatement>,\n        expr,\n        decorators,\n      );\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, { at: node });\n    }\n  }\n\n  decoratorsEnabledBeforeExport(): boolean {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return (\n      this.hasPlugin(\"decorators\") &&\n      this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false\n    );\n  }\n\n  // Attach the decorators to the given class.\n  // NOTE: This method changes the .start location of the class, and thus\n  // can affect comment attachment. Calling it before or after finalizing\n  // the class node (and thus finalizing its comments) changes how comments\n  // before the `class` keyword or before the final .start location of the\n  // class are attached.\n  maybeTakeDecorators<T extends Undone<N.Class>>(\n    maybeDecorators: N.Decorator[] | null,\n    classNode: T,\n    exportNode?: Undone<N.ExportDefaultDeclaration | N.ExportNamedDeclaration>,\n  ): T {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        // Note: decorators attachment is only attempred multiple times\n        // when the class is part of an export declaration.\n        if (\n          typeof this.getPluginOption(\n            \"decorators\",\n            \"decoratorsBeforeExport\",\n          ) !== \"boolean\"\n        ) {\n          // If `decoratorsBeforeExport` was set to `true` or `false`, we\n          // already threw an error about decorators not being in a valid\n          // position.\n          this.raise(Errors.DecoratorsBeforeAfterExport, {\n            at: classNode.decorators[0],\n          });\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(this: Parser, allowExport?: boolean): N.Decorator[] {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(tt.at));\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc,\n      });\n    }\n\n    return decorators;\n  }\n\n  parseDecorator(this: Parser): N.Decorator {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n    const node = this.startNode<N.Decorator>();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.match(tt.parenL)) {\n        const startLoc = this.state.startLoc;\n        this.next(); // eat '('\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        expr = this.wrapParenthesis(startLoc, expr);\n\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (\n          this.getPluginOption(\"decorators\", \"allowCallParenthesized\") ===\n            false &&\n          node.expression !== expr\n        ) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {\n            at: paramsStartLoc,\n          });\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(tt.privateName)) {\n            this.classScope.usePrivateName(\n              this.state.value,\n              this.state.startLoc,\n            );\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(this: Parser, expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: true,\n  ): N.BreakStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: false,\n  ): N.ContinueStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, { at: node, type });\n    }\n  }\n\n  parseDebuggerStatement(\n    node: Undone<N.DebuggerStatement>,\n  ): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(this: Parser): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  // https://tc39.es/ecma262/#prod-DoWhileStatement\n  parseDoWhileStatement(\n    this: Parser,\n    node: Undone<N.DoWhileStatement>,\n  ): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(\n    this: Parser,\n    node: Undone<N.ForStatement | N.ForInOf>,\n  ): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(tt._await)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(ScopeFlag.OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    {\n      const startsWithAwaitUsing =\n        this.isContextual(tt._await) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration =\n        startsWithAwaitUsing ||\n        (this.isContextual(tt._using) && this.startsUsingForOf());\n      const isLetOrUsing =\n        (startsWithLet && this.hasFollowingBindingAtom()) ||\n        starsWithUsingDeclaration;\n\n      if (this.match(tt._var) || this.match(tt._const) || isLetOrUsing) {\n        const initNode = this.startNode<N.VariableDeclaration>();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.isAwaitAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next(); // eat 'await'\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n        const isForIn = this.match(tt._in);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, { at: init });\n        }\n        if (\n          (isForIn || this.isContextual(tt._of)) &&\n          init.declarations.length === 1\n        ) {\n          return this.parseForIn(node as Undone<N.ForInOf>, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node as Undone<N.ForStatement>, init);\n      }\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, { at: init });\n      }\n\n      if (\n        // `for await (async of []);` is allowed.\n        awaitAt === null &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(Errors.ForOfAsync, { at: init });\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, /* isLHS */ true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, { in: { type } });\n      return this.parseForIn(\n        node as Undone<N.ForInStatement | N.ForOfStatement>,\n        // @ts-expect-error init has been transformed to an assignable\n        init,\n        awaitAt,\n      );\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node as Undone<N.ForStatement>, init);\n  }\n\n  // https://tc39.es/ecma262/#prod-HoistableDeclaration\n  parseFunctionStatement(\n    this: Parser,\n    node: Undone<N.FunctionDeclaration>,\n    isAsync: boolean,\n    isHangingDeclaration: boolean,\n  ): N.FunctionDeclaration {\n    this.next(); // eat 'function'\n    return this.parseFunction(\n      node,\n      ParseFunctionFlag.Declaration |\n        (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) |\n        (isAsync ? ParseFunctionFlag.Async : 0),\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-IfStatement\n  parseIfStatement(this: Parser, node: Undone<N.IfStatement>) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    // Annex B.3.3\n    // https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(tt._else)\n      ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()\n      : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(this: Parser, node: Undone<N.ReturnStatement>) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, { at: this.state.startLoc });\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-SwitchStatement\n  parseSwitchStatement(this: Parser, node: Undone<N.SwitchStatement>) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases: N.SwitchStatement[\"cases\"] = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(ScopeFlag.OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        // @ts-expect-error Fixme\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(this: Parser, node: Undone<N.ThrowStatement>) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(this: Parser): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    this.scope.enter(\n      this.options.annexB && param.type === \"Identifier\"\n        ? ScopeFlag.SIMPLE_CATCH\n        : 0,\n    );\n    this.checkLVal(param, {\n      in: { type: \"CatchClause\" },\n      binding: BindingFlag.TYPE_CATCH_PARAM,\n    });\n\n    return param;\n  }\n\n  parseTryStatement(\n    this: Parser,\n    node: Undone<N.TryStatement>,\n  ): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode<N.CatchClause>();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(ScopeFlag.OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, { at: node });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-VariableStatement\n  // https://tc39.es/ecma262/#prod-LexicalDeclaration\n  parseVarStatement(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  // https://tc39.es/ecma262/#prod-WhileStatement\n  parseWhileStatement(\n    this: Parser,\n    node: Undone<N.WhileStatement>,\n  ): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(\n    this: Parser,\n    node: Undone<N.WithStatement>,\n  ): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, { at: this.state.startLoc });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: Undone<N.EmptyStatement>): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-LabelledStatement\n  parseLabeledStatement(\n    this: Parser,\n    node: Undone<N.LabeledStatement>,\n    maybeName: string,\n    expr: N.Identifier,\n    flags: ParseStatementFlag,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName,\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? \"loop\"\n      : this.match(tt._switch)\n        ? \"switch\"\n        : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    // https://tc39.es/ecma262/#prod-LabelledItem\n    node.body =\n      flags & ParseStatementFlag.AllowLabeledFunction\n        ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)\n        : this.parseStatement();\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: Undone<N.ExpressionStatement>,\n    expr: N.Expression,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    decorators: N.Decorator[] | null,\n  ) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    this: Parser,\n    allowDirectives: boolean = false,\n    createNewLexicalScope: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode<N.BlockStatement>();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(ScopeFlag.OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    this: Parser,\n    node: Undone<N.BlockStatementLike>,\n    allowDirectives: boolean | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body: N.BlockStatementLike[\"body\"] = (node.body = []);\n    const directives: N.BlockStatementLike[\"directives\"] = (node.directives =\n      []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    this: Parser,\n    body: N.Statement[],\n    directives: N.Directive[] | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = topLevel\n        ? this.parseModuleItem()\n        : this.parseStatementListItem();\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    afterBlockParse?.call(this, hasStrictModeDirective);\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    this: Parser,\n    node: Undone<N.ForStatement>,\n    init?: N.VariableDeclaration | N.Expression | null,\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    this: Parser,\n    node: Undone<N.ForInOf>,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt?: Position | null,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        !this.options.annexB ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\",\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: { type: \"ForStatement\" },\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): Undone<N.VariableDeclaration> {\n    const declarations: N.VariableDeclarator[] = (node.declarations = []);\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode<N.VariableDeclarator>();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(tt.eq)\n        ? null\n        : isFor\n          ? this.parseMaybeAssignDisallowIn()\n          : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\",\n          });\n        } else if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\",\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(\n    this: Parser,\n    decl: Undone<N.VariableDeclarator>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  ): void {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: { type: \"VariableDeclarator\" },\n      binding: kind === \"var\" ? BindingFlag.TYPE_VAR : BindingFlag.TYPE_LEXICAL,\n    });\n    decl.id = id;\n  }\n\n  // https://tc39.es/ecma262/#prod-AsyncFunctionExpression\n  parseAsyncFunctionExpression(\n    this: Parser,\n    node: Undone<N.FunctionExpression>,\n  ): N.FunctionExpression {\n    return this.parseFunction(node, ParseFunctionFlag.Async);\n  }\n\n  // Parse a function declaration or expression (depending on the\n  // ParseFunctionFlag.Declaration flag).\n\n  parseFunction<T extends N.NormalFunction>(\n    this: Parser,\n    node: Undone<T>,\n    flags: ParseFunctionFlag = ParseFunctionFlag.Expression,\n  ): T {\n    const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;\n    const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);\n    const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);\n    const isAsync = !!(flags & ParseFunctionFlag.Async);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, {\n          at: this.state.startLoc,\n        });\n      }\n      this.next(); // eat *\n      node.generator = true;\n    }\n\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(ScopeFlag.FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* isConstructor */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isDeclaration && !hangingDeclaration) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node as T);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node as T;\n  }\n\n  parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(\n    this: Parser,\n    node: Undone<N.Function>,\n    isConstructor?: boolean,\n  ): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      ParseBindingListFlags.IS_FUNCTION_PARAMS |\n        (isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0),\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BindingFlag.TYPE_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      !this.options.annexB || this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BindingFlag.TYPE_VAR\n          : BindingFlag.TYPE_LEXICAL\n        : BindingFlag.TYPE_FUNCTION,\n      node.id.loc.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T extends N.Class>(\n    this: Parser,\n    node: Undone<T>,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next(); // 'class'\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    this: Parser,\n    hadSuperClass: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody = this.startNode<N.ClassBody>();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc,\n            });\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode<N.ClassMember>();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          // @ts-expect-error Fixme\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          // @ts-expect-error Fixme\n          member.kind === \"constructor\" &&\n          // @ts-expect-error Fixme\n          member.decorators &&\n          // @ts-expect-error Fixme\n          member.decorators.length > 0\n        ) {\n          this.raise(Errors.DecoratorConstructor, { at: member });\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = member as any;\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = member as any;\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod = member as N.ClassMethod;\n    const privateMethod = member as N.ClassPrivateMethod;\n    const publicProp = member as N.ClassProperty;\n    const privateProp = member as N.ClassPrivateProperty;\n    const accessorProp = member as N.ClassAccessorProperty;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key,\n        });\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(tt.privateName);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, { at: key });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, { at: key });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isContextual &&\n      key.name === \"async\" &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key });\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isContextual &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key });\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (\n      isContextual &&\n      key.name === \"accessor\" &&\n      !this.isLineTerminator()\n    ) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      // The so-called parsed name would have been \"accessor\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(\n    this: Parser,\n    member: Undone<N.ClassMember>,\n  ): N.Expression | N.Identifier {\n    const { type, value } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(Errors.StaticPrototype, { at: this.state.startLoc });\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc,\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<\n      N.StaticBlock & {\n        decorators?: Array<N.Decorator>;\n      }\n    >,\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(\n      ScopeFlag.CLASS | ScopeFlag.STATIC_BLOCK | ScopeFlag.SUPER,\n    );\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(ParamKind.PARAM);\n    const body: N.Node[] = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(Errors.DecoratorStaticBlock, { at: member });\n    }\n  }\n\n  pushClassProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassProperty,\n  ) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, { at: prop.key });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: Undone<N.ClassPrivateProperty>,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      ClassElementType.OTHER,\n      node.key.loc.start,\n    );\n  }\n\n  pushClassAccessorProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassAccessorProperty,\n    isPrivate: boolean,\n  ) {\n    if (!isPrivate && !prop.computed) {\n      // Not private, so not node is not a PrivateName and we can safely cast\n      const key = prop.key as N.Expression;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        // Non-computed field, which is either an identifier named \"constructor\"\n        // or a string literal named \"constructor\"\n        this.raise(Errors.ConstructorClassField, { at: key });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(\n        this.getPrivateNameSV(node.key),\n        ClassElementType.OTHER,\n        node.key.loc.start,\n      );\n    }\n  }\n\n  pushClassMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassPrivateMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? ClassElementType.STATIC_GETTER\n          : ClassElementType.INSTANCE_GETTER\n        : node.kind === \"set\"\n          ? node.static\n            ? ClassElementType.STATIC_SETTER\n            : ClassElementType.INSTANCE_SETTER\n          : ClassElementType.OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: Undone<\n      N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod\n    >,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.loc.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    methodOrProp: Undone<N.ClassMethod | N.ClassProperty>,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    this: Parser,\n    node: Undone<N.ClassPrivateProperty>,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(\n    this: Parser,\n    node: N.ClassAccessorProperty,\n  ): N.ClassAccessorProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(\n    this: Parser,\n    node: Undone<\n      N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty\n    >,\n  ): void {\n    this.scope.enter(ScopeFlag.CLASS | ScopeFlag.SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(ParamKind.PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: Undone<N.Class>,\n    isStatement: boolean,\n    optionalId?: boolean | null,\n    bindingType: BindingFlag = BindingFlag.TYPE_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(this: Parser, node: Undone<N.Class>): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(\n    this: Parser,\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    decorators: N.Decorator[] | null,\n  ): N.AnyExport {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n      node,\n      /* isExport */ true,\n    );\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar =\n      parseAfterDefault &&\n      this.eatExportStar(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const hasNamespace =\n      hasStar &&\n      this.maybeParseExportNamespaceSpecifier(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(node as Undone<N.ExportNamedDeclaration>, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, tt.braceL);\n    }\n\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, tt._from);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(\n        node as Undone<N.ExportNamedDeclaration>,\n        isFromRequired,\n      );\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(\n        node as Undone<N.ExportNamedDeclaration>,\n      );\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (node2.declaration?.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      const node2 = node as Undone<N.ExportDefaultDeclaration>;\n      // export default ...\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl as N.ClassDeclaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n\n      this.checkExport(node2, true, true);\n\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n\n    this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): node is Undone<N.ExportNamedDeclaration> {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier?.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode<N.ExportDefaultSpecifier>(id);\n      specifier.exported = id;\n      (node as Undone<N.ExportNamedDeclaration>).specifiers = [\n        this.finishNode(specifier, \"ExportDefaultSpecifier\"),\n      ];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(tt._as)) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n  ): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression(this: Parser): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    if (this.match(tt._function)) {\n      this.next();\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId,\n      );\n    } else if (this.isAsyncFunction()) {\n      this.next(); // eat 'async'\n      this.next(); // eat 'function'\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration |\n          ParseFunctionFlag.NullableId |\n          ParseFunctionFlag.Async,\n      );\n    }\n\n    if (this.match(tt._class)) {\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n      ) {\n        this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc });\n      }\n      return this.parseClass(\n        this.maybeTakeDecorators(\n          this.parseDecorators(false),\n          this.startNode<N.ClassDeclaration>(),\n        ),\n        true,\n        true,\n      );\n    }\n\n    if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc,\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n  parseExportDeclaration(\n    this: Parser,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    node: Undone<N.ExportNamedDeclaration>,\n  ): N.Declaration | undefined | null {\n    if (this.match(tt._class)) {\n      const node = this.parseClass(\n        this.startNode<N.ClassDeclaration>(),\n        true,\n        false,\n      );\n      return node;\n    }\n    return this.parseStatementListItem() as N.Declaration;\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n    expect?: boolean,\n  ): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (\n          this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n        ) {\n          this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: Undone<N.ExportNamedDeclaration | N.ExportDefaultDeclaration>,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = (node as any as N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration,\n            });\n          }\n        }\n        // @ts-expect-error node.specifiers may not exist\n      } else if (node.specifiers?.length) {\n        // Named exports\n        // @ts-expect-error node.specifiers may not exist\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName,\n              });\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      // @ts-expect-error migrate to Babel types\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node: Undone<\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier\n    >,\n    exportName: string,\n  ): void {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, { at: node });\n      } else {\n        this.raise(Errors.DuplicateExport, { at: node, exportName });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0),\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ): boolean {\n    if (node.assertions != null) {\n      return node.assertions.some(({ key, value }) => {\n        return (\n          value.value === \"json\" &&\n          (key.type === \"Identifier\"\n            ? key.name === \"type\"\n            : key.value === \"type\")\n        );\n      });\n    }\n    return false;\n  }\n\n  checkImportReflection(node: Undone<N.ImportDeclaration>) {\n    const { specifiers } = node;\n    const singleBindingType =\n      specifiers.length === 1 ? specifiers[0].type : null;\n\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, {\n          at: specifiers[0].loc.start,\n        });\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, {\n          at: specifiers[0].loc.start,\n        });\n      }\n    } else if (node.module) {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, {\n          at: specifiers[0].loc.start,\n        });\n      }\n      if (node.assertions?.length > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n  }\n\n  checkJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ) {\n    // @ts-expect-error Fixme: node.type must be undefined because they are undone\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      // @ts-expect-error specifiers may not index node\n      const { specifiers } = node;\n      if (specifiers != null) {\n        // @ts-expect-error refine specifier types\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\"\n              ? imported.name !== \"default\"\n              : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start,\n          });\n        }\n      }\n    }\n  }\n\n  isPotentialImportPhase(isExport: boolean): boolean {\n    if (isExport) return false;\n    return (\n      this.isContextual(tt._source) ||\n      this.isContextual(tt._defer) ||\n      this.isContextual(tt._module)\n    );\n  }\n\n  applyImportPhase(\n    node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n    isExport: boolean,\n    phase: string | null,\n    loc?: Position,\n  ): void {\n    if (isExport) {\n      if (!process.env.IS_PUBLISH) {\n        if (phase === \"module\" || phase === \"source\") {\n          throw new Error(\n            `Assertion failure: export declarations do not support the '${phase}' phase.`,\n          );\n        }\n      }\n      return;\n    }\n\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      (node as N.ImportDeclaration).module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      (node as N.ImportDeclaration).module = false;\n    }\n\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      (node as N.ImportDeclaration).phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      (node as N.ImportDeclaration).phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      (node as N.ImportDeclaration).phase = null;\n    }\n  }\n\n  /*\n   * Parse `module` in `import module x from \"x\"`, disambiguating\n   * `import module from \"x\"` and `import module from from \"x\"`.\n   *\n   * This function might return an identifier representing the `module`\n   * if it eats `module` and then discovers that it was the default import\n   * binding and not the import reflection.\n   *\n   * This function is also used to parse `import type` and `import typeof`\n   * in the TS and Flow plugins.\n   *\n   * Note: the proposal has been updated to use `source` instead of `module`,\n   * but it has not been implemented yet.\n   */\n  parseMaybeImportPhase(\n    node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    isExport: boolean,\n  ): N.Identifier | null {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      return null;\n    }\n\n    const phaseIdentifier = this.parseIdentifier(true);\n\n    const { type } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        phaseIdentifier.name,\n        phaseIdentifier.loc.start,\n      );\n      return null;\n    } else {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      // `<phase>` is a default binding, return it to the main import declaration parser\n      return phaseIdentifier;\n    }\n  }\n\n  isPrecedingIdImportPhase(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    phase: string,\n  ) {\n    const { type } = this.state;\n    return tokenIsIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(this: Parser, node: Undone<N.ImportDeclaration>): N.AnyImport {\n    if (this.match(tt.string)) {\n      // import '...'\n      return this.parseImportSourceAndAttributes(node);\n    }\n\n    return this.parseImportSpecifiersAndAfter(\n      node,\n      this.parseMaybeImportPhase(node, /* isExport */ false),\n    );\n  }\n\n  parseImportSpecifiersAndAfter(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): N.AnyImport {\n    node.specifiers = [];\n\n    // check if we have a default import like\n    // import React from \"react\";\n    const hasDefault = this.maybeParseDefaultImportSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    /* we are checking if we do not have a default import, then it is obvious that we need named imports\n     * import { get } from \"axios\";\n     * but if we do have a default import\n     * we need to check if we have a comma after that and\n     * that is where this `|| this.eat` condition comes into play\n     */\n    const parseNext = !hasDefault || this.eat(tt.comma);\n    // if we do have to parse the next set of specifiers, we first check for star imports\n    // import React, * from \"react\";\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    // now we check if we need to parse the next imports\n    // but only if they are not importing * (everything)\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(tt._from);\n\n    return this.parseImportSourceAndAttributes(node);\n  }\n\n  parseImportSourceAndAttributes(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n  ): N.AnyImport {\n    node.specifiers ??= [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(this: Parser): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom() as N.StringLiteral;\n  }\n\n  parseImportSpecifierLocal<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    node: Undone<N.ImportDeclaration>,\n    specifier: Undone<T>,\n    type: T[\"type\"],\n  ): void {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    specifier: Undone<T>,\n    type: T[\"type\"],\n    bindingType: BindingFlag = BindingFlag.TYPE_LEXICAL,\n  ) {\n    this.checkLVal(specifier.local, {\n      in: { type },\n      binding: bindingType,\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-attributes/#prod-WithEntries WithEntries}\n   */\n  parseImportAttributes(): N.ImportAttribute[] {\n    this.expect(tt.braceL);\n\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName,\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    this.expect(tt.braceR);\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   */\n  parseModuleAttributes() {\n    const attrs: N.ImportAttribute[] = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode<N.ImportAttribute>();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key,\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name,\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAttributes(\n    node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n  ) {\n    let attributes: N.ImportAttribute[];\n    let useWith = false;\n\n    // https://tc39.es/proposal-import-attributes/#prod-WithClause\n    if (this.match(tt._with)) {\n      if (\n        this.hasPrecedingLineBreak() &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      ) {\n        // This will be parsed as a with statement, and we will throw a\n        // better error about it not being supported in strict mode.\n        return;\n      }\n\n      this.next(); // eat `with`\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (this.hasPlugin(\"moduleAttributes\")) {\n          attributes = this.parseModuleAttributes();\n        } else {\n          this.expectImportAttributesPlugin();\n          attributes = this.parseImportAttributes();\n        }\n      } else {\n        this.expectImportAttributesPlugin();\n        attributes = this.parseImportAttributes();\n      }\n      useWith = true;\n    } else if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      if (this.hasPlugin(\"importAttributes\")) {\n        if (\n          this.getPluginOption(\"importAttributes\", \"deprecatedAssertSyntax\") !==\n          true\n        ) {\n          this.raise(Errors.ImportAttributesUseAssert, {\n            at: this.state.startLoc,\n          });\n        }\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      } else {\n        this.expectOnePlugin([\"importAttributes\", \"importAssertions\"]);\n      }\n      this.next(); // eat `assert`\n      attributes = this.parseImportAttributes();\n    } else if (\n      this.hasPlugin(\"importAttributes\") ||\n      this.hasPlugin(\"importAssertions\")\n    ) {\n      attributes = [];\n    } else if (!process.env.BABEL_8_BREAKING) {\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = [];\n      } else return;\n    } else return;\n\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n\n  maybeParseDefaultImportSpecifier(\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): boolean {\n    // import defaultObj, { x, y as z } from '...'\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode<N.ImportDefaultSpecifier>(\n        maybeDefaultIdentifier,\n      );\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(\n        this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"),\n      );\n      return true;\n    } else if (\n      // We allow keywords, and parseImportSpecifierLocal will report a recoverable error\n      tokenIsKeywordOrIdentifier(this.state.type)\n    ) {\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode<N.ImportDefaultSpecifier>(),\n        \"ImportDefaultSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode<N.ImportNamespaceSpecifier>();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: Undone<N.ImportDeclaration>) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode<N.ImportSpecifier>();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n        undefined,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: Undone<N.ImportSpecifier>,\n    importedIsString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    bindingType: BindingFlag | undefined,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: (imported as N.StringLiteral).value,\n        });\n      }\n      this.checkReservedWord(\n        (imported as N.Identifier).name,\n        specifier.loc.start,\n        true,\n        true,\n      );\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(\n      specifier,\n      \"ImportSpecifier\",\n      bindingType,\n    );\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n", "import type { Options } from \"../options.ts\";\nimport type * as N from \"../types.ts\";\nimport type { PluginList } from \"../plugin-utils.ts\";\nimport { getOptions } from \"../options.ts\";\nimport StatementParser from \"./statement.ts\";\nimport ScopeHandler from \"../util/scope.ts\";\n\nexport type PluginsMap = Map<\n  string,\n  {\n    [x: string]: any;\n  }\n>;\n\nexport default class Parser extends StatementParser {\n  // Forward-declaration so typescript plugin can override jsx plugin\n  // todo(flow->ts) - this probably can be removed\n  // abstract jsxParseOpeningElementAfterName(\n  //   node: N.JSXOpeningElement,\n  // ): N.JSXOpeningElement;\n\n  constructor(options: Options | undefined | null, input: string) {\n    options = getOptions(options);\n    super(options, input);\n\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  // This can be overwritten, for example, by the TypeScript plugin.\n  getScopeHandler(): {\n    new (...args: any): ScopeHandler;\n  } {\n    return ScopeHandler;\n  }\n\n  parse(): N.File {\n    this.enterInitialScopes();\n    const file = this.startNode() as N.File;\n    const program = this.startNode() as N.Program;\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\n\nfunction pluginsMap(plugins: PluginList): PluginsMap {\n  const pluginMap: PluginsMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\n", "import type { Options } from \"./options.ts\";\nimport {\n  hasPlugin,\n  validatePlugins,\n  mixinPluginNames,\n  mixinPlugins,\n  type PluginList,\n} from \"./plugin-utils.ts\";\nimport type {\n  PluginConfig as ParserPlugin,\n  FlowPluginOptions,\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"./typings.ts\";\nimport Parser from \"./parser/index.ts\";\n\nimport type { ExportedTokenType } from \"./tokenizer/types.ts\";\nimport {\n  getExportedToken,\n  tt as internalTokenTypes,\n  type InternalTokenTypes,\n} from \"./tokenizer/types.ts\";\n\nimport type { Expression, File } from \"./types.ts\";\n\nexport function parse(input: string, options?: Options): File {\n  if (options?.sourceType === \"unambiguous\") {\n    options = {\n      ...options,\n    };\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        // Top level await introduces code which can be both a valid script and\n        // a valid module, but which produces different ASTs:\n        //    await\n        //    0\n        // can be parsed either as an AwaitExpression, or as two ExpressionStatements.\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch {}\n      } else {\n        // This is both a valid module and a valid script, but\n        // we parse it as a script by default\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\n\nexport function parseExpression(input: string, options?: Options): Expression {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(\n  internalTokenTypes: InternalTokenTypes,\n): Record<string, ExportedTokenType> {\n  const tokenTypes: Record<string, ExportedTokenType> = {};\n  for (const typeName of Object.keys(\n    internalTokenTypes,\n  ) as (keyof InternalTokenTypes)[]) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\n\nexport const tokTypes = generateExportedTokenTypes(internalTokenTypes);\n\nfunction getParser(options: Options | undefined | null, input: string): Parser {\n  let cls = Parser;\n  if (options?.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache: { [key: string]: { new (...args: any): Parser } } = {};\n\n/** Get a Parser class with plugins applied. */\nfunction getParserClass(pluginsFromOptions: PluginList): {\n  new (...args: any): Parser;\n} {\n  const pluginList = mixinPluginNames.filter(name =>\n    hasPlugin(pluginsFromOptions, name),\n  );\n\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      // @ts-expect-error todo(flow->ts)\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\n\nexport type {\n  FlowPluginOptions,\n  ParserPlugin,\n  PipelineOperatorPluginOptions,\n  RecordAndTuplePluginOptions,\n};\nexport type ParserOptions = Partial<Options>;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\nfunction SortTemplate(comparator) {\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot, false) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n  return doQuickSort;\n}\n\nfunction cloneSort(comparator) {\n  let template = SortTemplate.toString();\n  let templateFn = new Function(`return ${template}`)();\n  return templateFn(comparator);\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\n\nlet sortCache = new WeakMap();\nexports.quickSort = function (ary, comparator, start = 0) {\n  let doQuickSort = sortCache.get(comparator);\n  if (doQuickSort === void 0) {\n    doQuickSort = cloneSort(comparator);\n    sortCache.set(comparator, doQuickSort);\n  }\n  doQuickSort(ary, comparator, start, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    var boundCallback = aCallback.bind(context);\n    var names = this._names;\n    var sources = this._sources;\n    var sourceMapURL = this._sourceMapURL;\n\n    for (var i = 0, n = mappings.length; i < n; i++) {\n      var mapping = mappings[i];\n      var source = mapping.source === null ? null : sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, sourceMapURL);\n      boundCallback({\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : names.at(mapping.name)\n      });\n    }\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\n\nconst compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;\nfunction sortGenerated(array, start) {\n  let l = array.length;\n  let n = array.length - start;\n  if (n <= 1) {\n    return;\n  } else if (n == 2) {\n    let a = array[start];\n    let b = array[start + 1];\n    if (compareGenerated(a, b) > 0) {\n      array[start] = b;\n      array[start + 1] = a;\n    }\n  } else if (n < 20) {\n    for (let i = start; i < l; i++) {\n      for (let j = i; j > start; j--) {\n        let a = array[j - 1];\n        let b = array[j];\n        if (compareGenerated(a, b) <= 0) {\n          break;\n        }\n        array[j - 1] = b;\n        array[j] = a;\n      }\n    }\n  } else {\n    quickSort(array, compareGenerated, start);\n  }\n}\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    let subarrayStart = 0;\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n\n        sortGenerated(generatedMappings, subarrayStart);\n        subarrayStart = generatedMappings.length;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = [];\n        while (index < end) {\n          base64VLQ.decode(aStr, index, temp);\n          value = temp.value;\n          index = temp.rest;\n          segment.push(value);\n        }\n\n        if (segment.length === 2) {\n          throw new Error('Found a source, but no line and column');\n        }\n\n        if (segment.length === 3) {\n          throw new Error('Found a source and line, but no column');\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          let currentSource = mapping.source;\n          while (originalMappings.length <= currentSource) {\n            originalMappings.push(null);\n          }\n          if (originalMappings[currentSource] === null) {\n            originalMappings[currentSource] = [];\n          }\n          originalMappings[currentSource].push(mapping);\n        }\n      }\n    }\n\n    sortGenerated(generatedMappings, subarrayStart);\n    this.__generatedMappings = generatedMappings;\n\n    for (var i = 0; i < originalMappings.length; i++) {\n      if (originalMappings[i] != null) {\n        quickSort(originalMappings[i], util.compareByOriginalPositionsNoSource);\n      }\n    }\n    this.__originalMappings = [].concat(...originalMappings);\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "// This entry is the \"full-build\" that includes both the runtime\r\n// and the compiler, and supports on-the-fly compilation of the template option.\r\nimport { initDev } from './dev'\r\nimport { compile, CompilerOptions, CompilerError } from '@vue/compiler-dom'\r\nimport { registerRuntimeCompiler, RenderFunction, warn } from '@vue/runtime-dom'\r\nimport * as runtimeDom from '@vue/runtime-dom'\r\nimport {\r\n  isString,\r\n  NOOP,\r\n  generateCodeFrame,\r\n  extend,\r\n  EMPTY_OBJ\r\n} from '@vue/shared'\r\nimport { InternalRenderFunction } from 'packages/runtime-core/src/component'\r\n\r\nif (__DEV__) {\r\n  initDev()\r\n}\r\n\r\nconst compileCache = new WeakMap<\r\n  CompilerOptions,\r\n  Record<string, RenderFunction>\r\n>()\r\n\r\nfunction getCache(options?: CompilerOptions) {\r\n  let c = compileCache.get(options ?? EMPTY_OBJ)\r\n  if (!c) {\r\n    c = Object.create(null) as Record<string, RenderFunction>\r\n    compileCache.set(options ?? EMPTY_OBJ, c)\r\n  }\r\n  return c\r\n}\r\n\r\nfunction compileToFunction(\r\n  template: string | HTMLElement,\r\n  options?: CompilerOptions\r\n): RenderFunction {\r\n  if (!isString(template)) {\r\n    if (template.nodeType) {\r\n      template = template.innerHTML\r\n    } else {\r\n      __DEV__ && warn(`invalid template option: `, template)\r\n      return NOOP\r\n    }\r\n  }\r\n\r\n  const key = template\r\n  const cache = getCache(options)\r\n  const cached = cache[key]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n\r\n  if (template[0] === '#') {\r\n    const el = document.querySelector(template)\r\n    if (__DEV__ && !el) {\r\n      warn(`Template element not found or is empty: ${template}`)\r\n    }\r\n    // __UNSAFE__\r\n    // Reason: potential execution of JS expressions in in-DOM template.\r\n    // The user must make sure the in-DOM template is trusted. If it's rendered\r\n    // by the server, the template should not contain any user data.\r\n    template = el ? el.innerHTML : ``\r\n  }\r\n\r\n  const opts = extend(\r\n    {\r\n      hoistStatic: true,\r\n      onError: __DEV__ ? onError : undefined,\r\n      onWarn: __DEV__ ? e => onError(e, true) : NOOP\r\n    } as CompilerOptions,\r\n    options\r\n  )\r\n\r\n  if (!opts.isCustomElement && typeof customElements !== 'undefined') {\r\n    opts.isCustomElement = tag => !!customElements.get(tag)\r\n  }\r\n\r\n  const { code } = compile(template, opts)\r\n\r\n  function onError(err: CompilerError, asWarning = false) {\r\n    const message = asWarning\r\n      ? err.message\r\n      : `Template compilation error: ${err.message}`\r\n    const codeFrame =\r\n      err.loc &&\r\n      generateCodeFrame(\r\n        template as string,\r\n        err.loc.start.offset,\r\n        err.loc.end.offset\r\n      )\r\n    warn(codeFrame ? `${message}\\n${codeFrame}` : message)\r\n  }\r\n\r\n  // The wildcard import results in a huge object with every export\r\n  // with keys that cannot be mangled, and can be quite heavy size-wise.\r\n  // In the global build we know `Vue` is available globally so we can avoid\r\n  // the wildcard object.\r\n  const render = (\r\n    __GLOBAL__ ? new Function(code)() : new Function('Vue', code)(runtimeDom)\r\n  ) as RenderFunction\r\n\r\n  // mark the function as runtime compiled\r\n  ;(render as InternalRenderFunction)._rc = true\r\n\r\n  return (cache[key] = render)\r\n}\r\n\r\nregisterRuntimeCompiler(compileToFunction)\r\n\r\nexport { compileToFunction as compile }\r\nexport * from '@vue/runtime-dom'\r\n", "// using literal strings instead of numbers so that it's easier to inspect\r\n// debugger events\r\n\r\nexport const enum TrackOpTypes {\r\n  GET = 'get',\r\n  HAS = 'has',\r\n  ITERATE = 'iterate'\r\n}\r\n\r\nexport const enum TriggerOpTypes {\r\n  SET = 'set',\r\n  ADD = 'add',\r\n  DELETE = 'delete',\r\n  CLEAR = 'clear'\r\n}\r\n", "/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nexport function makeMap(\r\n  str: string,\r\n  expectsLowerCase?: boolean\r\n): (key: string) => boolean {\r\n  const map: Record<string, boolean> = Object.create(null)\r\n  const list: Array<string> = str.split(',')\r\n  for (let i = 0; i < list.length; i++) {\r\n    map[list[i]] = true\r\n  }\r\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\r\n}\r\n", "import { makeMap } from './makeMap'\r\n\r\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\r\n  ? Object.freeze({})\r\n  : {}\r\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\r\n\r\nexport const NOOP = () => {}\r\n\r\n/**\r\n * Always return false.\r\n */\r\nexport const NO = () => false\r\n\r\nexport const isOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // uppercase letter\r\n  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97)\r\n\r\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\r\n\r\nexport const extend = Object.assign\r\n\r\nexport const remove = <T>(arr: T[], el: T) => {\r\n  const i = arr.indexOf(el)\r\n  if (i > -1) {\r\n    arr.splice(i, 1)\r\n  }\r\n}\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (\r\n  val: object,\r\n  key: string | symbol\r\n): key is keyof typeof val => hasOwnProperty.call(val, key)\r\n\r\nexport const isArray = Array.isArray\r\nexport const isMap = (val: unknown): val is Map<any, any> =>\r\n  toTypeString(val) === '[object Map]'\r\nexport const isSet = (val: unknown): val is Set<any> =>\r\n  toTypeString(val) === '[object Set]'\r\n\r\nexport const isDate = (val: unknown): val is Date =>\r\n  toTypeString(val) === '[object Date]'\r\nexport const isRegExp = (val: unknown): val is RegExp =>\r\n  toTypeString(val) === '[object RegExp]'\r\nexport const isFunction = (val: unknown): val is Function =>\r\n  typeof val === 'function'\r\nexport const isString = (val: unknown): val is string => typeof val === 'string'\r\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\r\nexport const isObject = (val: unknown): val is Record<any, any> =>\r\n  val !== null && typeof val === 'object'\r\n\r\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\r\n  return (\r\n    (isObject(val) || isFunction(val)) &&\r\n    isFunction((val as any).then) &&\r\n    isFunction((val as any).catch)\r\n  )\r\n}\r\n\r\nexport const objectToString = Object.prototype.toString\r\nexport const toTypeString = (value: unknown): string =>\r\n  objectToString.call(value)\r\n\r\nexport const toRawType = (value: unknown): string => {\r\n  // extract \"RawType\" from strings like \"[object RawType]\"\r\n  return toTypeString(value).slice(8, -1)\r\n}\r\n\r\nexport const isPlainObject = (val: unknown): val is object =>\r\n  toTypeString(val) === '[object Object]'\r\n\r\nexport const isIntegerKey = (key: unknown) =>\r\n  isString(key) &&\r\n  key !== 'NaN' &&\r\n  key[0] !== '-' &&\r\n  '' + parseInt(key, 10) === key\r\n\r\nexport const isReservedProp = /*#__PURE__*/ makeMap(\r\n  // the leading comma is intentional so empty string \"\" is also included\r\n  ',key,ref,ref_for,ref_key,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\r\n)\r\n\r\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\r\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\r\n)\r\n\r\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\r\n  const cache: Record<string, string> = Object.create(null)\r\n  return ((str: string) => {\r\n    const hit = cache[str]\r\n    return hit || (cache[str] = fn(str))\r\n  }) as T\r\n}\r\n\r\nconst camelizeRE = /-(\\w)/g\r\n/**\r\n * @private\r\n */\r\nexport const camelize = cacheStringFunction((str: string): string => {\r\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\r\n})\r\n\r\nconst hyphenateRE = /\\B([A-Z])/g\r\n/**\r\n * @private\r\n */\r\nexport const hyphenate = cacheStringFunction((str: string) =>\r\n  str.replace(hyphenateRE, '-$1').toLowerCase()\r\n)\r\n\r\n/**\r\n * @private\r\n */\r\nexport const capitalize = cacheStringFunction(<T extends string>(str: T) => {\r\n  return (str.charAt(0).toUpperCase() + str.slice(1)) as Capitalize<T>\r\n})\r\n\r\n/**\r\n * @private\r\n */\r\nexport const toHandlerKey = cacheStringFunction(<T extends string>(str: T) => {\r\n  const s = str ? `on${capitalize(str)}` : ``\r\n  return s as T extends '' ? '' : `on${Capitalize<T>}`\r\n})\r\n\r\n// compare whether a value has changed, accounting for NaN.\r\nexport const hasChanged = (value: any, oldValue: any): boolean =>\r\n  !Object.is(value, oldValue)\r\n\r\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\r\n  for (let i = 0; i < fns.length; i++) {\r\n    fns[i](arg)\r\n  }\r\n}\r\n\r\nexport const def = (obj: object, key: string | symbol, value: any) => {\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    value\r\n  })\r\n}\r\n\r\n/**\r\n * \"123-foo\" will be parsed to 123\r\n * This is used for the .number modifier in v-model\r\n */\r\nexport const looseToNumber = (val: any): any => {\r\n  const n = parseFloat(val)\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\n/**\r\n * Only concerns number-like strings\r\n * \"123-foo\" will be returned as-is\r\n */\r\nexport const toNumber = (val: any): any => {\r\n  const n = isString(val) ? Number(val) : NaN\r\n  return isNaN(n) ? val : n\r\n}\r\n\r\nlet _globalThis: any\r\nexport const getGlobalThis = (): any => {\r\n  return (\r\n    _globalThis ||\r\n    (_globalThis =\r\n      typeof globalThis !== 'undefined'\r\n        ? globalThis\r\n        : typeof self !== 'undefined'\r\n          ? self\r\n          : typeof window !== 'undefined'\r\n            ? window\r\n            : typeof global !== 'undefined'\r\n              ? global\r\n              : {})\r\n  )\r\n}\r\n\r\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/\r\n\r\nexport function genPropsAccessExp(name: string) {\r\n  return identRE.test(name)\r\n    ? `__props.${name}`\r\n    : `__props[${JSON.stringify(name)}]`\r\n}\r\n", "/**\r\n * Patch flags are optimization hints generated by the compiler.\r\n * when a block with dynamicChildren is encountered during diff, the algorithm\r\n * enters \"optimized mode\". In this mode, we know that the vdom is produced by\r\n * a render function generated by the compiler, so the algorithm only needs to\r\n * handle updates explicitly marked by these patch flags.\r\n *\r\n * Patch flags can be combined using the | bitwise operator and can be checked\r\n * using the & operator, e.g.\r\n *\r\n * ```js\r\n * const flag = TEXT | CLASS\r\n * if (flag & TEXT) { ... }\r\n * ```\r\n *\r\n * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the\r\n * flags are handled during diff.\r\n */\r\nexport const enum PatchFlags {\r\n  /**\r\n   * Indicates an element with dynamic textContent (children fast path)\r\n   */\r\n  TEXT = 1,\r\n\r\n  /**\r\n   * Indicates an element with dynamic class binding.\r\n   */\r\n  CLASS = 1 << 1,\r\n\r\n  /**\r\n   * Indicates an element with dynamic style\r\n   * The compiler pre-compiles static string styles into static objects\r\n   * + detects and hoists inline static objects\r\n   * e.g. `style=\"color: red\"` and `:style=\"{ color: 'red' }\"` both get hoisted\r\n   * as:\r\n   * ```js\r\n   * const style = { color: 'red' }\r\n   * render() { return e('div', { style }) }\r\n   * ```\r\n   */\r\n  STYLE = 1 << 2,\r\n\r\n  /**\r\n   * Indicates an element that has non-class/style dynamic props.\r\n   * Can also be on a component that has any dynamic props (includes\r\n   * class/style). when this flag is present, the vnode also has a dynamicProps\r\n   * array that contains the keys of the props that may change so the runtime\r\n   * can diff them faster (without having to worry about removed props)\r\n   */\r\n  PROPS = 1 << 3,\r\n\r\n  /**\r\n   * Indicates an element with props with dynamic keys. When keys change, a full\r\n   * diff is always needed to remove the old key. This flag is mutually\r\n   * exclusive with CLASS, STYLE and PROPS.\r\n   */\r\n  FULL_PROPS = 1 << 4,\r\n\r\n  /**\r\n   * Indicates an element that requires props hydration\r\n   * (but not necessarily patching)\r\n   * e.g. event listeners & v-bind with prop modifier\r\n   */\r\n  NEED_HYDRATION = 1 << 5,\r\n\r\n  /**\r\n   * Indicates a fragment whose children order doesn't change.\r\n   */\r\n  STABLE_FRAGMENT = 1 << 6,\r\n\r\n  /**\r\n   * Indicates a fragment with keyed or partially keyed children\r\n   */\r\n  KEYED_FRAGMENT = 1 << 7,\r\n\r\n  /**\r\n   * Indicates a fragment with unkeyed children.\r\n   */\r\n  UNKEYED_FRAGMENT = 1 << 8,\r\n\r\n  /**\r\n   * Indicates an element that only needs non-props patching, e.g. ref or\r\n   * directives (onVnodeXXX hooks). since every patched vnode checks for refs\r\n   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block\r\n   * will track it.\r\n   */\r\n  NEED_PATCH = 1 << 9,\r\n\r\n  /**\r\n   * Indicates a component with dynamic slots (e.g. slot that references a v-for\r\n   * iterated value, or dynamic slot names).\r\n   * Components with this flag are always force updated.\r\n   */\r\n  DYNAMIC_SLOTS = 1 << 10,\r\n\r\n  /**\r\n   * Indicates a fragment that was created only because the user has placed\r\n   * comments at the root level of a template. This is a dev-only flag since\r\n   * comments are stripped in production.\r\n   */\r\n  DEV_ROOT_FRAGMENT = 1 << 11,\r\n\r\n  /**\r\n   * SPECIAL FLAGS -------------------------------------------------------------\r\n   * Special flags are negative integers. They are never matched against using\r\n   * bitwise operators (bitwise matching should only happen in branches where\r\n   * patchFlag > 0), and are mutually exclusive. When checking for a special\r\n   * flag, simply check patchFlag === FLAG.\r\n   */\r\n\r\n  /**\r\n   * Indicates a hoisted static vnode. This is a hint for hydration to skip\r\n   * the entire sub tree since static content never needs to be updated.\r\n   */\r\n  HOISTED = -1,\r\n  /**\r\n   * A special flag that indicates that the diffing algorithm should bail out\r\n   * of optimized mode. For example, on block fragments created by renderSlot()\r\n   * when encountering non-compiler generated slots (i.e. manually written\r\n   * render functions, which should always be fully diffed)\r\n   * OR manually cloneVNodes\r\n   */\r\n  BAIL = -2\r\n}\r\n\r\n/**\r\n * dev only flag -> name mapping\r\n */\r\nexport const PatchFlagNames: Record<PatchFlags, string> = {\r\n  [PatchFlags.TEXT]: `TEXT`,\r\n  [PatchFlags.CLASS]: `CLASS`,\r\n  [PatchFlags.STYLE]: `STYLE`,\r\n  [PatchFlags.PROPS]: `PROPS`,\r\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\r\n  [PatchFlags.NEED_HYDRATION]: `NEED_HYDRATION`,\r\n  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,\r\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\r\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\r\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\r\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\r\n  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,\r\n  [PatchFlags.HOISTED]: `HOISTED`,\r\n  [PatchFlags.BAIL]: `BAIL`\r\n}\r\n", "export const enum SlotFlags {\r\n  /**\r\n   * Stable slots that only reference slot props or context state. The slot\r\n   * can fully capture its own dependencies so when passed down the parent won't\r\n   * need to force the child to update.\r\n   */\r\n  STABLE = 1,\r\n  /**\r\n   * Slots that reference scope variables (v-for or an outer slot prop), or\r\n   * has conditional structure (v-if, v-for). The parent will need to force\r\n   * the child to update because the slot does not fully capture its dependencies.\r\n   */\r\n  DYNAMIC = 2,\r\n  /**\r\n   * `<slot/>` being forwarded into a child component. Whether the parent needs\r\n   * to update the child is dependent on what kind of slots the parent itself\r\n   * received. This has to be refined at runtime, when the child's vnode\r\n   * is being created (in `normalizeChildren`)\r\n   */\r\n  FORWARDED = 3\r\n}\r\n\r\n/**\r\n * Dev only\r\n */\r\nexport const slotFlagsText = {\r\n  [SlotFlags.STABLE]: 'STABLE',\r\n  [SlotFlags.DYNAMIC]: 'DYNAMIC',\r\n  [SlotFlags.FORWARDED]: 'FORWARDED'\r\n}\r\n", "import { makeMap } from './makeMap'\r\n\r\nconst GLOBALS_ALLOWED =\r\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console'\r\n\r\nexport const isGloballyAllowed = /*#__PURE__*/ makeMap(GLOBALS_ALLOWED)\r\n\r\n/** @deprecated use `isGloballyAllowed` instead */\r\nexport const isGloballyWhitelisted = isGloballyAllowed\r\n", "const range: number = 2\r\n\r\nexport function generateCodeFrame(\r\n  source: string,\r\n  start = 0,\r\n  end = source.length\r\n): string {\r\n  // Split the content into individual lines but capture the newline sequence\r\n  // that separated each line. This is important because the actual sequence is\r\n  // needed to properly take into account the full line length for offset\r\n  // comparison\r\n  let lines = source.split(/(\\r?\\n)/)\r\n\r\n  // Separate the lines and newline sequences into separate arrays for easier referencing\r\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)\r\n  lines = lines.filter((_, idx) => idx % 2 === 0)\r\n\r\n  let count = 0\r\n  const res: string[] = []\r\n  for (let i = 0; i < lines.length; i++) {\r\n    count +=\r\n      lines[i].length +\r\n      ((newlineSequences[i] && newlineSequences[i].length) || 0)\r\n    if (count >= start) {\r\n      for (let j = i - range; j <= i + range || end > count; j++) {\r\n        if (j < 0 || j >= lines.length) continue\r\n        const line = j + 1\r\n        res.push(\r\n          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${\r\n            lines[j]\r\n          }`\r\n        )\r\n        const lineLength = lines[j].length\r\n        const newLineSeqLength =\r\n          (newlineSequences[j] && newlineSequences[j].length) || 0\r\n\r\n        if (j === i) {\r\n          // push underline\r\n          const pad = start - (count - (lineLength + newLineSeqLength))\r\n          const length = Math.max(\r\n            1,\r\n            end > count ? lineLength - pad : end - start\r\n          )\r\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\r\n        } else if (j > i) {\r\n          if (end > count) {\r\n            const length = Math.max(Math.min(end - count, lineLength), 1)\r\n            res.push(`   |  ` + '^'.repeat(length))\r\n          }\r\n\r\n          count += lineLength + newLineSeqLength\r\n        }\r\n      }\r\n      break\r\n    }\r\n  }\r\n  return res.join('\\n')\r\n}\r\n", "import { isArray, isString, isObject, hyphenate } from './general'\r\n\r\nexport type NormalizedStyle = Record<string, string | number>\r\n\r\nexport function normalizeStyle(\r\n  value: unknown\r\n): NormalizedStyle | string | undefined {\r\n  if (isArray(value)) {\r\n    const res: NormalizedStyle = {}\r\n    for (let i = 0; i < value.length; i++) {\r\n      const item = value[i]\r\n      const normalized = isString(item)\r\n        ? parseStringStyle(item)\r\n        : (normalizeStyle(item) as NormalizedStyle)\r\n      if (normalized) {\r\n        for (const key in normalized) {\r\n          res[key] = normalized[key]\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  } else if (isString(value) || isObject(value)) {\r\n    return value\r\n  }\r\n}\r\n\r\nconst listDelimiterRE = /;(?![^(]*\\))/g\r\nconst propertyDelimiterRE = /:([^]+)/\r\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g\r\n\r\nexport function parseStringStyle(cssText: string): NormalizedStyle {\r\n  const ret: NormalizedStyle = {}\r\n  cssText\r\n    .replace(styleCommentRE, '')\r\n    .split(listDelimiterRE)\r\n    .forEach(item => {\r\n      if (item) {\r\n        const tmp = item.split(propertyDelimiterRE)\r\n        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\r\n      }\r\n    })\r\n  return ret\r\n}\r\n\r\nexport function stringifyStyle(\r\n  styles: NormalizedStyle | string | undefined\r\n): string {\r\n  let ret = ''\r\n  if (!styles || isString(styles)) {\r\n    return ret\r\n  }\r\n  for (const key in styles) {\r\n    const value = styles[key]\r\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\r\n    if (isString(value) || typeof value === 'number') {\r\n      // only render valid values\r\n      ret += `${normalizedKey}:${value};`\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function normalizeClass(value: unknown): string {\r\n  let res = ''\r\n  if (isString(value)) {\r\n    res = value\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      const normalized = normalizeClass(value[i])\r\n      if (normalized) {\r\n        res += normalized + ' '\r\n      }\r\n    }\r\n  } else if (isObject(value)) {\r\n    for (const name in value) {\r\n      if (value[name]) {\r\n        res += name + ' '\r\n      }\r\n    }\r\n  }\r\n  return res.trim()\r\n}\r\n\r\nexport function normalizeProps(props: Record<string, any> | null) {\r\n  if (!props) return null\r\n  let { class: klass, style } = props\r\n  if (klass && !isString(klass)) {\r\n    props.class = normalizeClass(klass)\r\n  }\r\n  if (style) {\r\n    props.style = normalizeStyle(style)\r\n  }\r\n  return props\r\n}\r\n", "// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// must be extracted in shared to avoid creating a dependency between the two.\r\nimport { makeMap } from './makeMap'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS =\r\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n  'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\r\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\r\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n  'option,output,progress,select,textarea,details,dialog,menu,' +\r\n  'summary,template,blockquote,iframe,tfoot'\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS =\r\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n  'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n  'text,textPath,title,tspan,unknown,use,view'\r\n\r\nconst VOID_TAGS =\r\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\r\n\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\r\n/**\r\n * Compiler only.\r\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\r\n */\r\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\r\n", "import { makeMap } from './makeMap'\r\n\r\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`\r\nexport const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)\r\n\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nexport const isBooleanAttr = /*#__PURE__*/ makeMap(\r\n  specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `inert,loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`\r\n)\r\n\r\n/**\r\n * Boolean attributes should be included if the value is truthy or ''.\r\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\r\n */\r\nexport function includeBooleanAttr(value: unknown): boolean {\r\n  return !!value || value === ''\r\n}\r\n\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/\r\nconst attrValidationCache: Record<string, boolean> = {}\r\n\r\nexport function isSSRSafeAttrName(name: string): boolean {\r\n  if (attrValidationCache.hasOwnProperty(name)) {\r\n    return attrValidationCache[name]\r\n  }\r\n  const isUnsafe = unsafeAttrCharRE.test(name)\r\n  if (isUnsafe) {\r\n    console.error(`unsafe attribute name: ${name}`)\r\n  }\r\n  return (attrValidationCache[name] = !isUnsafe)\r\n}\r\n\r\nexport const propsToAttrMap: Record<string, string | undefined> = {\r\n  acceptCharset: 'accept-charset',\r\n  className: 'class',\r\n  htmlFor: 'for',\r\n  httpEquiv: 'http-equiv'\r\n}\r\n\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nexport const isKnownHtmlAttr = /*#__PURE__*/ makeMap(\r\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`\r\n)\r\n\r\n/**\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\r\n */\r\nexport const isKnownSvgAttr = /*#__PURE__*/ makeMap(\r\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\r\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\r\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\r\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\r\n    `color-interpolation-filters,color-profile,color-rendering,` +\r\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\r\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\r\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\r\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\r\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\r\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\r\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\r\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\r\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\r\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\r\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\r\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\r\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\r\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\r\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\r\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\r\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\r\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\r\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\r\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\r\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\r\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\r\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\r\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\r\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\r\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\r\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\r\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\r\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\r\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\r\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\r\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,` +\r\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\r\n)\r\n", "import { isArray, isDate, isObject, isSymbol } from './general'\r\n\r\nfunction looseCompareArrays(a: any[], b: any[]) {\r\n  if (a.length !== b.length) return false\r\n  let equal = true\r\n  for (let i = 0; equal && i < a.length; i++) {\r\n    equal = looseEqual(a[i], b[i])\r\n  }\r\n  return equal\r\n}\r\n\r\nexport function looseEqual(a: any, b: any): boolean {\r\n  if (a === b) return true\r\n  let aValidType = isDate(a)\r\n  let bValidType = isDate(b)\r\n  if (aValidType || bValidType) {\r\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false\r\n  }\r\n  aValidType = isSymbol(a)\r\n  bValidType = isSymbol(b)\r\n  if (aValidType || bValidType) {\r\n    return a === b\r\n  }\r\n  aValidType = isArray(a)\r\n  bValidType = isArray(b)\r\n  if (aValidType || bValidType) {\r\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false\r\n  }\r\n  aValidType = isObject(a)\r\n  bValidType = isObject(b)\r\n  if (aValidType || bValidType) {\r\n    /* istanbul ignore if: this if will probably never be called */\r\n    if (!aValidType || !bValidType) {\r\n      return false\r\n    }\r\n    const aKeysCount = Object.keys(a).length\r\n    const bKeysCount = Object.keys(b).length\r\n    if (aKeysCount !== bKeysCount) {\r\n      return false\r\n    }\r\n    for (const key in a) {\r\n      const aHasKey = a.hasOwnProperty(key)\r\n      const bHasKey = b.hasOwnProperty(key)\r\n      if (\r\n        (aHasKey && !bHasKey) ||\r\n        (!aHasKey && bHasKey) ||\r\n        !looseEqual(a[key], b[key])\r\n      ) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  return String(a) === String(b)\r\n}\r\n\r\nexport function looseIndexOf(arr: any[], val: any): number {\r\n  return arr.findIndex(item => looseEqual(item, val))\r\n}\r\n", "import {\r\n  isArray,\r\n  isMap,\r\n  isObject,\r\n  isFunction,\r\n  isPlainObject,\r\n  isSet,\r\n  objectToString,\r\n  isString,\r\n  isSymbol\r\n} from './general'\r\n\r\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nexport const toDisplayString = (val: unknown): string => {\r\n  return isString(val)\r\n    ? val\r\n    : val == null\r\n      ? ''\r\n      : isArray(val) ||\r\n          (isObject(val) &&\r\n            (val.toString === objectToString || !isFunction(val.toString)))\r\n        ? JSON.stringify(val, replacer, 2)\r\n        : String(val)\r\n}\r\n\r\nconst replacer = (_key: string, val: any): any => {\r\n  // can't use isRef here since @vue/shared has no deps\r\n  if (val && val.__v_isRef) {\r\n    return replacer(_key, val.value)\r\n  } else if (isMap(val)) {\r\n    return {\r\n      [`Map(${val.size})`]: [...val.entries()].reduce(\r\n        (entries, [key, val], i) => {\r\n          entries[stringifySymbol(key, i) + ' =>'] = val\r\n          return entries\r\n        },\r\n        {} as Record<string, any>\r\n      )\r\n    }\r\n  } else if (isSet(val)) {\r\n    return {\r\n      [`Set(${val.size})`]: [...val.values()].map(v => stringifySymbol(v))\r\n    }\r\n  } else if (isSymbol(val)) {\r\n    return stringifySymbol(val)\r\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n    // native elements\r\n    return String(val)\r\n  }\r\n  return val\r\n}\r\n\r\nconst stringifySymbol = (v: unknown, i: number | string = ''): any =>\r\n  isSymbol(v) ? `Symbol(${v.description ?? i})` : v\r\n", "export function warn(msg: string, ...args: any[]) {\r\n  console.warn(`[Vue warn] ${msg}`, ...args)\r\n}\r\n", "import { ReactiveEffect } from './effect'\r\nimport { warn } from './warning'\r\n\r\nlet activeEffectScope: EffectScope | undefined\r\n\r\nexport class EffectScope {\r\n  /**\r\n   * @internal\r\n   */\r\n  private _active = true\r\n  /**\r\n   * @internal\r\n   */\r\n  effects: ReactiveEffect[] = []\r\n  /**\r\n   * @internal\r\n   */\r\n  cleanups: (() => void)[] = []\r\n\r\n  /**\r\n   * only assigned by undetached scope\r\n   * @internal\r\n   */\r\n  parent: EffectScope | undefined\r\n  /**\r\n   * record undetached scopes\r\n   * @internal\r\n   */\r\n  scopes: EffectScope[] | undefined\r\n  /**\r\n   * track a child scope's index in its parent's scopes array for optimized\r\n   * removal\r\n   * @internal\r\n   */\r\n  private index: number | undefined\r\n\r\n  constructor(public detached = false) {\r\n    this.parent = activeEffectScope\r\n    if (!detached && activeEffectScope) {\r\n      this.index =\r\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\r\n          this\r\n        ) - 1\r\n    }\r\n  }\r\n\r\n  get active() {\r\n    return this._active\r\n  }\r\n\r\n  run<T>(fn: () => T): T | undefined {\r\n    if (this._active) {\r\n      const currentEffectScope = activeEffectScope\r\n      try {\r\n        activeEffectScope = this\r\n        return fn()\r\n      } finally {\r\n        activeEffectScope = currentEffectScope\r\n      }\r\n    } else if (__DEV__) {\r\n      warn(`cannot run an inactive effect scope.`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  on() {\r\n    activeEffectScope = this\r\n  }\r\n\r\n  /**\r\n   * This should only be called on non-detached scopes\r\n   * @internal\r\n   */\r\n  off() {\r\n    activeEffectScope = this.parent\r\n  }\r\n\r\n  stop(fromParent?: boolean) {\r\n    if (this._active) {\r\n      let i, l\r\n      for (i = 0, l = this.effects.length; i < l; i++) {\r\n        this.effects[i].stop()\r\n      }\r\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n        this.cleanups[i]()\r\n      }\r\n      if (this.scopes) {\r\n        for (i = 0, l = this.scopes.length; i < l; i++) {\r\n          this.scopes[i].stop(true)\r\n        }\r\n      }\r\n      // nested scope, dereference from parent to avoid memory leaks\r\n      if (!this.detached && this.parent && !fromParent) {\r\n        // optimized O(1) removal\r\n        const last = this.parent.scopes!.pop()\r\n        if (last && last !== this) {\r\n          this.parent.scopes![this.index!] = last\r\n          last.index = this.index!\r\n        }\r\n      }\r\n      this.parent = undefined\r\n      this._active = false\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creates an effect scope object which can capture the reactive effects (i.e.\r\n * computed and watchers) created within it so that these effects can be\r\n * disposed together. For detailed use cases of this API, please consult its\r\n * corresponding {@link https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md | RFC}.\r\n *\r\n * @param detached - Can be used to create a \"detached\" effect scope.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#effectscope}\r\n */\r\nexport function effectScope(detached?: boolean) {\r\n  return new EffectScope(detached)\r\n}\r\n\r\nexport function recordEffectScope(\r\n  effect: ReactiveEffect,\r\n  scope: EffectScope | undefined = activeEffectScope\r\n) {\r\n  if (scope && scope.active) {\r\n    scope.effects.push(effect)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the current active effect scope if there is one.\r\n *\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#getcurrentscope}\r\n */\r\nexport function getCurrentScope() {\r\n  return activeEffectScope\r\n}\r\n\r\n/**\r\n * Registers a dispose callback on the current active effect scope. The\r\n * callback will be invoked when the associated effect scope is stopped.\r\n *\r\n * @param fn - The callback function to attach to the scope's cleanup.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#onscopedispose}\r\n */\r\nexport function onScopeDispose(fn: () => void) {\r\n  if (activeEffectScope) {\r\n    activeEffectScope.cleanups.push(fn)\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `onScopeDispose() is called when there is no active effect scope` +\r\n        ` to be associated with.`\r\n    )\r\n  }\r\n}\r\n", "import { ReactiveEffect, trackOpBit } from './effect'\r\n\r\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\r\n\r\n/**\r\n * wasTracked and newTracked maintain the status for several levels of effect\r\n * tracking recursion. One bit per level is used to define whether the dependency\r\n * was/is tracked.\r\n */\r\ntype TrackedMarkers = {\r\n  /**\r\n   * wasTracked\r\n   */\r\n  w: number\r\n  /**\r\n   * newTracked\r\n   */\r\n  n: number\r\n}\r\n\r\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\r\n  const dep = new Set<ReactiveEffect>(effects) as Dep\r\n  dep.w = 0\r\n  dep.n = 0\r\n  return dep\r\n}\r\n\r\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\r\n\r\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\r\n\r\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].w |= trackOpBit // set was tracked\r\n    }\r\n  }\r\n}\r\n\r\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    let ptr = 0\r\n    for (let i = 0; i < deps.length; i++) {\r\n      const dep = deps[i]\r\n      if (wasTracked(dep) && !newTracked(dep)) {\r\n        dep.delete(effect)\r\n      } else {\r\n        deps[ptr++] = dep\r\n      }\r\n      // clear bits\r\n      dep.w &= ~trackOpBit\r\n      dep.n &= ~trackOpBit\r\n    }\r\n    deps.length = ptr\r\n  }\r\n}\r\n", "import { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { extend, isArray, isIntegerKey, isMap, isSymbol } from '@vue/shared'\r\nimport { EffectScope, recordEffectScope } from './effectScope'\r\nimport {\r\n  createDep,\r\n  Dep,\r\n  finalizeDepMarkers,\r\n  initDepMarkers,\r\n  newTracked,\r\n  wasTracked\r\n} from './dep'\r\nimport { ComputedRefImpl } from './computed'\r\n\r\n// The main WeakMap that stores {target -> key -> dep} connections.\r\n// Conceptually, it's easier to think of a dependency as a Dep class\r\n// which maintains a Set of subscribers, but we simply store them as\r\n// raw Sets to reduce memory overhead.\r\ntype KeyToDepMap = Map<any, Dep>\r\nconst targetMap = new WeakMap<object, KeyToDepMap>()\r\n\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0\r\n\r\nexport let trackOpBit = 1\r\n\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30\r\n\r\nexport type EffectScheduler = (...args: any[]) => any\r\n\r\nexport type DebuggerEvent = {\r\n  effect: ReactiveEffect\r\n} & DebuggerEventExtraInfo\r\n\r\nexport type DebuggerEventExtraInfo = {\r\n  target: object\r\n  type: TrackOpTypes | TriggerOpTypes\r\n  key: any\r\n  newValue?: any\r\n  oldValue?: any\r\n  oldTarget?: Map<any, any> | Set<any>\r\n}\r\n\r\nexport let activeEffect: ReactiveEffect | undefined\r\n\r\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\r\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\r\n\r\nexport class ReactiveEffect<T = any> {\r\n  active = true\r\n  deps: Dep[] = []\r\n  parent: ReactiveEffect | undefined = undefined\r\n\r\n  /**\r\n   * Can be attached after creation\r\n   * @internal\r\n   */\r\n  computed?: ComputedRefImpl<T>\r\n  /**\r\n   * @internal\r\n   */\r\n  allowRecurse?: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  private deferStop?: boolean\r\n\r\n  onStop?: () => void\r\n  // dev only\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  // dev only\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n\r\n  constructor(\r\n    public fn: () => T,\r\n    public scheduler: EffectScheduler | null = null,\r\n    scope?: EffectScope\r\n  ) {\r\n    recordEffectScope(this, scope)\r\n  }\r\n\r\n  run() {\r\n    if (!this.active) {\r\n      return this.fn()\r\n    }\r\n    let parent: ReactiveEffect | undefined = activeEffect\r\n    let lastShouldTrack = shouldTrack\r\n    while (parent) {\r\n      if (parent === this) {\r\n        return\r\n      }\r\n      parent = parent.parent\r\n    }\r\n    try {\r\n      this.parent = activeEffect\r\n      activeEffect = this\r\n      shouldTrack = true\r\n\r\n      trackOpBit = 1 << ++effectTrackDepth\r\n\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        initDepMarkers(this)\r\n      } else {\r\n        cleanupEffect(this)\r\n      }\r\n      return this.fn()\r\n    } finally {\r\n      if (effectTrackDepth <= maxMarkerBits) {\r\n        finalizeDepMarkers(this)\r\n      }\r\n\r\n      trackOpBit = 1 << --effectTrackDepth\r\n\r\n      activeEffect = this.parent\r\n      shouldTrack = lastShouldTrack\r\n      this.parent = undefined\r\n\r\n      if (this.deferStop) {\r\n        this.stop()\r\n      }\r\n    }\r\n  }\r\n\r\n  stop() {\r\n    // stopped while running itself - defer the cleanup\r\n    if (activeEffect === this) {\r\n      this.deferStop = true\r\n    } else if (this.active) {\r\n      cleanupEffect(this)\r\n      if (this.onStop) {\r\n        this.onStop()\r\n      }\r\n      this.active = false\r\n    }\r\n  }\r\n}\r\n\r\nfunction cleanupEffect(effect: ReactiveEffect) {\r\n  const { deps } = effect\r\n  if (deps.length) {\r\n    for (let i = 0; i < deps.length; i++) {\r\n      deps[i].delete(effect)\r\n    }\r\n    deps.length = 0\r\n  }\r\n}\r\n\r\nexport interface DebuggerOptions {\r\n  onTrack?: (event: DebuggerEvent) => void\r\n  onTrigger?: (event: DebuggerEvent) => void\r\n}\r\n\r\nexport interface ReactiveEffectOptions extends DebuggerOptions {\r\n  lazy?: boolean\r\n  scheduler?: EffectScheduler\r\n  scope?: EffectScope\r\n  allowRecurse?: boolean\r\n  onStop?: () => void\r\n}\r\n\r\nexport interface ReactiveEffectRunner<T = any> {\r\n  (): T\r\n  effect: ReactiveEffect\r\n}\r\n\r\n/**\r\n * Registers the given function to track reactive updates.\r\n *\r\n * The given function will be run once immediately. Every time any reactive\r\n * property that's accessed within it gets updated, the function will run again.\r\n *\r\n * @param fn - The function that will track reactive updates.\r\n * @param options - Allows to control the effect's behaviour.\r\n * @returns A runner that can be used to control the effect after creation.\r\n */\r\nexport function effect<T = any>(\r\n  fn: () => T,\r\n  options?: ReactiveEffectOptions\r\n): ReactiveEffectRunner {\r\n  if ((fn as ReactiveEffectRunner).effect instanceof ReactiveEffect) {\r\n    fn = (fn as ReactiveEffectRunner).effect.fn\r\n  }\r\n\r\n  const _effect = new ReactiveEffect(fn)\r\n  if (options) {\r\n    extend(_effect, options)\r\n    if (options.scope) recordEffectScope(_effect, options.scope)\r\n  }\r\n  if (!options || !options.lazy) {\r\n    _effect.run()\r\n  }\r\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\r\n  runner.effect = _effect\r\n  return runner\r\n}\r\n\r\n/**\r\n * Stops the effect associated with the given runner.\r\n *\r\n * @param runner - Association with the effect to stop tracking.\r\n */\r\nexport function stop(runner: ReactiveEffectRunner) {\r\n  runner.effect.stop()\r\n}\r\n\r\nexport let shouldTrack = true\r\nconst trackStack: boolean[] = []\r\n\r\n/**\r\n * Temporarily pauses tracking.\r\n */\r\nexport function pauseTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = false\r\n}\r\n\r\n/**\r\n * Re-enables effect tracking (if it was paused).\r\n */\r\nexport function enableTracking() {\r\n  trackStack.push(shouldTrack)\r\n  shouldTrack = true\r\n}\r\n\r\n/**\r\n * Resets the previous global effect tracking state.\r\n */\r\nexport function resetTracking() {\r\n  const last = trackStack.pop()\r\n  shouldTrack = last === undefined ? true : last\r\n}\r\n\r\n/**\r\n * Tracks access to a reactive property.\r\n *\r\n * This will check which effect is running at the moment and record it as dep\r\n * which records all effects that depend on the reactive property.\r\n *\r\n * @param target - Object holding the reactive property.\r\n * @param type - Defines the type of access to the reactive property.\r\n * @param key - Identifier of the reactive property to track.\r\n */\r\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\r\n  if (shouldTrack && activeEffect) {\r\n    let depsMap = targetMap.get(target)\r\n    if (!depsMap) {\r\n      targetMap.set(target, (depsMap = new Map()))\r\n    }\r\n    let dep = depsMap.get(key)\r\n    if (!dep) {\r\n      depsMap.set(key, (dep = createDep()))\r\n    }\r\n\r\n    const eventInfo = __DEV__\r\n      ? { effect: activeEffect, target, type, key }\r\n      : undefined\r\n\r\n    trackEffects(dep, eventInfo)\r\n  }\r\n}\r\n\r\nexport function trackEffects(\r\n  dep: Dep,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  let shouldTrack = false\r\n  if (effectTrackDepth <= maxMarkerBits) {\r\n    if (!newTracked(dep)) {\r\n      dep.n |= trackOpBit // set newly tracked\r\n      shouldTrack = !wasTracked(dep)\r\n    }\r\n  } else {\r\n    // Full cleanup mode.\r\n    shouldTrack = !dep.has(activeEffect!)\r\n  }\r\n\r\n  if (shouldTrack) {\r\n    dep.add(activeEffect!)\r\n    activeEffect!.deps.push(dep)\r\n    if (__DEV__ && activeEffect!.onTrack) {\r\n      activeEffect!.onTrack(\r\n        extend(\r\n          {\r\n            effect: activeEffect!\r\n          },\r\n          debuggerEventExtraInfo!\r\n        )\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Finds all deps associated with the target (or a specific property) and\r\n * triggers the effects stored within.\r\n *\r\n * @param target - The reactive object.\r\n * @param type - Defines the type of the operation that needs to trigger effects.\r\n * @param key - Can be used to target a specific reactive property in the target object.\r\n */\r\nexport function trigger(\r\n  target: object,\r\n  type: TriggerOpTypes,\r\n  key?: unknown,\r\n  newValue?: unknown,\r\n  oldValue?: unknown,\r\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\r\n) {\r\n  const depsMap = targetMap.get(target)\r\n  if (!depsMap) {\r\n    // never been tracked\r\n    return\r\n  }\r\n\r\n  let deps: (Dep | undefined)[] = []\r\n  if (type === TriggerOpTypes.CLEAR) {\r\n    // collection being cleared\r\n    // trigger all effects for target\r\n    deps = [...depsMap.values()]\r\n  } else if (key === 'length' && isArray(target)) {\r\n    const newLength = Number(newValue)\r\n    depsMap.forEach((dep, key) => {\r\n      if (key === 'length' || (!isSymbol(key) && key >= newLength)) {\r\n        deps.push(dep)\r\n      }\r\n    })\r\n  } else {\r\n    // schedule runs for SET | ADD | DELETE\r\n    if (key !== void 0) {\r\n      deps.push(depsMap.get(key))\r\n    }\r\n\r\n    // also run for iteration key on ADD | DELETE | Map.SET\r\n    switch (type) {\r\n      case TriggerOpTypes.ADD:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        } else if (isIntegerKey(key)) {\r\n          // new index added to array -> length changes\r\n          deps.push(depsMap.get('length'))\r\n        }\r\n        break\r\n      case TriggerOpTypes.DELETE:\r\n        if (!isArray(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n          if (isMap(target)) {\r\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\r\n          }\r\n        }\r\n        break\r\n      case TriggerOpTypes.SET:\r\n        if (isMap(target)) {\r\n          deps.push(depsMap.get(ITERATE_KEY))\r\n        }\r\n        break\r\n    }\r\n  }\r\n\r\n  const eventInfo = __DEV__\r\n    ? { target, type, key, newValue, oldValue, oldTarget }\r\n    : undefined\r\n\r\n  if (deps.length === 1) {\r\n    if (deps[0]) {\r\n      if (__DEV__) {\r\n        triggerEffects(deps[0], eventInfo)\r\n      } else {\r\n        triggerEffects(deps[0])\r\n      }\r\n    }\r\n  } else {\r\n    const effects: ReactiveEffect[] = []\r\n    for (const dep of deps) {\r\n      if (dep) {\r\n        effects.push(...dep)\r\n      }\r\n    }\r\n    if (__DEV__) {\r\n      triggerEffects(createDep(effects), eventInfo)\r\n    } else {\r\n      triggerEffects(createDep(effects))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerEffects(\r\n  dep: Dep | ReactiveEffect[],\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  // spread into array for stabilization\r\n  const effects = isArray(dep) ? dep : [...dep]\r\n  for (const effect of effects) {\r\n    if (effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n  for (const effect of effects) {\r\n    if (!effect.computed) {\r\n      triggerEffect(effect, debuggerEventExtraInfo)\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerEffect(\r\n  effect: ReactiveEffect,\r\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\r\n) {\r\n  if (effect !== activeEffect || effect.allowRecurse) {\r\n    if (__DEV__ && effect.onTrigger) {\r\n      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\r\n    }\r\n    if (effect.scheduler) {\r\n      effect.scheduler()\r\n    } else {\r\n      effect.run()\r\n    }\r\n  }\r\n}\r\n\r\nexport function getDepFromReactive(object: any, key: string | number | symbol) {\r\n  return targetMap.get(object)?.get(key)\r\n}\r\n", "import {\r\n  reactive,\r\n  readonly,\r\n  toRaw,\r\n  ReactiveFlags,\r\n  Target,\r\n  readonlyMap,\r\n  reactiveMap,\r\n  shallowReactiveMap,\r\n  shallowReadonlyMap,\r\n  isReadonly,\r\n  isShallow\r\n} from './reactive'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport {\r\n  track,\r\n  trigger,\r\n  ITERATE_KEY,\r\n  pauseTracking,\r\n  resetTracking\r\n} from './effect'\r\nimport {\r\n  isObject,\r\n  hasOwn,\r\n  isSymbol,\r\n  hasChanged,\r\n  isArray,\r\n  isIntegerKey,\r\n  makeMap\r\n} from '@vue/shared'\r\nimport { isRef } from './ref'\r\nimport { warn } from './warning'\r\n\r\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\r\n\r\nconst builtInSymbols = new Set(\r\n  /*#__PURE__*/\r\n  Object.getOwnPropertyNames(Symbol)\r\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\r\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\r\n    // function\r\n    .filter(key => key !== 'arguments' && key !== 'caller')\r\n    .map(key => (Symbol as any)[key])\r\n    .filter(isSymbol)\r\n)\r\n\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\r\n\r\nfunction createArrayInstrumentations() {\r\n  const instrumentations: Record<string, Function> = {}\r\n  // instrument identity-sensitive Array methods to account for possible reactive\r\n  // values\r\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      const arr = toRaw(this) as any\r\n      for (let i = 0, l = this.length; i < l; i++) {\r\n        track(arr, TrackOpTypes.GET, i + '')\r\n      }\r\n      // we run the method using the original args first (which may be reactive)\r\n      const res = arr[key](...args)\r\n      if (res === -1 || res === false) {\r\n        // if that didn't work, run it again using raw values.\r\n        return arr[key](...args.map(toRaw))\r\n      } else {\r\n        return res\r\n      }\r\n    }\r\n  })\r\n  // instrument length-altering mutation methods to avoid length being tracked\r\n  // which leads to infinite loops in some cases (#2137)\r\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\r\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\r\n      pauseTracking()\r\n      const res = (toRaw(this) as any)[key].apply(this, args)\r\n      resetTracking()\r\n      return res\r\n    }\r\n  })\r\n  return instrumentations\r\n}\r\n\r\nfunction hasOwnProperty(this: object, key: string) {\r\n  const obj = toRaw(this)\r\n  track(obj, TrackOpTypes.HAS, key)\r\n  return obj.hasOwnProperty(key)\r\n}\r\n\r\nclass BaseReactiveHandler implements ProxyHandler<Target> {\r\n  constructor(\r\n    protected readonly _isReadonly = false,\r\n    protected readonly _shallow = false\r\n  ) {}\r\n\r\n  get(target: Target, key: string | symbol, receiver: object) {\r\n    const isReadonly = this._isReadonly,\r\n      shallow = this._shallow\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\r\n      return shallow\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      if (\r\n        receiver ===\r\n          (isReadonly\r\n            ? shallow\r\n              ? shallowReadonlyMap\r\n              : readonlyMap\r\n            : shallow\r\n              ? shallowReactiveMap\r\n              : reactiveMap\r\n          ).get(target) ||\r\n        // receiver is not the reactive proxy, but has the same prototype\r\n        // this means the reciever is a user proxy of the reactive proxy\r\n        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)\r\n      ) {\r\n        return target\r\n      }\r\n      // early return undefined\r\n      return\r\n    }\r\n\r\n    const targetIsArray = isArray(target)\r\n\r\n    if (!isReadonly) {\r\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n        return Reflect.get(arrayInstrumentations, key, receiver)\r\n      }\r\n      if (key === 'hasOwnProperty') {\r\n        return hasOwnProperty\r\n      }\r\n    }\r\n\r\n    const res = Reflect.get(target, key, receiver)\r\n\r\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n      return res\r\n    }\r\n\r\n    if (!isReadonly) {\r\n      track(target, TrackOpTypes.GET, key)\r\n    }\r\n\r\n    if (shallow) {\r\n      return res\r\n    }\r\n\r\n    if (isRef(res)) {\r\n      // ref unwrapping - skip unwrap for Array + integer key.\r\n      return targetIsArray && isIntegerKey(key) ? res : res.value\r\n    }\r\n\r\n    if (isObject(res)) {\r\n      // Convert returned value into a proxy as well. we do the isObject check\r\n      // here to avoid invalid value warning. Also need to lazy access readonly\r\n      // and reactive here to avoid circular dependency.\r\n      return isReadonly ? readonly(res) : reactive(res)\r\n    }\r\n\r\n    return res\r\n  }\r\n}\r\n\r\nclass MutableReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(false, shallow)\r\n  }\r\n\r\n  set(\r\n    target: object,\r\n    key: string | symbol,\r\n    value: unknown,\r\n    receiver: object\r\n  ): boolean {\r\n    let oldValue = (target as any)[key]\r\n    if (!this._shallow) {\r\n      const isOldValueReadonly = isReadonly(oldValue)\r\n      if (!isShallow(value) && !isReadonly(value)) {\r\n        oldValue = toRaw(oldValue)\r\n        value = toRaw(value)\r\n      }\r\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n        if (isOldValueReadonly) {\r\n          return false\r\n        } else {\r\n          oldValue.value = value\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // in shallow mode, objects are set as-is regardless of reactive or not\r\n    }\r\n\r\n    const hadKey =\r\n      isArray(target) && isIntegerKey(key)\r\n        ? Number(key) < target.length\r\n        : hasOwn(target, key)\r\n    const result = Reflect.set(target, key, value, receiver)\r\n    // don't trigger if target is something up in the prototype chain of original\r\n    if (target === toRaw(receiver)) {\r\n      if (!hadKey) {\r\n        trigger(target, TriggerOpTypes.ADD, key, value)\r\n      } else if (hasChanged(value, oldValue)) {\r\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  deleteProperty(target: object, key: string | symbol): boolean {\r\n    const hadKey = hasOwn(target, key)\r\n    const oldValue = (target as any)[key]\r\n    const result = Reflect.deleteProperty(target, key)\r\n    if (result && hadKey) {\r\n      trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n    }\r\n    return result\r\n  }\r\n\r\n  has(target: object, key: string | symbol): boolean {\r\n    const result = Reflect.has(target, key)\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n      track(target, TrackOpTypes.HAS, key)\r\n    }\r\n    return result\r\n  }\r\n  ownKeys(target: object): (string | symbol)[] {\r\n    track(\r\n      target,\r\n      TrackOpTypes.ITERATE,\r\n      isArray(target) ? 'length' : ITERATE_KEY\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\r\n  constructor(shallow = false) {\r\n    super(true, shallow)\r\n  }\r\n\r\n  set(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n\r\n  deleteProperty(target: object, key: string | symbol) {\r\n    if (__DEV__) {\r\n      warn(\r\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\r\n        target\r\n      )\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nexport const mutableHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new MutableReactiveHandler()\r\n\r\nexport const readonlyHandlers: ProxyHandler<object> =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler()\r\n\r\nexport const shallowReactiveHandlers = /*#__PURE__*/ new MutableReactiveHandler(\r\n  true\r\n)\r\n\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nexport const shallowReadonlyHandlers =\r\n  /*#__PURE__*/ new ReadonlyReactiveHandler(true)\r\n", "import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\r\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\r\n\r\ntype CollectionTypes = IterableCollections | WeakCollections\r\n\r\ntype IterableCollections = Map<any, any> | Set<any>\r\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\r\ntype MapTypes = Map<any, any> | WeakMap<any, any>\r\ntype SetTypes = Set<any> | WeakSet<any>\r\n\r\nconst toShallow = <T extends unknown>(value: T): T => value\r\n\r\nconst getProto = <T extends CollectionTypes>(v: T): any =>\r\n  Reflect.getPrototypeOf(v)\r\n\r\nfunction get(\r\n  target: MapTypes,\r\n  key: unknown,\r\n  isReadonly = false,\r\n  isShallow = false\r\n) {\r\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n  // of the value\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      track(rawTarget, TrackOpTypes.GET, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.GET, rawKey)\r\n  }\r\n  const { has } = getProto(rawTarget)\r\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n  if (has.call(rawTarget, key)) {\r\n    return wrap(target.get(key))\r\n  } else if (has.call(rawTarget, rawKey)) {\r\n    return wrap(target.get(rawKey))\r\n  } else if (target !== rawTarget) {\r\n    // #3602 readonly(reactive(Map))\r\n    // ensure that the nested reactive `Map` can do tracking for itself\r\n    target.get(key)\r\n  }\r\n}\r\n\r\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\r\n  const target = (this as any)[ReactiveFlags.RAW]\r\n  const rawTarget = toRaw(target)\r\n  const rawKey = toRaw(key)\r\n  if (!isReadonly) {\r\n    if (hasChanged(key, rawKey)) {\r\n      track(rawTarget, TrackOpTypes.HAS, key)\r\n    }\r\n    track(rawTarget, TrackOpTypes.HAS, rawKey)\r\n  }\r\n  return key === rawKey\r\n    ? target.has(key)\r\n    : target.has(key) || target.has(rawKey)\r\n}\r\n\r\nfunction size(target: IterableCollections, isReadonly = false) {\r\n  target = (target as any)[ReactiveFlags.RAW]\r\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\r\n  return Reflect.get(target, 'size', target)\r\n}\r\n\r\nfunction add(this: SetTypes, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const proto = getProto(target)\r\n  const hadKey = proto.has.call(target, value)\r\n  if (!hadKey) {\r\n    target.add(value)\r\n    trigger(target, TriggerOpTypes.ADD, value, value)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction set(this: MapTypes, key: unknown, value: unknown) {\r\n  value = toRaw(value)\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get.call(target, key)\r\n  target.set(key, value)\r\n  if (!hadKey) {\r\n    trigger(target, TriggerOpTypes.ADD, key, value)\r\n  } else if (hasChanged(value, oldValue)) {\r\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\r\n  }\r\n  return this\r\n}\r\n\r\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\r\n  const target = toRaw(this)\r\n  const { has, get } = getProto(target)\r\n  let hadKey = has.call(target, key)\r\n  if (!hadKey) {\r\n    key = toRaw(key)\r\n    hadKey = has.call(target, key)\r\n  } else if (__DEV__) {\r\n    checkIdentityKeys(target, has, key)\r\n  }\r\n\r\n  const oldValue = get ? get.call(target, key) : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.delete(key)\r\n  if (hadKey) {\r\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction clear(this: IterableCollections) {\r\n  const target = toRaw(this)\r\n  const hadItems = target.size !== 0\r\n  const oldTarget = __DEV__\r\n    ? isMap(target)\r\n      ? new Map(target)\r\n      : new Set(target)\r\n    : undefined\r\n  // forward the operation before queueing reactions\r\n  const result = target.clear()\r\n  if (hadItems) {\r\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\r\n  }\r\n  return result\r\n}\r\n\r\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\r\n  return function forEach(\r\n    this: IterableCollections,\r\n    callback: Function,\r\n    thisArg?: unknown\r\n  ) {\r\n    const observed = this as any\r\n    const target = observed[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\r\n    return target.forEach((value: unknown, key: unknown) => {\r\n      // important: make sure the callback is\r\n      // 1. invoked with the reactive map as `this` and 3rd arg\r\n      // 2. the value received should be a corresponding reactive/readonly.\r\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\r\n    })\r\n  }\r\n}\r\n\r\ninterface Iterable {\r\n  [Symbol.iterator](): Iterator\r\n}\r\n\r\ninterface Iterator {\r\n  next(value?: any): IterationResult\r\n}\r\n\r\ninterface IterationResult {\r\n  value: any\r\n  done: boolean\r\n}\r\n\r\nfunction createIterableMethod(\r\n  method: string | symbol,\r\n  isReadonly: boolean,\r\n  isShallow: boolean\r\n) {\r\n  return function (\r\n    this: IterableCollections,\r\n    ...args: unknown[]\r\n  ): Iterable & Iterator {\r\n    const target = (this as any)[ReactiveFlags.RAW]\r\n    const rawTarget = toRaw(target)\r\n    const targetIsMap = isMap(rawTarget)\r\n    const isPair =\r\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\r\n    const isKeyOnly = method === 'keys' && targetIsMap\r\n    const innerIterator = target[method](...args)\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\r\n    !isReadonly &&\r\n      track(\r\n        rawTarget,\r\n        TrackOpTypes.ITERATE,\r\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\r\n      )\r\n    // return a wrapped iterator which returns observed versions of the\r\n    // values emitted from the real iterator\r\n    return {\r\n      // iterator protocol\r\n      next() {\r\n        const { value, done } = innerIterator.next()\r\n        return done\r\n          ? { value, done }\r\n          : {\r\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n              done\r\n            }\r\n      },\r\n      // iterable protocol\r\n      [Symbol.iterator]() {\r\n        return this\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\r\n  return function (this: CollectionTypes, ...args: unknown[]) {\r\n    if (__DEV__) {\r\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\r\n      console.warn(\r\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\r\n        toRaw(this)\r\n      )\r\n    }\r\n    return type === TriggerOpTypes.DELETE\r\n      ? false\r\n      : type === TriggerOpTypes.CLEAR\r\n        ? undefined\r\n        : this\r\n  }\r\n}\r\n\r\nfunction createInstrumentations() {\r\n  const mutableInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n  }\r\n\r\n  const shallowInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, false, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections)\r\n    },\r\n    has,\r\n    add,\r\n    set,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n  }\r\n\r\n  const readonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, false)\r\n  }\r\n\r\n  const shallowReadonlyInstrumentations: Record<string, Function | number> = {\r\n    get(this: MapTypes, key: unknown) {\r\n      return get(this, key, true, true)\r\n    },\r\n    get size() {\r\n      return size(this as unknown as IterableCollections, true)\r\n    },\r\n    has(this: MapTypes, key: unknown) {\r\n      return has.call(this, key, true)\r\n    },\r\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\r\n    set: createReadonlyMethod(TriggerOpTypes.SET),\r\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\r\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\r\n    forEach: createForEach(true, true)\r\n  }\r\n\r\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\r\n  iteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      false\r\n    )\r\n    readonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      false\r\n    )\r\n    shallowInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      false,\r\n      true\r\n    )\r\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\r\n      method,\r\n      true,\r\n      true\r\n    )\r\n  })\r\n\r\n  return [\r\n    mutableInstrumentations,\r\n    readonlyInstrumentations,\r\n    shallowInstrumentations,\r\n    shallowReadonlyInstrumentations\r\n  ]\r\n}\r\n\r\nconst [\r\n  mutableInstrumentations,\r\n  readonlyInstrumentations,\r\n  shallowInstrumentations,\r\n  shallowReadonlyInstrumentations\r\n] = /* #__PURE__*/ createInstrumentations()\r\n\r\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\r\n  const instrumentations = shallow\r\n    ? isReadonly\r\n      ? shallowReadonlyInstrumentations\r\n      : shallowInstrumentations\r\n    : isReadonly\r\n      ? readonlyInstrumentations\r\n      : mutableInstrumentations\r\n\r\n  return (\r\n    target: CollectionTypes,\r\n    key: string | symbol,\r\n    receiver: CollectionTypes\r\n  ) => {\r\n    if (key === ReactiveFlags.IS_REACTIVE) {\r\n      return !isReadonly\r\n    } else if (key === ReactiveFlags.IS_READONLY) {\r\n      return isReadonly\r\n    } else if (key === ReactiveFlags.RAW) {\r\n      return target\r\n    }\r\n\r\n    return Reflect.get(\r\n      hasOwn(instrumentations, key) && key in target\r\n        ? instrumentations\r\n        : target,\r\n      key,\r\n      receiver\r\n    )\r\n  }\r\n}\r\n\r\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n}\r\n\r\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n}\r\n\r\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\r\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n}\r\n\r\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\r\n  {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n  }\r\n\r\nfunction checkIdentityKeys(\r\n  target: CollectionTypes,\r\n  has: (key: unknown) => boolean,\r\n  key: unknown\r\n) {\r\n  const rawKey = toRaw(key)\r\n  if (rawKey !== key && has.call(target, rawKey)) {\r\n    const type = toRawType(target)\r\n    console.warn(\r\n      `Reactive ${type} contains both the raw and reactive ` +\r\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n        `which can lead to inconsistencies. ` +\r\n        `Avoid differentiating between the raw and reactive versions ` +\r\n        `of an object and only use the reactive version if possible.`\r\n    )\r\n  }\r\n}\r\n", "import { isObject, toRawType, def } from '@vue/shared'\r\nimport {\r\n  mutableHandlers,\r\n  readonlyHandlers,\r\n  shallowReactiveHandlers,\r\n  shallowReadonlyHandlers\r\n} from './baseHandlers'\r\nimport {\r\n  mutableCollectionHandlers,\r\n  readonlyCollectionHandlers,\r\n  shallowCollectionHandlers,\r\n  shallowReadonlyCollectionHandlers\r\n} from './collectionHandlers'\r\nimport type { UnwrapRefSimple, Ref, RawSymbol } from './ref'\r\n\r\nexport const enum ReactiveFlags {\r\n  SKIP = '__v_skip',\r\n  IS_REACTIVE = '__v_isReactive',\r\n  IS_READONLY = '__v_isReadonly',\r\n  IS_SHALLOW = '__v_isShallow',\r\n  RAW = '__v_raw'\r\n}\r\n\r\nexport interface Target {\r\n  [ReactiveFlags.SKIP]?: boolean\r\n  [ReactiveFlags.IS_REACTIVE]?: boolean\r\n  [ReactiveFlags.IS_READONLY]?: boolean\r\n  [ReactiveFlags.IS_SHALLOW]?: boolean\r\n  [ReactiveFlags.RAW]?: any\r\n}\r\n\r\nexport const reactiveMap = new WeakMap<Target, any>()\r\nexport const shallowReactiveMap = new WeakMap<Target, any>()\r\nexport const readonlyMap = new WeakMap<Target, any>()\r\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\r\n\r\nconst enum TargetType {\r\n  INVALID = 0,\r\n  COMMON = 1,\r\n  COLLECTION = 2\r\n}\r\n\r\nfunction targetTypeMap(rawType: string) {\r\n  switch (rawType) {\r\n    case 'Object':\r\n    case 'Array':\r\n      return TargetType.COMMON\r\n    case 'Map':\r\n    case 'Set':\r\n    case 'WeakMap':\r\n    case 'WeakSet':\r\n      return TargetType.COLLECTION\r\n    default:\r\n      return TargetType.INVALID\r\n  }\r\n}\r\n\r\nfunction getTargetType(value: Target) {\r\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\r\n    ? TargetType.INVALID\r\n    : targetTypeMap(toRawType(value))\r\n}\r\n\r\n// only unwrap nested ref\r\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\r\n\r\n/**\r\n * Returns a reactive proxy of the object.\r\n *\r\n * The reactive conversion is \"deep\": it affects all nested properties. A\r\n * reactive object also deeply unwraps any properties that are refs while\r\n * maintaining reactivity.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = reactive({ count: 0 })\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#reactive}\r\n */\r\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\r\nexport function reactive(target: object) {\r\n  // if trying to observe a readonly proxy, return the readonly version.\r\n  if (isReadonly(target)) {\r\n    return target\r\n  }\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    mutableHandlers,\r\n    mutableCollectionHandlers,\r\n    reactiveMap\r\n  )\r\n}\r\n\r\nexport declare const ShallowReactiveMarker: unique symbol\r\n\r\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link reactive()}.\r\n *\r\n * Unlike {@link reactive()}, there is no deep conversion: only root-level\r\n * properties are reactive for a shallow reactive object. Property values are\r\n * stored and exposed as-is - this also means properties with ref values will\r\n * not be automatically unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReactive({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties is reactive\r\n * state.foo++\r\n *\r\n * // ...but does not convert nested objects\r\n * isReactive(state.nested) // false\r\n *\r\n * // NOT reactive\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreactive}\r\n */\r\nexport function shallowReactive<T extends object>(\r\n  target: T\r\n): ShallowReactive<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    false,\r\n    shallowReactiveHandlers,\r\n    shallowCollectionHandlers,\r\n    shallowReactiveMap\r\n  )\r\n}\r\n\r\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\r\ntype Builtin = Primitive | Function | Date | Error | RegExp\r\nexport type DeepReadonly<T> = T extends Builtin\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n    : T extends ReadonlyMap<infer K, infer V>\r\n      ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\r\n      : T extends WeakMap<infer K, infer V>\r\n        ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\r\n        : T extends Set<infer U>\r\n          ? ReadonlySet<DeepReadonly<U>>\r\n          : T extends ReadonlySet<infer U>\r\n            ? ReadonlySet<DeepReadonly<U>>\r\n            : T extends WeakSet<infer U>\r\n              ? WeakSet<DeepReadonly<U>>\r\n              : T extends Promise<infer U>\r\n                ? Promise<DeepReadonly<U>>\r\n                : T extends Ref<infer U>\r\n                  ? Readonly<Ref<DeepReadonly<U>>>\r\n                  : T extends {}\r\n                    ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\r\n                    : Readonly<T>\r\n\r\n/**\r\n * Takes an object (reactive or plain) or a ref and returns a readonly proxy to\r\n * the original.\r\n *\r\n * A readonly proxy is deep: any nested property accessed will be readonly as\r\n * well. It also has the same ref-unwrapping behavior as {@link reactive()},\r\n * except the unwrapped values will also be made readonly.\r\n *\r\n * @example\r\n * ```js\r\n * const original = reactive({ count: 0 })\r\n *\r\n * const copy = readonly(original)\r\n *\r\n * watchEffect(() => {\r\n *   // works for reactivity tracking\r\n *   console.log(copy.count)\r\n * })\r\n *\r\n * // mutating original will trigger watchers relying on the copy\r\n * original.count++\r\n *\r\n * // mutating the copy will fail and result in a warning\r\n * copy.count++ // warning!\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#readonly}\r\n */\r\nexport function readonly<T extends object>(\r\n  target: T\r\n): DeepReadonly<UnwrapNestedRefs<T>> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    readonlyHandlers,\r\n    readonlyCollectionHandlers,\r\n    readonlyMap\r\n  )\r\n}\r\n\r\n/**\r\n * Shallow version of {@link readonly()}.\r\n *\r\n * Unlike {@link readonly()}, there is no deep conversion: only root-level\r\n * properties are made readonly. Property values are stored and exposed as-is -\r\n * this also means properties with ref values will not be automatically\r\n * unwrapped.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowReadonly({\r\n *   foo: 1,\r\n *   nested: {\r\n *     bar: 2\r\n *   }\r\n * })\r\n *\r\n * // mutating state's own properties will fail\r\n * state.foo++\r\n *\r\n * // ...but works on nested objects\r\n * isReadonly(state.nested) // false\r\n *\r\n * // works\r\n * state.nested.bar++\r\n * ```\r\n *\r\n * @param target - The source object.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowreadonly}\r\n */\r\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\r\n  return createReactiveObject(\r\n    target,\r\n    true,\r\n    shallowReadonlyHandlers,\r\n    shallowReadonlyCollectionHandlers,\r\n    shallowReadonlyMap\r\n  )\r\n}\r\n\r\nfunction createReactiveObject(\r\n  target: Target,\r\n  isReadonly: boolean,\r\n  baseHandlers: ProxyHandler<any>,\r\n  collectionHandlers: ProxyHandler<any>,\r\n  proxyMap: WeakMap<Target, any>\r\n) {\r\n  if (!isObject(target)) {\r\n    if (__DEV__) {\r\n      console.warn(`value cannot be made reactive: ${String(target)}`)\r\n    }\r\n    return target\r\n  }\r\n  // target is already a Proxy, return it.\r\n  // exception: calling readonly() on a reactive object\r\n  if (\r\n    target[ReactiveFlags.RAW] &&\r\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\r\n  ) {\r\n    return target\r\n  }\r\n  // target already has corresponding Proxy\r\n  const existingProxy = proxyMap.get(target)\r\n  if (existingProxy) {\r\n    return existingProxy\r\n  }\r\n  // only specific value types can be observed.\r\n  const targetType = getTargetType(target)\r\n  if (targetType === TargetType.INVALID) {\r\n    return target\r\n  }\r\n  const proxy = new Proxy(\r\n    target,\r\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\r\n  )\r\n  proxyMap.set(target, proxy)\r\n  return proxy\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive()} or\r\n * {@link shallowReactive()} (or {@link ref()} in some cases).\r\n *\r\n * @example\r\n * ```js\r\n * isReactive(reactive({}))            // => true\r\n * isReactive(readonly(reactive({})))  // => true\r\n * isReactive(ref({}).value)           // => true\r\n * isReactive(readonly(ref({})).value) // => true\r\n * isReactive(ref(true))               // => false\r\n * isReactive(shallowRef({}).value)    // => false\r\n * isReactive(shallowReactive({}))     // => true\r\n * ```\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreactive}\r\n */\r\nexport function isReactive(value: unknown): boolean {\r\n  if (isReadonly(value)) {\r\n    return isReactive((value as Target)[ReactiveFlags.RAW])\r\n  }\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\r\n}\r\n\r\n/**\r\n * Checks whether the passed value is a readonly object. The properties of a\r\n * readonly object can change, but they can't be assigned directly via the\r\n * passed object.\r\n *\r\n * The proxies created by {@link readonly()} and {@link shallowReadonly()} are\r\n * both considered readonly, as is a computed ref without a set function.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isreadonly}\r\n */\r\nexport function isReadonly(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\r\n}\r\n\r\nexport function isShallow(value: unknown): boolean {\r\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\r\n}\r\n\r\n/**\r\n * Checks if an object is a proxy created by {@link reactive},\r\n * {@link readonly}, {@link shallowReactive} or {@link shallowReadonly()}.\r\n *\r\n * @param value - The value to check.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isproxy}\r\n */\r\nexport function isProxy(value: unknown): boolean {\r\n  return isReactive(value) || isReadonly(value)\r\n}\r\n\r\n/**\r\n * Returns the raw, original object of a Vue-created proxy.\r\n *\r\n * `toRaw()` can return the original object from proxies created by\r\n * {@link reactive()}, {@link readonly()}, {@link shallowReactive()} or\r\n * {@link shallowReadonly()}.\r\n *\r\n * This is an escape hatch that can be used to temporarily read without\r\n * incurring proxy access / tracking overhead or write without triggering\r\n * changes. It is **not** recommended to hold a persistent reference to the\r\n * original object. Use with caution.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = {}\r\n * const reactiveFoo = reactive(foo)\r\n *\r\n * console.log(toRaw(reactiveFoo) === foo) // true\r\n * ```\r\n *\r\n * @param observed - The object for which the \"raw\" value is requested.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#toraw}\r\n */\r\nexport function toRaw<T>(observed: T): T {\r\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\r\n  return raw ? toRaw(raw) : observed\r\n}\r\n\r\nexport type Raw<T> = T & { [RawSymbol]?: true }\r\n\r\n/**\r\n * Marks an object so that it will never be converted to a proxy. Returns the\r\n * object itself.\r\n *\r\n * @example\r\n * ```js\r\n * const foo = markRaw({})\r\n * console.log(isReactive(reactive(foo))) // false\r\n *\r\n * // also works when nested inside other reactive objects\r\n * const bar = reactive({ foo })\r\n * console.log(isReactive(bar.foo)) // false\r\n * ```\r\n *\r\n * **Warning:** `markRaw()` together with the shallow APIs such as\r\n * {@link shallowReactive()} allow you to selectively opt-out of the default\r\n * deep reactive/readonly conversion and embed raw, non-proxied objects in your\r\n * state graph.\r\n *\r\n * @param value - The object to be marked as \"raw\".\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#markraw}\r\n */\r\nexport function markRaw<T extends object>(value: T): Raw<T> {\r\n  def(value, ReactiveFlags.SKIP, true)\r\n  return value\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a reactive proxy shall be created.\r\n */\r\nexport const toReactive = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? reactive(value) : value\r\n\r\n/**\r\n * Returns a readonly proxy of the given value (if possible).\r\n *\r\n * If the given value is not an object, the original value itself is returned.\r\n *\r\n * @param value - The value for which a readonly proxy shall be created.\r\n */\r\nexport const toReadonly = <T extends unknown>(value: T): T =>\r\n  isObject(value) ? readonly(value) : value\r\n", "import type { ComputedRef } from './computed'\r\nimport {\r\n  activeEffect,\r\n  getDepFromReactive,\r\n  shouldTrack,\r\n  trackEffects,\r\n  triggerEffects\r\n} from './effect'\r\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\r\nimport { isArray, hasChanged, IfAny, isFunction, isObject } from '@vue/shared'\r\nimport {\r\n  isProxy,\r\n  toRaw,\r\n  isReactive,\r\n  toReactive,\r\n  isReadonly,\r\n  isShallow\r\n} from './reactive'\r\nimport type { ShallowReactiveMarker } from './reactive'\r\nimport { createDep, Dep } from './dep'\r\n\r\ndeclare const RefSymbol: unique symbol\r\nexport declare const RawSymbol: unique symbol\r\n\r\nexport interface Ref<T = any> {\r\n  value: T\r\n  /**\r\n   * Type differentiator only.\r\n   * We need this to be in public d.ts but don't want it to show up in IDE\r\n   * autocomplete, so we use a private Symbol instead.\r\n   */\r\n  [RefSymbol]: true\r\n}\r\n\r\ntype RefBase<T> = {\r\n  dep?: Dep\r\n  value: T\r\n}\r\n\r\nexport function trackRefValue(ref: RefBase<any>) {\r\n  if (shouldTrack && activeEffect) {\r\n    ref = toRaw(ref)\r\n    if (__DEV__) {\r\n      trackEffects(ref.dep || (ref.dep = createDep()), {\r\n        target: ref,\r\n        type: TrackOpTypes.GET,\r\n        key: 'value'\r\n      })\r\n    } else {\r\n      trackEffects(ref.dep || (ref.dep = createDep()))\r\n    }\r\n  }\r\n}\r\n\r\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\r\n  ref = toRaw(ref)\r\n  const dep = ref.dep\r\n  if (dep) {\r\n    if (__DEV__) {\r\n      triggerEffects(dep, {\r\n        target: ref,\r\n        type: TriggerOpTypes.SET,\r\n        key: 'value',\r\n        newValue: newVal\r\n      })\r\n    } else {\r\n      triggerEffects(dep)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if a value is a ref object.\r\n *\r\n * @param r - The value to inspect.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#isref}\r\n */\r\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\r\nexport function isRef(r: any): r is Ref {\r\n  return !!(r && r.__v_isRef === true)\r\n}\r\n\r\n/**\r\n * Takes an inner value and returns a reactive and mutable ref object, which\r\n * has a single property `.value` that points to the inner value.\r\n *\r\n * @param value - The object to wrap in the ref.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#ref}\r\n */\r\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\r\nexport function ref<T = any>(): Ref<T | undefined>\r\nexport function ref(value?: unknown) {\r\n  return createRef(value, false)\r\n}\r\n\r\ndeclare const ShallowRefMarker: unique symbol\r\n\r\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\r\n\r\n/**\r\n * Shallow version of {@link ref()}.\r\n *\r\n * @example\r\n * ```js\r\n * const state = shallowRef({ count: 1 })\r\n *\r\n * // does NOT trigger change\r\n * state.value.count = 2\r\n *\r\n * // does trigger change\r\n * state.value = { count: 2 }\r\n * ```\r\n *\r\n * @param value - The \"inner value\" for the shallow ref.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#shallowref}\r\n */\r\nexport function shallowRef<T>(\r\n  value: T\r\n): Ref extends T\r\n  ? T extends Ref\r\n    ? IfAny<T, ShallowRef<T>, T>\r\n    : ShallowRef<T>\r\n  : ShallowRef<T>\r\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\r\nexport function shallowRef(value?: unknown) {\r\n  return createRef(value, true)\r\n}\r\n\r\nfunction createRef(rawValue: unknown, shallow: boolean) {\r\n  if (isRef(rawValue)) {\r\n    return rawValue\r\n  }\r\n  return new RefImpl(rawValue, shallow)\r\n}\r\n\r\nclass RefImpl<T> {\r\n  private _value: T\r\n  private _rawValue: T\r\n\r\n  public dep?: Dep = undefined\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    value: T,\r\n    public readonly __v_isShallow: boolean\r\n  ) {\r\n    this._rawValue = __v_isShallow ? value : toRaw(value)\r\n    this._value = __v_isShallow ? value : toReactive(value)\r\n  }\r\n\r\n  get value() {\r\n    trackRefValue(this)\r\n    return this._value\r\n  }\r\n\r\n  set value(newVal) {\r\n    const useDirectValue =\r\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\r\n    newVal = useDirectValue ? newVal : toRaw(newVal)\r\n    if (hasChanged(newVal, this._rawValue)) {\r\n      this._rawValue = newVal\r\n      this._value = useDirectValue ? newVal : toReactive(newVal)\r\n      triggerRefValue(this, newVal)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Force trigger effects that depends on a shallow ref. This is typically used\r\n * after making deep mutations to the inner value of a shallow ref.\r\n *\r\n * @example\r\n * ```js\r\n * const shallow = shallowRef({\r\n *   greet: 'Hello, world'\r\n * })\r\n *\r\n * // Logs \"Hello, world\" once for the first run-through\r\n * watchEffect(() => {\r\n *   console.log(shallow.value.greet)\r\n * })\r\n *\r\n * // This won't trigger the effect because the ref is shallow\r\n * shallow.value.greet = 'Hello, universe'\r\n *\r\n * // Logs \"Hello, universe\"\r\n * triggerRef(shallow)\r\n * ```\r\n *\r\n * @param ref - The ref whose tied effects shall be executed.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#triggerref}\r\n */\r\nexport function triggerRef(ref: Ref) {\r\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\r\n}\r\n\r\nexport type MaybeRef<T = any> = T | Ref<T>\r\nexport type MaybeRefOrGetter<T = any> = MaybeRef<T> | (() => T)\r\n\r\n/**\r\n * Returns the inner value if the argument is a ref, otherwise return the\r\n * argument itself. This is a sugar function for\r\n * `val = isRef(val) ? val.value : val`.\r\n *\r\n * @example\r\n * ```js\r\n * function useFoo(x: number | Ref<number>) {\r\n *   const unwrapped = unref(x)\r\n *   // unwrapped is guaranteed to be number now\r\n * }\r\n * ```\r\n *\r\n * @param ref - Ref or plain value to be converted into the plain value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#unref}\r\n */\r\nexport function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {\r\n  return isRef(ref) ? ref.value : ref\r\n}\r\n\r\n/**\r\n * Normalizes values / refs / getters to values.\r\n * This is similar to {@link unref()}, except that it also normalizes getters.\r\n * If the argument is a getter, it will be invoked and its return value will\r\n * be returned.\r\n *\r\n * @example\r\n * ```js\r\n * toValue(1) // 1\r\n * toValue(ref(1)) // 1\r\n * toValue(() => 1) // 1\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, or a non-function value.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#tovalue}\r\n */\r\nexport function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {\r\n  return isFunction(source) ? source() : unref(source)\r\n}\r\n\r\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\r\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n  set: (target, key, value, receiver) => {\r\n    const oldValue = target[key]\r\n    if (isRef(oldValue) && !isRef(value)) {\r\n      oldValue.value = value\r\n      return true\r\n    } else {\r\n      return Reflect.set(target, key, value, receiver)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a reactive proxy for the given object.\r\n *\r\n * If the object already is reactive, it's returned as-is. If not, a new\r\n * reactive proxy is created. Direct child properties that are refs are properly\r\n * handled, as well.\r\n *\r\n * @param objectWithRefs - Either an already-reactive object or a simple object\r\n * that contains refs.\r\n */\r\nexport function proxyRefs<T extends object>(\r\n  objectWithRefs: T\r\n): ShallowUnwrapRef<T> {\r\n  return isReactive(objectWithRefs)\r\n    ? objectWithRefs\r\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\r\n}\r\n\r\nexport type CustomRefFactory<T> = (\r\n  track: () => void,\r\n  trigger: () => void\r\n) => {\r\n  get: () => T\r\n  set: (value: T) => void\r\n}\r\n\r\nclass CustomRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\r\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\r\n\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(factory: CustomRefFactory<T>) {\r\n    const { get, set } = factory(\r\n      () => trackRefValue(this),\r\n      () => triggerRefValue(this)\r\n    )\r\n    this._get = get\r\n    this._set = set\r\n  }\r\n\r\n  get value() {\r\n    return this._get()\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._set(newVal)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a customized ref with explicit control over its dependency tracking\r\n * and updates triggering.\r\n *\r\n * @param factory - The function that receives the `track` and `trigger` callbacks.\r\n * @see {@link https://vuejs.org/api/reactivity-advanced.html#customref}\r\n */\r\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\r\n  return new CustomRefImpl(factory) as any\r\n}\r\n\r\nexport type ToRefs<T = any> = {\r\n  [K in keyof T]: ToRef<T[K]>\r\n}\r\n\r\n/**\r\n * Converts a reactive object to a plain object where each property of the\r\n * resulting object is a ref pointing to the corresponding property of the\r\n * original object. Each individual ref is created using {@link toRef()}.\r\n *\r\n * @param object - Reactive object to be made into an object of linked refs.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#torefs}\r\n */\r\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\r\n  if (__DEV__ && !isProxy(object)) {\r\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\r\n  }\r\n  const ret: any = isArray(object) ? new Array(object.length) : {}\r\n  for (const key in object) {\r\n    ret[key] = propertyToRef(object, key)\r\n  }\r\n  return ret\r\n}\r\n\r\nclass ObjectRefImpl<T extends object, K extends keyof T> {\r\n  public readonly __v_isRef = true\r\n\r\n  constructor(\r\n    private readonly _object: T,\r\n    private readonly _key: K,\r\n    private readonly _defaultValue?: T[K]\r\n  ) {}\r\n\r\n  get value() {\r\n    const val = this._object[this._key]\r\n    return val === undefined ? this._defaultValue! : val\r\n  }\r\n\r\n  set value(newVal) {\r\n    this._object[this._key] = newVal\r\n  }\r\n\r\n  get dep(): Dep | undefined {\r\n    return getDepFromReactive(toRaw(this._object), this._key)\r\n  }\r\n}\r\n\r\nclass GetterRefImpl<T> {\r\n  public readonly __v_isRef = true\r\n  public readonly __v_isReadonly = true\r\n  constructor(private readonly _getter: () => T) {}\r\n  get value() {\r\n    return this._getter()\r\n  }\r\n}\r\n\r\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\r\n\r\n/**\r\n * Used to normalize values / refs / getters into refs.\r\n *\r\n * @example\r\n * ```js\r\n * // returns existing refs as-is\r\n * toRef(existingRef)\r\n *\r\n * // creates a ref that calls the getter on .value access\r\n * toRef(() => props.foo)\r\n *\r\n * // creates normal refs from non-function values\r\n * // equivalent to ref(1)\r\n * toRef(1)\r\n * ```\r\n *\r\n * Can also be used to create a ref for a property on a source reactive object.\r\n * The created ref is synced with its source property: mutating the source\r\n * property will update the ref, and vice-versa.\r\n *\r\n * @example\r\n * ```js\r\n * const state = reactive({\r\n *   foo: 1,\r\n *   bar: 2\r\n * })\r\n *\r\n * const fooRef = toRef(state, 'foo')\r\n *\r\n * // mutating the ref updates the original\r\n * fooRef.value++\r\n * console.log(state.foo) // 2\r\n *\r\n * // mutating the original also updates the ref\r\n * state.foo++\r\n * console.log(fooRef.value) // 3\r\n * ```\r\n *\r\n * @param source - A getter, an existing ref, a non-function value, or a\r\n *                 reactive object to create a property ref from.\r\n * @param [key] - (optional) Name of the property in the reactive object.\r\n * @see {@link https://vuejs.org/api/reactivity-utilities.html#toref}\r\n */\r\nexport function toRef<T>(\r\n  value: T\r\n): T extends () => infer R\r\n  ? Readonly<Ref<R>>\r\n  : T extends Ref\r\n    ? T\r\n    : Ref<UnwrapRef<T>>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K\r\n): ToRef<T[K]>\r\nexport function toRef<T extends object, K extends keyof T>(\r\n  object: T,\r\n  key: K,\r\n  defaultValue: T[K]\r\n): ToRef<Exclude<T[K], undefined>>\r\nexport function toRef(\r\n  source: Record<string, any> | MaybeRef,\r\n  key?: string,\r\n  defaultValue?: unknown\r\n): Ref {\r\n  if (isRef(source)) {\r\n    return source\r\n  } else if (isFunction(source)) {\r\n    return new GetterRefImpl(source) as any\r\n  } else if (isObject(source) && arguments.length > 1) {\r\n    return propertyToRef(source, key!, defaultValue)\r\n  } else {\r\n    return ref(source)\r\n  }\r\n}\r\n\r\nfunction propertyToRef(\r\n  source: Record<string, any>,\r\n  key: string,\r\n  defaultValue?: unknown\r\n) {\r\n  const val = source[key]\r\n  return isRef(val)\r\n    ? val\r\n    : (new ObjectRefImpl(source, key, defaultValue) as any)\r\n}\r\n\r\n// corner case when use narrows type\r\n// Ex. type RelativePath = string & { __brand: unknown }\r\n// RelativePath extends object -> true\r\ntype BaseTypes = string | number | boolean\r\n\r\n/**\r\n * This is a special exported interface for other packages to declare\r\n * additional types that should bail out for ref unwrapping. For example\r\n * \\@vue/runtime-dom can declare it like so in its d.ts:\r\n *\r\n * ``` ts\r\n * declare module '@vue/reactivity' {\r\n *   export interface RefUnwrapBailTypes {\r\n *     runtimeDOMBailTypes: Node | Window\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface RefUnwrapBailTypes {}\r\n\r\nexport type ShallowUnwrapRef<T> = {\r\n  [K in keyof T]: DistrubuteRef<T[K]>\r\n}\r\n\r\ntype DistrubuteRef<T> = T extends Ref<infer V> ? V : T\r\n\r\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\r\n  ? V\r\n  : T extends Ref<infer V>\r\n    ? UnwrapRefSimple<V>\r\n    : UnwrapRefSimple<T>\r\n\r\nexport type UnwrapRefSimple<T> = T extends\r\n  | Function\r\n  | BaseTypes\r\n  | Ref\r\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\r\n  | { [RawSymbol]?: true }\r\n  ? T\r\n  : T extends Map<infer K, infer V>\r\n    ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>>\r\n    : T extends WeakMap<infer K, infer V>\r\n      ? WeakMap<K, UnwrapRefSimple<V>> &\r\n          UnwrapRef<Omit<T, keyof WeakMap<any, any>>>\r\n      : T extends Set<infer V>\r\n        ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>>\r\n        : T extends WeakSet<infer V>\r\n          ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>>\r\n          : T extends ReadonlyArray<any>\r\n            ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\r\n            : T extends object & { [ShallowReactiveMarker]?: never }\r\n              ? {\r\n                  [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\r\n                }\r\n              : T\r\n", "import { DebuggerOptions, ReactiveEffect } from './effect'\r\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\r\nimport { isFunction, NOOP } from '@vue/shared'\r\nimport { ReactiveFlags, toRaw } from './reactive'\r\nimport { Dep } from './dep'\r\n\r\ndeclare const ComputedRefSymbol: unique symbol\r\n\r\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\r\n  readonly value: T\r\n  [ComputedRefSymbol]: true\r\n}\r\n\r\nexport interface WritableComputedRef<T> extends Ref<T> {\r\n  readonly effect: ReactiveEffect<T>\r\n}\r\n\r\nexport type ComputedGetter<T> = (...args: any[]) => T\r\nexport type ComputedSetter<T> = (v: T) => void\r\n\r\nexport interface WritableComputedOptions<T> {\r\n  get: ComputedGetter<T>\r\n  set: ComputedSetter<T>\r\n}\r\n\r\nexport class ComputedRefImpl<T> {\r\n  public dep?: Dep = undefined\r\n\r\n  private _value!: T\r\n  public readonly effect: ReactiveEffect<T>\r\n\r\n  public readonly __v_isRef = true\r\n  public readonly [ReactiveFlags.IS_READONLY]: boolean = false\r\n\r\n  public _dirty = true\r\n  public _cacheable: boolean\r\n\r\n  constructor(\r\n    getter: ComputedGetter<T>,\r\n    private readonly _setter: ComputedSetter<T>,\r\n    isReadonly: boolean,\r\n    isSSR: boolean\r\n  ) {\r\n    this.effect = new ReactiveEffect(getter, () => {\r\n      if (!this._dirty) {\r\n        this._dirty = true\r\n        triggerRefValue(this)\r\n      }\r\n    })\r\n    this.effect.computed = this\r\n    this.effect.active = this._cacheable = !isSSR\r\n    this[ReactiveFlags.IS_READONLY] = isReadonly\r\n  }\r\n\r\n  get value() {\r\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n    const self = toRaw(this)\r\n    trackRefValue(self)\r\n    if (self._dirty || !self._cacheable) {\r\n      self._dirty = false\r\n      self._value = self.effect.run()!\r\n    }\r\n    return self._value\r\n  }\r\n\r\n  set value(newValue: T) {\r\n    this._setter(newValue)\r\n  }\r\n}\r\n\r\n/**\r\n * Takes a getter function and returns a readonly reactive ref object for the\r\n * returned value from the getter. It can also take an object with get and set\r\n * functions to create a writable ref object.\r\n *\r\n * @example\r\n * ```js\r\n * // Creating a readonly computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed(() => count.value + 1)\r\n *\r\n * console.log(plusOne.value) // 2\r\n * plusOne.value++ // error\r\n * ```\r\n *\r\n * ```js\r\n * // Creating a writable computed ref:\r\n * const count = ref(1)\r\n * const plusOne = computed({\r\n *   get: () => count.value + 1,\r\n *   set: (val) => {\r\n *     count.value = val - 1\r\n *   }\r\n * })\r\n *\r\n * plusOne.value = 1\r\n * console.log(count.value) // 0\r\n * ```\r\n *\r\n * @param getter - Function that produces the next value.\r\n * @param debugOptions - For debugging. See {@link https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging}.\r\n * @see {@link https://vuejs.org/api/reactivity-core.html#computed}\r\n */\r\nexport function computed<T>(\r\n  getter: ComputedGetter<T>,\r\n  debugOptions?: DebuggerOptions\r\n): ComputedRef<T>\r\nexport function computed<T>(\r\n  options: WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions\r\n): WritableComputedRef<T>\r\nexport function computed<T>(\r\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\r\n  debugOptions?: DebuggerOptions,\r\n  isSSR = false\r\n) {\r\n  let getter: ComputedGetter<T>\r\n  let setter: ComputedSetter<T>\r\n\r\n  const onlyGetter = isFunction(getterOrOptions)\r\n  if (onlyGetter) {\r\n    getter = getterOrOptions\r\n    setter = __DEV__\r\n      ? () => {\r\n          console.warn('Write operation failed: computed value is readonly')\r\n        }\r\n      : NOOP\r\n  } else {\r\n    getter = getterOrOptions.get\r\n    setter = getterOrOptions.set\r\n  }\r\n\r\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\r\n\r\n  if (__DEV__ && debugOptions && !isSSR) {\r\n    cRef.effect.onTrack = debugOptions.onTrack\r\n    cRef.effect.onTrigger = debugOptions.onTrigger\r\n  }\r\n\r\n  return cRef as any\r\n}\r\n", "import { VNode } from './vnode'\r\nimport {\r\n  Data,\r\n  ComponentInternalInstance,\r\n  ConcreteComponent,\r\n  formatComponentName\r\n} from './component'\r\nimport { isString, isFunction } from '@vue/shared'\r\nimport { toRaw, isRef, pauseTracking, resetTracking } from '@vue/reactivity'\r\nimport { callWithErrorHandling, ErrorCodes } from './errorHandling'\r\n\r\ntype ComponentVNode = VNode & {\r\n  type: ConcreteComponent\r\n}\r\n\r\nconst stack: VNode[] = []\r\n\r\ntype TraceEntry = {\r\n  vnode: ComponentVNode\r\n  recurseCount: number\r\n}\r\n\r\ntype ComponentTraceStack = TraceEntry[]\r\n\r\nexport function pushWarningContext(vnode: VNode) {\r\n  stack.push(vnode)\r\n}\r\n\r\nexport function popWarningContext() {\r\n  stack.pop()\r\n}\r\n\r\nexport function warn(msg: string, ...args: any[]) {\r\n  if (!__DEV__) return\r\n\r\n  // avoid props formatting or warn handler tracking deps that might be mutated\r\n  // during patch, leading to infinite recursion.\r\n  pauseTracking()\r\n\r\n  const instance = stack.length ? stack[stack.length - 1].component : null\r\n  const appWarnHandler = instance && instance.appContext.config.warnHandler\r\n  const trace = getComponentTrace()\r\n\r\n  if (appWarnHandler) {\r\n    callWithErrorHandling(\r\n      appWarnHandler,\r\n      instance,\r\n      ErrorCodes.APP_WARN_HANDLER,\r\n      [\r\n        msg + args.join(''),\r\n        instance && instance.proxy,\r\n        trace\r\n          .map(\r\n            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\r\n          )\r\n          .join('\\n'),\r\n        trace\r\n      ]\r\n    )\r\n  } else {\r\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args]\r\n    /* istanbul ignore if */\r\n    if (\r\n      trace.length &&\r\n      // avoid spamming console during tests\r\n      !__TEST__\r\n    ) {\r\n      warnArgs.push(`\\n`, ...formatTrace(trace))\r\n    }\r\n    console.warn(...warnArgs)\r\n  }\r\n\r\n  resetTracking()\r\n}\r\n\r\nexport function getComponentTrace(): ComponentTraceStack {\r\n  let currentVNode: VNode | null = stack[stack.length - 1]\r\n  if (!currentVNode) {\r\n    return []\r\n  }\r\n\r\n  // we can't just use the stack because it will be incomplete during updates\r\n  // that did not start from the root. Re-construct the parent chain using\r\n  // instance parent pointers.\r\n  const normalizedStack: ComponentTraceStack = []\r\n\r\n  while (currentVNode) {\r\n    const last = normalizedStack[0]\r\n    if (last && last.vnode === currentVNode) {\r\n      last.recurseCount++\r\n    } else {\r\n      normalizedStack.push({\r\n        vnode: currentVNode as ComponentVNode,\r\n        recurseCount: 0\r\n      })\r\n    }\r\n    const parentInstance: ComponentInternalInstance | null =\r\n      currentVNode.component && currentVNode.component.parent\r\n    currentVNode = parentInstance && parentInstance.vnode\r\n  }\r\n\r\n  return normalizedStack\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace: ComponentTraceStack): any[] {\r\n  const logs: any[] = []\r\n  trace.forEach((entry, i) => {\r\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry))\r\n  })\r\n  return logs\r\n}\r\n\r\nfunction formatTraceEntry({ vnode, recurseCount }: TraceEntry): any[] {\r\n  const postfix =\r\n    recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``\r\n  const isRoot = vnode.component ? vnode.component.parent == null : false\r\n  const open = ` at <${formatComponentName(\r\n    vnode.component,\r\n    vnode.type,\r\n    isRoot\r\n  )}`\r\n  const close = `>` + postfix\r\n  return vnode.props\r\n    ? [open, ...formatProps(vnode.props), close]\r\n    : [open + close]\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction formatProps(props: Data): any[] {\r\n  const res: any[] = []\r\n  const keys = Object.keys(props)\r\n  keys.slice(0, 3).forEach(key => {\r\n    res.push(...formatProp(key, props[key]))\r\n  })\r\n  if (keys.length > 3) {\r\n    res.push(` ...`)\r\n  }\r\n  return res\r\n}\r\n\r\nfunction formatProp(key: string, value: unknown): any[]\r\nfunction formatProp(key: string, value: unknown, raw: true): any\r\n/* istanbul ignore next */\r\nfunction formatProp(key: string, value: unknown, raw?: boolean): any {\r\n  if (isString(value)) {\r\n    value = JSON.stringify(value)\r\n    return raw ? value : [`${key}=${value}`]\r\n  } else if (\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean' ||\r\n    value == null\r\n  ) {\r\n    return raw ? value : [`${key}=${value}`]\r\n  } else if (isRef(value)) {\r\n    value = formatProp(key, toRaw(value.value), true)\r\n    return raw ? value : [`${key}=Ref<`, value, `>`]\r\n  } else if (isFunction(value)) {\r\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`]\r\n  } else {\r\n    value = toRaw(value)\r\n    return raw ? value : [`${key}=`, value]\r\n  }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function assertNumber(val: unknown, type: string) {\r\n  if (!__DEV__) return\r\n  if (val === undefined) {\r\n    return\r\n  } else if (typeof val !== 'number') {\r\n    warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`)\r\n  } else if (isNaN(val)) {\r\n    warn(`${type} is NaN - ` + 'the duration expression might be incorrect.')\r\n  }\r\n}\r\n", "import { VNode } from './vnode'\r\nimport { ComponentInternalInstance } from './component'\r\nimport { warn, pushWarningContext, popWarningContext } from './warning'\r\nimport { isPromise, isFunction } from '@vue/shared'\r\nimport { LifecycleHooks } from './enums'\r\n\r\n// contexts where user provided function may be executed, in addition to\r\n// lifecycle hooks.\r\nexport const enum ErrorCodes {\r\n  SETUP_FUNCTION,\r\n  RENDER_FUNCTION,\r\n  WATCH_GETTER,\r\n  WATCH_CALLBACK,\r\n  WATCH_CLEANUP,\r\n  NATIVE_EVENT_HANDLER,\r\n  COMPONENT_EVENT_HANDLER,\r\n  VNODE_HOOK,\r\n  DIRECTIVE_HOOK,\r\n  TRANSITION_HOOK,\r\n  APP_ERROR_HANDLER,\r\n  APP_WARN_HANDLER,\r\n  FUNCTION_REF,\r\n  ASYNC_COMPONENT_LOADER,\r\n  SCHEDULER\r\n}\r\n\r\nexport const ErrorTypeStrings: Record<LifecycleHooks | ErrorCodes, string> = {\r\n  [LifecycleHooks.SERVER_PREFETCH]: 'serverPrefetch hook',\r\n  [LifecycleHooks.BEFORE_CREATE]: 'beforeCreate hook',\r\n  [LifecycleHooks.CREATED]: 'created hook',\r\n  [LifecycleHooks.BEFORE_MOUNT]: 'beforeMount hook',\r\n  [LifecycleHooks.MOUNTED]: 'mounted hook',\r\n  [LifecycleHooks.BEFORE_UPDATE]: 'beforeUpdate hook',\r\n  [LifecycleHooks.UPDATED]: 'updated',\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: 'beforeUnmount hook',\r\n  [LifecycleHooks.UNMOUNTED]: 'unmounted hook',\r\n  [LifecycleHooks.ACTIVATED]: 'activated hook',\r\n  [LifecycleHooks.DEACTIVATED]: 'deactivated hook',\r\n  [LifecycleHooks.ERROR_CAPTURED]: 'errorCaptured hook',\r\n  [LifecycleHooks.RENDER_TRACKED]: 'renderTracked hook',\r\n  [LifecycleHooks.RENDER_TRIGGERED]: 'renderTriggered hook',\r\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\r\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\r\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\r\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\r\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\r\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\r\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\r\n  [ErrorCodes.VNODE_HOOK]: 'vnode hook',\r\n  [ErrorCodes.DIRECTIVE_HOOK]: 'directive hook',\r\n  [ErrorCodes.TRANSITION_HOOK]: 'transition hook',\r\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\r\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\r\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\r\n  [ErrorCodes.ASYNC_COMPONENT_LOADER]: 'async component loader',\r\n  [ErrorCodes.SCHEDULER]:\r\n    'scheduler flush. This is likely a Vue internals bug. ' +\r\n    'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n}\r\n\r\nexport type ErrorTypes = LifecycleHooks | ErrorCodes\r\n\r\nexport function callWithErrorHandling(\r\n  fn: Function,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[]\r\n) {\r\n  let res\r\n  try {\r\n    res = args ? fn(...args) : fn()\r\n  } catch (err) {\r\n    handleError(err, instance, type)\r\n  }\r\n  return res\r\n}\r\n\r\nexport function callWithAsyncErrorHandling(\r\n  fn: Function | Function[],\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  args?: unknown[]\r\n): any[] {\r\n  if (isFunction(fn)) {\r\n    const res = callWithErrorHandling(fn, instance, type, args)\r\n    if (res && isPromise(res)) {\r\n      res.catch(err => {\r\n        handleError(err, instance, type)\r\n      })\r\n    }\r\n    return res\r\n  }\r\n\r\n  const values = []\r\n  for (let i = 0; i < fn.length; i++) {\r\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\r\n  }\r\n  return values\r\n}\r\n\r\nexport function handleError(\r\n  err: unknown,\r\n  instance: ComponentInternalInstance | null,\r\n  type: ErrorTypes,\r\n  throwInDev = true\r\n) {\r\n  const contextVNode = instance ? instance.vnode : null\r\n  if (instance) {\r\n    let cur = instance.parent\r\n    // the exposed instance is the render proxy to keep it consistent with 2.x\r\n    const exposedInstance = instance.proxy\r\n    // in production the hook receives only the error code\r\n    const errorInfo = __DEV__ ? ErrorTypeStrings[type] : type\r\n    while (cur) {\r\n      const errorCapturedHooks = cur.ec\r\n      if (errorCapturedHooks) {\r\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n          if (\r\n            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false\r\n          ) {\r\n            return\r\n          }\r\n        }\r\n      }\r\n      cur = cur.parent\r\n    }\r\n    // app-level handling\r\n    const appErrorHandler = instance.appContext.config.errorHandler\r\n    if (appErrorHandler) {\r\n      callWithErrorHandling(\r\n        appErrorHandler,\r\n        null,\r\n        ErrorCodes.APP_ERROR_HANDLER,\r\n        [err, exposedInstance, errorInfo]\r\n      )\r\n      return\r\n    }\r\n  }\r\n  logError(err, type, contextVNode, throwInDev)\r\n}\r\n\r\nfunction logError(\r\n  err: unknown,\r\n  type: ErrorTypes,\r\n  contextVNode: VNode | null,\r\n  throwInDev = true\r\n) {\r\n  if (__DEV__) {\r\n    const info = ErrorTypeStrings[type]\r\n    if (contextVNode) {\r\n      pushWarningContext(contextVNode)\r\n    }\r\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\r\n    if (contextVNode) {\r\n      popWarningContext()\r\n    }\r\n    // crash in dev by default so it's more noticeable\r\n    if (throwInDev) {\r\n      throw err\r\n    } else if (!__TEST__) {\r\n      console.error(err)\r\n    }\r\n  } else {\r\n    // recover in prod to reduce the impact on end-user\r\n    console.error(err)\r\n  }\r\n}\r\n", "import { ErrorCodes, callWithErrorHandling } from './errorHandling'\r\nimport { Awaited, isArray, NOOP } from '@vue/shared'\r\nimport { ComponentInternalInstance, getComponentName } from './component'\r\nimport { warn } from './warning'\r\n\r\nexport interface SchedulerJob extends Function {\r\n  id?: number\r\n  pre?: boolean\r\n  active?: boolean\r\n  computed?: boolean\r\n  /**\r\n   * Indicates whether the effect is allowed to recursively trigger itself\r\n   * when managed by the scheduler.\r\n   *\r\n   * By default, a job cannot trigger itself because some built-in method calls,\r\n   * e.g. Array.prototype.push actually performs reads as well (#1740) which\r\n   * can lead to confusing infinite loops.\r\n   * The allowed cases are component update functions and watch callbacks.\r\n   * Component update functions may update child component props, which in turn\r\n   * trigger flush: \"pre\" watch callbacks that mutates state that the parent\r\n   * relies on (#1801). Watch callbacks doesn't track its dependencies so if it\r\n   * triggers itself again, it's likely intentional and it is the user's\r\n   * responsibility to perform recursive state mutation that eventually\r\n   * stabilizes (#1727).\r\n   */\r\n  allowRecurse?: boolean\r\n  /**\r\n   * Attached by renderer.ts when setting up a component's render effect\r\n   * Used to obtain component information when reporting max recursive updates.\r\n   * dev only.\r\n   */\r\n  ownerInstance?: ComponentInternalInstance\r\n}\r\n\r\nexport type SchedulerJobs = SchedulerJob | SchedulerJob[]\r\n\r\nlet isFlushing = false\r\nlet isFlushPending = false\r\n\r\nconst queue: SchedulerJob[] = []\r\nlet flushIndex = 0\r\n\r\nconst pendingPostFlushCbs: SchedulerJob[] = []\r\nlet activePostFlushCbs: SchedulerJob[] | null = null\r\nlet postFlushIndex = 0\r\n\r\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\r\nlet currentFlushPromise: Promise<void> | null = null\r\n\r\nconst RECURSION_LIMIT = 100\r\ntype CountMap = Map<SchedulerJob, number>\r\n\r\nexport function nextTick<T = void, R = void>(\r\n  this: T,\r\n  fn?: (this: T) => R\r\n): Promise<Awaited<R>> {\r\n  const p = currentFlushPromise || resolvedPromise\r\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\r\n}\r\n\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(id: number) {\r\n  // the start index should be `flushIndex + 1`\r\n  let start = flushIndex + 1\r\n  let end = queue.length\r\n\r\n  while (start < end) {\r\n    const middle = (start + end) >>> 1\r\n    const middleJob = queue[middle]\r\n    const middleJobId = getId(middleJob)\r\n    if (middleJobId < id || (middleJobId === id && middleJob.pre)) {\r\n      start = middle + 1\r\n    } else {\r\n      end = middle\r\n    }\r\n  }\r\n\r\n  return start\r\n}\r\n\r\nexport function queueJob(job: SchedulerJob) {\r\n  // the dedupe search uses the startIndex argument of Array.includes()\r\n  // by default the search index includes the current job that is being run\r\n  // so it cannot recursively trigger itself again.\r\n  // if the job is a watch() callback, the search will start with a +1 index to\r\n  // allow it recursively trigger itself - it is the user's responsibility to\r\n  // ensure it doesn't end up in an infinite loop.\r\n  if (\r\n    !queue.length ||\r\n    !queue.includes(\r\n      job,\r\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\r\n    )\r\n  ) {\r\n    if (job.id == null) {\r\n      queue.push(job)\r\n    } else {\r\n      queue.splice(findInsertionIndex(job.id), 0, job)\r\n    }\r\n    queueFlush()\r\n  }\r\n}\r\n\r\nfunction queueFlush() {\r\n  if (!isFlushing && !isFlushPending) {\r\n    isFlushPending = true\r\n    currentFlushPromise = resolvedPromise.then(flushJobs)\r\n  }\r\n}\r\n\r\nexport function invalidateJob(job: SchedulerJob) {\r\n  const i = queue.indexOf(job)\r\n  if (i > flushIndex) {\r\n    queue.splice(i, 1)\r\n  }\r\n}\r\n\r\nexport function queuePostFlushCb(cb: SchedulerJobs) {\r\n  if (!isArray(cb)) {\r\n    if (\r\n      !activePostFlushCbs ||\r\n      !activePostFlushCbs.includes(\r\n        cb,\r\n        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex\r\n      )\r\n    ) {\r\n      pendingPostFlushCbs.push(cb)\r\n    }\r\n  } else {\r\n    // if cb is an array, it is a component lifecycle hook which can only be\r\n    // triggered by a job, which is already deduped in the main queue, so\r\n    // we can skip duplicate check here to improve perf\r\n    pendingPostFlushCbs.push(...cb)\r\n  }\r\n  queueFlush()\r\n}\r\n\r\nexport function flushPreFlushCbs(\r\n  instance?: ComponentInternalInstance,\r\n  seen?: CountMap,\r\n  // if currently flushing, skip the current job itself\r\n  i = isFlushing ? flushIndex + 1 : 0\r\n) {\r\n  if (__DEV__) {\r\n    seen = seen || new Map()\r\n  }\r\n  for (; i < queue.length; i++) {\r\n    const cb = queue[i]\r\n    if (cb && cb.pre) {\r\n      if (instance && cb.id !== instance.uid) {\r\n        continue\r\n      }\r\n      if (__DEV__ && checkRecursiveUpdates(seen!, cb)) {\r\n        continue\r\n      }\r\n      queue.splice(i, 1)\r\n      i--\r\n      cb()\r\n    }\r\n  }\r\n}\r\n\r\nexport function flushPostFlushCbs(seen?: CountMap) {\r\n  if (pendingPostFlushCbs.length) {\r\n    const deduped = [...new Set(pendingPostFlushCbs)]\r\n    pendingPostFlushCbs.length = 0\r\n\r\n    // #1947 already has active queue, nested flushPostFlushCbs call\r\n    if (activePostFlushCbs) {\r\n      activePostFlushCbs.push(...deduped)\r\n      return\r\n    }\r\n\r\n    activePostFlushCbs = deduped\r\n    if (__DEV__) {\r\n      seen = seen || new Map()\r\n    }\r\n\r\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\r\n\r\n    for (\r\n      postFlushIndex = 0;\r\n      postFlushIndex < activePostFlushCbs.length;\r\n      postFlushIndex++\r\n    ) {\r\n      if (\r\n        __DEV__ &&\r\n        checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])\r\n      ) {\r\n        continue\r\n      }\r\n      activePostFlushCbs[postFlushIndex]()\r\n    }\r\n    activePostFlushCbs = null\r\n    postFlushIndex = 0\r\n  }\r\n}\r\n\r\nconst getId = (job: SchedulerJob): number =>\r\n  job.id == null ? Infinity : job.id\r\n\r\nconst comparator = (a: SchedulerJob, b: SchedulerJob): number => {\r\n  const diff = getId(a) - getId(b)\r\n  if (diff === 0) {\r\n    if (a.pre && !b.pre) return -1\r\n    if (b.pre && !a.pre) return 1\r\n  }\r\n  return diff\r\n}\r\n\r\nfunction flushJobs(seen?: CountMap) {\r\n  isFlushPending = false\r\n  isFlushing = true\r\n  if (__DEV__) {\r\n    seen = seen || new Map()\r\n  }\r\n\r\n  // Sort queue before flush.\r\n  // This ensures that:\r\n  // 1. Components are updated from parent to child. (because parent is always\r\n  //    created before the child so its render effect will have smaller\r\n  //    priority number)\r\n  // 2. If a component is unmounted during a parent component's update,\r\n  //    its update can be skipped.\r\n  queue.sort(comparator)\r\n\r\n  // conditional usage of checkRecursiveUpdate must be determined out of\r\n  // try ... catch block since Rollup by default de-optimizes treeshaking\r\n  // inside try-catch. This can leave all warning code unshaked. Although\r\n  // they would get eventually shaken by a minifier like terser, some minifiers\r\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\r\n  const check = __DEV__\r\n    ? (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)\r\n    : NOOP\r\n\r\n  try {\r\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n      const job = queue[flushIndex]\r\n      if (job && job.active !== false) {\r\n        if (__DEV__ && check(job)) {\r\n          continue\r\n        }\r\n        // console.log(`running:`, job.id)\r\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\r\n      }\r\n    }\r\n  } finally {\r\n    flushIndex = 0\r\n    queue.length = 0\r\n\r\n    flushPostFlushCbs(seen)\r\n\r\n    isFlushing = false\r\n    currentFlushPromise = null\r\n    // some postFlushCb queued jobs!\r\n    // keep flushing until it drains.\r\n    if (queue.length || pendingPostFlushCbs.length) {\r\n      flushJobs(seen)\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {\r\n  if (!seen.has(fn)) {\r\n    seen.set(fn, 1)\r\n  } else {\r\n    const count = seen.get(fn)!\r\n    if (count > RECURSION_LIMIT) {\r\n      const instance = fn.ownerInstance\r\n      const componentName = instance && getComponentName(instance.type)\r\n      warn(\r\n        `Maximum recursive updates exceeded${\r\n          componentName ? ` in component <${componentName}>` : ``\r\n        }. ` +\r\n          `This means you have a reactive effect that is mutating its own ` +\r\n          `dependencies and thus recursively triggering itself. Possible sources ` +\r\n          `include component template, render function, updated hook or ` +\r\n          `watcher source function.`\r\n      )\r\n      return true\r\n    } else {\r\n      seen.set(fn, count + 1)\r\n    }\r\n  }\r\n}\r\n", "/* eslint-disable no-restricted-globals */\r\nimport {\r\n  ConcreteComponent,\r\n  ComponentInternalInstance,\r\n  ComponentOptions,\r\n  InternalRenderFunction,\r\n  ClassComponent,\r\n  isClassComponent\r\n} from './component'\r\nimport { queueJob, queuePostFlushCb } from './scheduler'\r\nimport { extend, getGlobalThis } from '@vue/shared'\r\n\r\ntype HMRComponent = ComponentOptions | ClassComponent\r\n\r\nexport let isHmrUpdating = false\r\n\r\nexport const hmrDirtyComponents = new Set<ConcreteComponent>()\r\n\r\nexport interface HMRRuntime {\r\n  createRecord: typeof createRecord\r\n  rerender: typeof rerender\r\n  reload: typeof reload\r\n}\r\n\r\n// Expose the HMR runtime on the global object\r\n// This makes it entirely tree-shakable without polluting the exports and makes\r\n// it easier to be used in toolings like vue-loader\r\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\r\n// to be set so that its instances can be registered / removed.\r\nif (__DEV__) {\r\n  getGlobalThis().__VUE_HMR_RUNTIME__ = {\r\n    createRecord: tryWrap(createRecord),\r\n    rerender: tryWrap(rerender),\r\n    reload: tryWrap(reload)\r\n  } as HMRRuntime\r\n}\r\n\r\nconst map: Map<\r\n  string,\r\n  {\r\n    // the initial component definition is recorded on import - this allows us\r\n    // to apply hot updates to the component even when there are no actively\r\n    // rendered instance.\r\n    initialDef: ComponentOptions\r\n    instances: Set<ComponentInternalInstance>\r\n  }\r\n> = new Map()\r\n\r\nexport function registerHMR(instance: ComponentInternalInstance) {\r\n  const id = instance.type.__hmrId!\r\n  let record = map.get(id)\r\n  if (!record) {\r\n    createRecord(id, instance.type as HMRComponent)\r\n    record = map.get(id)!\r\n  }\r\n  record.instances.add(instance)\r\n}\r\n\r\nexport function unregisterHMR(instance: ComponentInternalInstance) {\r\n  map.get(instance.type.__hmrId!)!.instances.delete(instance)\r\n}\r\n\r\nfunction createRecord(id: string, initialDef: HMRComponent): boolean {\r\n  if (map.has(id)) {\r\n    return false\r\n  }\r\n  map.set(id, {\r\n    initialDef: normalizeClassComponent(initialDef),\r\n    instances: new Set()\r\n  })\r\n  return true\r\n}\r\n\r\nfunction normalizeClassComponent(component: HMRComponent): ComponentOptions {\r\n  return isClassComponent(component) ? component.__vccOpts : component\r\n}\r\n\r\nfunction rerender(id: string, newRender?: Function) {\r\n  const record = map.get(id)\r\n  if (!record) {\r\n    return\r\n  }\r\n\r\n  // update initial record (for not-yet-rendered component)\r\n  record.initialDef.render = newRender\r\n\r\n  // Create a snapshot which avoids the set being mutated during updates\r\n  ;[...record.instances].forEach(instance => {\r\n    if (newRender) {\r\n      instance.render = newRender as InternalRenderFunction\r\n      normalizeClassComponent(instance.type as HMRComponent).render = newRender\r\n    }\r\n    instance.renderCache = []\r\n    // this flag forces child components with slot content to update\r\n    isHmrUpdating = true\r\n    instance.update()\r\n    isHmrUpdating = false\r\n  })\r\n}\r\n\r\nfunction reload(id: string, newComp: HMRComponent) {\r\n  const record = map.get(id)\r\n  if (!record) return\r\n\r\n  newComp = normalizeClassComponent(newComp)\r\n  // update initial def (for not-yet-rendered components)\r\n  updateComponentDef(record.initialDef, newComp)\r\n\r\n  // create a snapshot which avoids the set being mutated during updates\r\n  const instances = [...record.instances]\r\n\r\n  for (const instance of instances) {\r\n    const oldComp = normalizeClassComponent(instance.type as HMRComponent)\r\n\r\n    if (!hmrDirtyComponents.has(oldComp)) {\r\n      // 1. Update existing comp definition to match new one\r\n      if (oldComp !== record.initialDef) {\r\n        updateComponentDef(oldComp, newComp)\r\n      }\r\n      // 2. mark definition dirty. This forces the renderer to replace the\r\n      // component on patch.\r\n      hmrDirtyComponents.add(oldComp)\r\n    }\r\n\r\n    // 3. invalidate options resolution cache\r\n    instance.appContext.propsCache.delete(instance.type as any)\r\n    instance.appContext.emitsCache.delete(instance.type as any)\r\n    instance.appContext.optionsCache.delete(instance.type as any)\r\n\r\n    // 4. actually update\r\n    if (instance.ceReload) {\r\n      // custom element\r\n      hmrDirtyComponents.add(oldComp)\r\n      instance.ceReload((newComp as any).styles)\r\n      hmrDirtyComponents.delete(oldComp)\r\n    } else if (instance.parent) {\r\n      // 4. Force the parent instance to re-render. This will cause all updated\r\n      // components to be unmounted and re-mounted. Queue the update so that we\r\n      // don't end up forcing the same parent to re-render multiple times.\r\n      queueJob(instance.parent.update)\r\n    } else if (instance.appContext.reload) {\r\n      // root instance mounted via createApp() has a reload method\r\n      instance.appContext.reload()\r\n    } else if (typeof window !== 'undefined') {\r\n      // root instance inside tree created via raw render(). Force reload.\r\n      window.location.reload()\r\n    } else {\r\n      console.warn(\r\n        '[HMR] Root or manually mounted instance modified. Full reload required.'\r\n      )\r\n    }\r\n  }\r\n\r\n  // 5. make sure to cleanup dirty hmr components after update\r\n  queuePostFlushCb(() => {\r\n    for (const instance of instances) {\r\n      hmrDirtyComponents.delete(\r\n        normalizeClassComponent(instance.type as HMRComponent)\r\n      )\r\n    }\r\n  })\r\n}\r\n\r\nfunction updateComponentDef(\r\n  oldComp: ComponentOptions,\r\n  newComp: ComponentOptions\r\n) {\r\n  extend(oldComp, newComp)\r\n  for (const key in oldComp) {\r\n    if (key !== '__file' && !(key in newComp)) {\r\n      delete oldComp[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction tryWrap(fn: (id: string, arg: any) => any): Function {\r\n  return (id: string, arg: any) => {\r\n    try {\r\n      return fn(id, arg)\r\n    } catch (e: any) {\r\n      console.error(e)\r\n      console.warn(\r\n        `[HMR] Something went wrong during Vue component hot-reload. ` +\r\n          `Full reload required.`\r\n      )\r\n    }\r\n  }\r\n}\r\n", "/* eslint-disable no-restricted-globals */\r\nimport { App } from './apiCreateApp'\r\nimport { Fragment, Text, Comment, Static } from './vnode'\r\nimport { ComponentInternalInstance } from './component'\r\n\r\ninterface AppRecord {\r\n  id: number\r\n  app: App\r\n  version: string\r\n  types: Record<string, string | Symbol>\r\n}\r\n\r\nconst enum DevtoolsHooks {\r\n  APP_INIT = 'app:init',\r\n  APP_UNMOUNT = 'app:unmount',\r\n  COMPONENT_UPDATED = 'component:updated',\r\n  COMPONENT_ADDED = 'component:added',\r\n  COMPONENT_REMOVED = 'component:removed',\r\n  COMPONENT_EMIT = 'component:emit',\r\n  PERFORMANCE_START = 'perf:start',\r\n  PERFORMANCE_END = 'perf:end'\r\n}\r\n\r\ninterface DevtoolsHook {\r\n  enabled?: boolean\r\n  emit: (event: string, ...payload: any[]) => void\r\n  on: (event: string, handler: Function) => void\r\n  once: (event: string, handler: Function) => void\r\n  off: (event: string, handler: Function) => void\r\n  appRecords: AppRecord[]\r\n  /**\r\n   * Added at https://github.com/vuejs/devtools/commit/f2ad51eea789006ab66942e5a27c0f0986a257f9\r\n   * Returns whether the arg was buffered or not\r\n   */\r\n  cleanupBuffer?: (matchArg: unknown) => boolean\r\n}\r\n\r\nexport let devtools: DevtoolsHook\r\n\r\nlet buffer: { event: string; args: any[] }[] = []\r\n\r\nlet devtoolsNotInstalled = false\r\n\r\nfunction emit(event: string, ...args: any[]) {\r\n  if (devtools) {\r\n    devtools.emit(event, ...args)\r\n  } else if (!devtoolsNotInstalled) {\r\n    buffer.push({ event, args })\r\n  }\r\n}\r\n\r\nexport function setDevtoolsHook(hook: DevtoolsHook, target: any) {\r\n  devtools = hook\r\n  if (devtools) {\r\n    devtools.enabled = true\r\n    buffer.forEach(({ event, args }) => devtools.emit(event, ...args))\r\n    buffer = []\r\n  } else if (\r\n    // handle late devtools injection - only do this if we are in an actual\r\n    // browser environment to avoid the timer handle stalling test runner exit\r\n    // (#4815)\r\n    typeof window !== 'undefined' &&\r\n    // some envs mock window but not fully\r\n    window.HTMLElement &&\r\n    // also exclude jsdom\r\n    !window.navigator?.userAgent?.includes('jsdom')\r\n  ) {\r\n    const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\r\n      target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [])\r\n    replay.push((newHook: DevtoolsHook) => {\r\n      setDevtoolsHook(newHook, target)\r\n    })\r\n    // clear buffer after 3s - the user probably doesn't have devtools installed\r\n    // at all, and keeping the buffer will cause memory leaks (#4738)\r\n    setTimeout(() => {\r\n      if (!devtools) {\r\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null\r\n        devtoolsNotInstalled = true\r\n        buffer = []\r\n      }\r\n    }, 3000)\r\n  } else {\r\n    // non-browser env, assume not installed\r\n    devtoolsNotInstalled = true\r\n    buffer = []\r\n  }\r\n}\r\n\r\nexport function devtoolsInitApp(app: App, version: string) {\r\n  emit(DevtoolsHooks.APP_INIT, app, version, {\r\n    Fragment,\r\n    Text,\r\n    Comment,\r\n    Static\r\n  })\r\n}\r\n\r\nexport function devtoolsUnmountApp(app: App) {\r\n  emit(DevtoolsHooks.APP_UNMOUNT, app)\r\n}\r\n\r\nexport const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\r\n  DevtoolsHooks.COMPONENT_ADDED\r\n)\r\n\r\nexport const devtoolsComponentUpdated =\r\n  /*#__PURE__*/ createDevtoolsComponentHook(DevtoolsHooks.COMPONENT_UPDATED)\r\n\r\nconst _devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(\r\n  DevtoolsHooks.COMPONENT_REMOVED\r\n)\r\n\r\nexport const devtoolsComponentRemoved = (\r\n  component: ComponentInternalInstance\r\n) => {\r\n  if (\r\n    devtools &&\r\n    typeof devtools.cleanupBuffer === 'function' &&\r\n    // remove the component if it wasn't buffered\r\n    !devtools.cleanupBuffer(component)\r\n  ) {\r\n    _devtoolsComponentRemoved(component)\r\n  }\r\n}\r\n\r\nfunction createDevtoolsComponentHook(hook: DevtoolsHooks) {\r\n  return (component: ComponentInternalInstance) => {\r\n    emit(\r\n      hook,\r\n      component.appContext.app,\r\n      component.uid,\r\n      component.parent ? component.parent.uid : undefined,\r\n      component\r\n    )\r\n  }\r\n}\r\n\r\nexport const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(\r\n  DevtoolsHooks.PERFORMANCE_START\r\n)\r\n\r\nexport const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(\r\n  DevtoolsHooks.PERFORMANCE_END\r\n)\r\n\r\nfunction createDevtoolsPerformanceHook(hook: DevtoolsHooks) {\r\n  return (component: ComponentInternalInstance, type: string, time: number) => {\r\n    emit(hook, component.appContext.app, component.uid, component, type, time)\r\n  }\r\n}\r\n\r\nexport function devtoolsComponentEmit(\r\n  component: ComponentInternalInstance,\r\n  event: string,\r\n  params: any[]\r\n) {\r\n  emit(\r\n    DevtoolsHooks.COMPONENT_EMIT,\r\n    component.appContext.app,\r\n    component,\r\n    event,\r\n    params\r\n  )\r\n}\r\n", "import { extend, hasOwn, isArray, isFunction } from '@vue/shared'\r\nimport {\r\n  Component,\r\n  ComponentInternalInstance,\r\n  ComponentOptions,\r\n  formatComponentName,\r\n  getComponentName,\r\n  getCurrentInstance,\r\n  isRuntimeOnly\r\n} from '../component'\r\nimport { warn } from '../warning'\r\n\r\nexport const enum DeprecationTypes {\r\n  GLOBAL_MOUNT = 'GLOBAL_MOUNT',\r\n  GLOBAL_MOUNT_CONTAINER = 'GLOBAL_MOUNT_CONTAINER',\r\n  GLOBAL_EXTEND = 'GLOBAL_EXTEND',\r\n  GLOBAL_PROTOTYPE = 'GLOBAL_PROTOTYPE',\r\n  GLOBAL_SET = 'GLOBAL_SET',\r\n  GLOBAL_DELETE = 'GLOBAL_DELETE',\r\n  GLOBAL_OBSERVABLE = 'GLOBAL_OBSERVABLE',\r\n  GLOBAL_PRIVATE_UTIL = 'GLOBAL_PRIVATE_UTIL',\r\n\r\n  CONFIG_SILENT = 'CONFIG_SILENT',\r\n  CONFIG_DEVTOOLS = 'CONFIG_DEVTOOLS',\r\n  CONFIG_KEY_CODES = 'CONFIG_KEY_CODES',\r\n  CONFIG_PRODUCTION_TIP = 'CONFIG_PRODUCTION_TIP',\r\n  CONFIG_IGNORED_ELEMENTS = 'CONFIG_IGNORED_ELEMENTS',\r\n  CONFIG_WHITESPACE = 'CONFIG_WHITESPACE',\r\n  CONFIG_OPTION_MERGE_STRATS = 'CONFIG_OPTION_MERGE_STRATS',\r\n\r\n  INSTANCE_SET = 'INSTANCE_SET',\r\n  INSTANCE_DELETE = 'INSTANCE_DELETE',\r\n  INSTANCE_DESTROY = 'INSTANCE_DESTROY',\r\n  INSTANCE_EVENT_EMITTER = 'INSTANCE_EVENT_EMITTER',\r\n  INSTANCE_EVENT_HOOKS = 'INSTANCE_EVENT_HOOKS',\r\n  INSTANCE_CHILDREN = 'INSTANCE_CHILDREN',\r\n  INSTANCE_LISTENERS = 'INSTANCE_LISTENERS',\r\n  INSTANCE_SCOPED_SLOTS = 'INSTANCE_SCOPED_SLOTS',\r\n  INSTANCE_ATTRS_CLASS_STYLE = 'INSTANCE_ATTRS_CLASS_STYLE',\r\n\r\n  OPTIONS_DATA_FN = 'OPTIONS_DATA_FN',\r\n  OPTIONS_DATA_MERGE = 'OPTIONS_DATA_MERGE',\r\n  OPTIONS_BEFORE_DESTROY = 'OPTIONS_BEFORE_DESTROY',\r\n  OPTIONS_DESTROYED = 'OPTIONS_DESTROYED',\r\n\r\n  WATCH_ARRAY = 'WATCH_ARRAY',\r\n  PROPS_DEFAULT_THIS = 'PROPS_DEFAULT_THIS',\r\n\r\n  V_ON_KEYCODE_MODIFIER = 'V_ON_KEYCODE_MODIFIER',\r\n  CUSTOM_DIR = 'CUSTOM_DIR',\r\n\r\n  ATTR_FALSE_VALUE = 'ATTR_FALSE_VALUE',\r\n  ATTR_ENUMERATED_COERCION = 'ATTR_ENUMERATED_COERCION',\r\n\r\n  TRANSITION_CLASSES = 'TRANSITION_CLASSES',\r\n  TRANSITION_GROUP_ROOT = 'TRANSITION_GROUP_ROOT',\r\n\r\n  COMPONENT_ASYNC = 'COMPONENT_ASYNC',\r\n  COMPONENT_FUNCTIONAL = 'COMPONENT_FUNCTIONAL',\r\n  COMPONENT_V_MODEL = 'COMPONENT_V_MODEL',\r\n\r\n  RENDER_FUNCTION = 'RENDER_FUNCTION',\r\n\r\n  FILTERS = 'FILTERS',\r\n\r\n  PRIVATE_APIS = 'PRIVATE_APIS'\r\n}\r\n\r\ntype DeprecationData = {\r\n  message: string | ((...args: any[]) => string)\r\n  link?: string\r\n}\r\n\r\nexport const deprecationData: Record<DeprecationTypes, DeprecationData> = {\r\n  [DeprecationTypes.GLOBAL_MOUNT]: {\r\n    message:\r\n      `The global app bootstrapping API has changed: vm.$mount() and the \"el\" ` +\r\n      `option have been removed. Use createApp(RootComponent).mount() instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#mounting-app-instance`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_MOUNT_CONTAINER]: {\r\n    message:\r\n      `Vue detected directives on the mount container. ` +\r\n      `In Vue 3, the container is no longer considered part of the template ` +\r\n      `and will not be processed/replaced.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/mount-changes.html`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_EXTEND]: {\r\n    message:\r\n      `Vue.extend() has been removed in Vue 3. ` +\r\n      `Use defineComponent() instead.`,\r\n    link: `https://vuejs.org/api/general.html#definecomponent`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_PROTOTYPE]: {\r\n    message:\r\n      `Vue.prototype is no longer available in Vue 3. ` +\r\n      `Use app.config.globalProperties instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#vue-prototype-replaced-by-config-globalproperties`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_SET]: {\r\n    message:\r\n      `Vue.set() has been removed as it is no longer needed in Vue 3. ` +\r\n      `Simply use native JavaScript mutations.`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_DELETE]: {\r\n    message:\r\n      `Vue.delete() has been removed as it is no longer needed in Vue 3. ` +\r\n      `Simply use native JavaScript mutations.`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_OBSERVABLE]: {\r\n    message:\r\n      `Vue.observable() has been removed. ` +\r\n      `Use \\`import { reactive } from \"vue\"\\` from Composition API instead.`,\r\n    link: `https://vuejs.org/api/reactivity-core.html#reactive`\r\n  },\r\n\r\n  [DeprecationTypes.GLOBAL_PRIVATE_UTIL]: {\r\n    message:\r\n      `Vue.util has been removed. Please refactor to avoid its usage ` +\r\n      `since it was an internal API even in Vue 2.`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_SILENT]: {\r\n    message:\r\n      `config.silent has been removed because it is not good practice to ` +\r\n      `intentionally suppress warnings. You can use your browser console's ` +\r\n      `filter features to focus on relevant messages.`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_DEVTOOLS]: {\r\n    message:\r\n      `config.devtools has been removed. To enable devtools for ` +\r\n      `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,\r\n    link: `https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_KEY_CODES]: {\r\n    message:\r\n      `config.keyCodes has been removed. ` +\r\n      `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_PRODUCTION_TIP]: {\r\n    message: `config.productionTip has been removed.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_IGNORED_ELEMENTS]: {\r\n    message: () => {\r\n      let msg = `config.ignoredElements has been removed.`\r\n      if (isRuntimeOnly()) {\r\n        msg += ` Pass the \"isCustomElement\" option to @vue/compiler-dom instead.`\r\n      } else {\r\n        msg += ` Use config.isCustomElement instead.`\r\n      }\r\n      return msg\r\n    },\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_WHITESPACE]: {\r\n    // this warning is only relevant in the full build when using runtime\r\n    // compilation, so it's put in the runtime compatConfig list.\r\n    message:\r\n      `Vue 3 compiler's whitespace option will default to \"condense\" instead of ` +\r\n      `\"preserve\". To suppress this warning, provide an explicit value for ` +\r\n      `\\`config.compilerOptions.whitespace\\`.`\r\n  },\r\n\r\n  [DeprecationTypes.CONFIG_OPTION_MERGE_STRATS]: {\r\n    message:\r\n      `config.optionMergeStrategies no longer exposes internal strategies. ` +\r\n      `Use custom merge functions instead.`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_SET]: {\r\n    message:\r\n      `vm.$set() has been removed as it is no longer needed in Vue 3. ` +\r\n      `Simply use native JavaScript mutations.`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_DELETE]: {\r\n    message:\r\n      `vm.$delete() has been removed as it is no longer needed in Vue 3. ` +\r\n      `Simply use native JavaScript mutations.`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_DESTROY]: {\r\n    message: `vm.$destroy() has been removed. Use app.unmount() instead.`,\r\n    link: `https://vuejs.org/api/application.html#app-unmount`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_EVENT_EMITTER]: {\r\n    message:\r\n      `vm.$on/$once/$off() have been removed. ` +\r\n      `Use an external event emitter library instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/events-api.html`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_EVENT_HOOKS]: {\r\n    message: event =>\r\n      `\"${event}\" lifecycle events are no longer supported. From templates, ` +\r\n      `use the \"vue:\" prefix instead of \"hook:\". For example, @${event} ` +\r\n      `should be changed to @vue:${event.slice(5)}. ` +\r\n      `From JavaScript, use Composition API to dynamically register lifecycle ` +\r\n      `hooks.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/vnode-lifecycle-events.html`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_CHILDREN]: {\r\n    message:\r\n      `vm.$children has been removed. Consider refactoring your logic ` +\r\n      `to avoid relying on direct access to child components.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/children.html`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_LISTENERS]: {\r\n    message:\r\n      `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` +\r\n      `included in vm.$attrs and it is no longer necessary to separately use ` +\r\n      `v-on=\"$listeners\" if you are already using v-bind=\"$attrs\". ` +\r\n      `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_SCOPED_SLOTS]: {\r\n    message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/slots-unification.html`\r\n  },\r\n\r\n  [DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE]: {\r\n    message: componentName =>\r\n      `Component <${\r\n        componentName || 'Anonymous'\r\n      }> has \\`inheritAttrs: false\\` but is ` +\r\n      `relying on class/style fallthrough from parent. In Vue 3, class/style ` +\r\n      `are now included in $attrs and will no longer fallthrough when ` +\r\n      `inheritAttrs is false. If you are already using v-bind=\"$attrs\" on ` +\r\n      `component root it should render the same end result. ` +\r\n      `If you are binding $attrs to a non-root element and expecting ` +\r\n      `class/style to fallthrough on root, you will need to now manually bind ` +\r\n      `them on root via :class=\"$attrs.class\".`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/attrs-includes-class-style.html`\r\n  },\r\n\r\n  [DeprecationTypes.OPTIONS_DATA_FN]: {\r\n    message:\r\n      `The \"data\" option can no longer be a plain object. ` +\r\n      `Always use a function.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html`\r\n  },\r\n\r\n  [DeprecationTypes.OPTIONS_DATA_MERGE]: {\r\n    message: (key: string) =>\r\n      `Detected conflicting key \"${key}\" when merging data option values. ` +\r\n      `In Vue 3, data keys are merged shallowly and will override one another.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html#mixin-merge-behavior-change`\r\n  },\r\n\r\n  [DeprecationTypes.OPTIONS_BEFORE_DESTROY]: {\r\n    message: `\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`\r\n  },\r\n\r\n  [DeprecationTypes.OPTIONS_DESTROYED]: {\r\n    message: `\\`destroyed\\` has been renamed to \\`unmounted\\`.`\r\n  },\r\n\r\n  [DeprecationTypes.WATCH_ARRAY]: {\r\n    message:\r\n      `\"watch\" option or vm.$watch on an array value will no longer ` +\r\n      `trigger on array mutation unless the \"deep\" option is specified. ` +\r\n      `If current usage is intended, you can disable the compat behavior and ` +\r\n      `suppress this warning with:` +\r\n      `\\n\\n  configureCompat({ ${DeprecationTypes.WATCH_ARRAY}: false })\\n`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/watch.html`\r\n  },\r\n\r\n  [DeprecationTypes.PROPS_DEFAULT_THIS]: {\r\n    message: (key: string) =>\r\n      `props default value function no longer has access to \"this\". The compat ` +\r\n      `build only offers access to this.$options.` +\r\n      `(found in prop \"${key}\")`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/props-default-this.html`\r\n  },\r\n\r\n  [DeprecationTypes.CUSTOM_DIR]: {\r\n    message: (legacyHook: string, newHook: string) =>\r\n      `Custom directive hook \"${legacyHook}\" has been removed. ` +\r\n      `Use \"${newHook}\" instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-directives.html`\r\n  },\r\n\r\n  [DeprecationTypes.V_ON_KEYCODE_MODIFIER]: {\r\n    message:\r\n      `Using keyCode as v-on modifier is no longer supported. ` +\r\n      `Use kebab-case key name modifiers instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`\r\n  },\r\n\r\n  [DeprecationTypes.ATTR_FALSE_VALUE]: {\r\n    message: (name: string) =>\r\n      `Attribute \"${name}\" with v-bind value \\`false\\` will render ` +\r\n      `${name}=\"false\" instead of removing it in Vue 3. To remove the attribute, ` +\r\n      `use \\`null\\` or \\`undefined\\` instead. If the usage is intended, ` +\r\n      `you can disable the compat behavior and suppress this warning with:` +\r\n      `\\n\\n  configureCompat({ ${DeprecationTypes.ATTR_FALSE_VALUE}: false })\\n`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`\r\n  },\r\n\r\n  [DeprecationTypes.ATTR_ENUMERATED_COERCION]: {\r\n    message: (name: string, value: any, coerced: string) =>\r\n      `Enumerated attribute \"${name}\" with v-bind value \\`${value}\\` will ` +\r\n      `${\r\n        value === null ? `be removed` : `render the value as-is`\r\n      } instead of coercing the value to \"${coerced}\" in Vue 3. ` +\r\n      `Always use explicit \"true\" or \"false\" values for enumerated attributes. ` +\r\n      `If the usage is intended, ` +\r\n      `you can disable the compat behavior and suppress this warning with:` +\r\n      `\\n\\n  configureCompat({ ${DeprecationTypes.ATTR_ENUMERATED_COERCION}: false })\\n`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`\r\n  },\r\n\r\n  [DeprecationTypes.TRANSITION_CLASSES]: {\r\n    message: `` // this feature cannot be runtime-detected\r\n  },\r\n\r\n  [DeprecationTypes.TRANSITION_GROUP_ROOT]: {\r\n    message:\r\n      `<TransitionGroup> no longer renders a root <span> element by ` +\r\n      `default if no \"tag\" prop is specified. If you do not rely on the span ` +\r\n      `for styling, you can disable the compat behavior and suppress this ` +\r\n      `warning with:` +\r\n      `\\n\\n  configureCompat({ ${DeprecationTypes.TRANSITION_GROUP_ROOT}: false })\\n`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/transition-group.html`\r\n  },\r\n\r\n  [DeprecationTypes.COMPONENT_ASYNC]: {\r\n    message: (comp: any) => {\r\n      const name = getComponentName(comp)\r\n      return (\r\n        `Async component${\r\n          name ? ` <${name}>` : `s`\r\n        } should be explicitly created via \\`defineAsyncComponent()\\` ` +\r\n        `in Vue 3. Plain functions will be treated as functional components in ` +\r\n        `non-compat build. If you have already migrated all async component ` +\r\n        `usage and intend to use plain functions for functional components, ` +\r\n        `you can disable the compat behavior and suppress this ` +\r\n        `warning with:` +\r\n        `\\n\\n  configureCompat({ ${DeprecationTypes.COMPONENT_ASYNC}: false })\\n`\r\n      )\r\n    },\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/async-components.html`\r\n  },\r\n\r\n  [DeprecationTypes.COMPONENT_FUNCTIONAL]: {\r\n    message: (comp: any) => {\r\n      const name = getComponentName(comp)\r\n      return (\r\n        `Functional component${\r\n          name ? ` <${name}>` : `s`\r\n        } should be defined as a plain function in Vue 3. The \"functional\" ` +\r\n        `option has been removed. NOTE: Before migrating to use plain ` +\r\n        `functions for functional components, first make sure that all async ` +\r\n        `components usage have been migrated and its compat behavior has ` +\r\n        `been disabled.`\r\n      )\r\n    },\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/functional-components.html`\r\n  },\r\n\r\n  [DeprecationTypes.COMPONENT_V_MODEL]: {\r\n    message: (comp: ComponentOptions) => {\r\n      const configMsg =\r\n        `opt-in to ` +\r\n        `Vue 3 behavior on a per-component basis with \\`compatConfig: { ${DeprecationTypes.COMPONENT_V_MODEL}: false }\\`.`\r\n      if (\r\n        comp.props &&\r\n        (isArray(comp.props)\r\n          ? comp.props.includes('modelValue')\r\n          : hasOwn(comp.props, 'modelValue'))\r\n      ) {\r\n        return (\r\n          `Component declares \"modelValue\" prop, which is Vue 3 usage, but ` +\r\n          `is running under Vue 2 compat v-model behavior. You can ${configMsg}`\r\n        )\r\n      }\r\n      return (\r\n        `v-model usage on component has changed in Vue 3. Component that expects ` +\r\n        `to work with v-model should now use the \"modelValue\" prop and emit the ` +\r\n        `\"update:modelValue\" event. You can update the usage and then ${configMsg}`\r\n      )\r\n    },\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\r\n  },\r\n\r\n  [DeprecationTypes.RENDER_FUNCTION]: {\r\n    message:\r\n      `Vue 3's render function API has changed. ` +\r\n      `You can opt-in to the new API with:` +\r\n      `\\n\\n  configureCompat({ ${DeprecationTypes.RENDER_FUNCTION}: false })\\n` +\r\n      `\\n  (This can also be done per-component via the \"compatConfig\" option.)`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/render-function-api.html`\r\n  },\r\n\r\n  [DeprecationTypes.FILTERS]: {\r\n    message:\r\n      `filters have been removed in Vue 3. ` +\r\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\r\n      `Use method calls or computed properties instead.`,\r\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\r\n  },\r\n\r\n  [DeprecationTypes.PRIVATE_APIS]: {\r\n    message: name =>\r\n      `\"${name}\" is a Vue 2 private API that no longer exists in Vue 3. ` +\r\n      `If you are seeing this warning only due to a dependency, you can ` +\r\n      `suppress this warning via { PRIVATE_APIS: 'suppress-warning' }.`\r\n  }\r\n}\r\n\r\nconst instanceWarned: Record<string, true> = Object.create(null)\r\nconst warnCount: Record<string, number> = Object.create(null)\r\n\r\n// test only\r\nlet warningEnabled = true\r\n\r\nexport function toggleDeprecationWarning(flag: boolean) {\r\n  warningEnabled = flag\r\n}\r\n\r\nexport function warnDeprecation(\r\n  key: DeprecationTypes,\r\n  instance: ComponentInternalInstance | null,\r\n  ...args: any[]\r\n) {\r\n  if (!__DEV__) {\r\n    return\r\n  }\r\n  if (__TEST__ && !warningEnabled) {\r\n    return\r\n  }\r\n\r\n  instance = instance || getCurrentInstance()\r\n\r\n  // check user config\r\n  const config = getCompatConfigForKey(key, instance)\r\n  if (config === 'suppress-warning') {\r\n    return\r\n  }\r\n\r\n  const dupKey = key + args.join('')\r\n  let compId: string | number | null =\r\n    instance && formatComponentName(instance, instance.type)\r\n  if (compId === 'Anonymous' && instance) {\r\n    compId = instance.uid\r\n  }\r\n\r\n  // skip if the same warning is emitted for the same component type\r\n  const componentDupKey = dupKey + compId\r\n  if (!__TEST__ && componentDupKey in instanceWarned) {\r\n    return\r\n  }\r\n  instanceWarned[componentDupKey] = true\r\n\r\n  // same warning, but different component. skip the long message and just\r\n  // log the key and count.\r\n  if (!__TEST__ && dupKey in warnCount) {\r\n    warn(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`)\r\n    return\r\n  }\r\n\r\n  warnCount[dupKey] = 0\r\n\r\n  const { message, link } = deprecationData[key]\r\n  warn(\r\n    `(deprecation ${key}) ${\r\n      typeof message === 'function' ? message(...args) : message\r\n    }${link ? `\\n  Details: ${link}` : ``}`\r\n  )\r\n  if (!isCompatEnabled(key, instance, true)) {\r\n    console.error(\r\n      `^ The above deprecation's compat behavior is disabled and will likely ` +\r\n        `lead to runtime errors.`\r\n    )\r\n  }\r\n}\r\n\r\nexport type CompatConfig = Partial<\r\n  Record<DeprecationTypes, boolean | 'suppress-warning'>\r\n> & {\r\n  MODE?: 2 | 3 | ((comp: Component | null) => 2 | 3)\r\n}\r\n\r\nexport const globalCompatConfig: CompatConfig = {\r\n  MODE: 2\r\n}\r\n\r\nexport function configureCompat(config: CompatConfig) {\r\n  if (__DEV__) {\r\n    validateCompatConfig(config)\r\n  }\r\n  extend(globalCompatConfig, config)\r\n}\r\n\r\nconst seenConfigObjects = /*#__PURE__*/ new WeakSet<CompatConfig>()\r\nconst warnedInvalidKeys: Record<string, boolean> = {}\r\n\r\n// dev only\r\nexport function validateCompatConfig(\r\n  config: CompatConfig,\r\n  instance?: ComponentInternalInstance\r\n) {\r\n  if (seenConfigObjects.has(config)) {\r\n    return\r\n  }\r\n  seenConfigObjects.add(config)\r\n\r\n  for (const key of Object.keys(config)) {\r\n    if (\r\n      key !== 'MODE' &&\r\n      !(key in deprecationData) &&\r\n      !(key in warnedInvalidKeys)\r\n    ) {\r\n      if (key.startsWith('COMPILER_')) {\r\n        if (isRuntimeOnly()) {\r\n          warn(\r\n            `Deprecation config \"${key}\" is compiler-specific and you are ` +\r\n              `running a runtime-only build of Vue. This deprecation should be ` +\r\n              `configured via compiler options in your build setup instead.\\n` +\r\n              `Details: https://v3-migration.vuejs.org/breaking-changes/migration-build.html`\r\n          )\r\n        }\r\n      } else {\r\n        warn(`Invalid deprecation config \"${key}\".`)\r\n      }\r\n      warnedInvalidKeys[key] = true\r\n    }\r\n  }\r\n\r\n  if (instance && config[DeprecationTypes.OPTIONS_DATA_MERGE] != null) {\r\n    warn(\r\n      `Deprecation config \"${DeprecationTypes.OPTIONS_DATA_MERGE}\" can only be configured globally.`\r\n    )\r\n  }\r\n}\r\n\r\nexport function getCompatConfigForKey(\r\n  key: DeprecationTypes | 'MODE',\r\n  instance: ComponentInternalInstance | null\r\n) {\r\n  const instanceConfig =\r\n    instance && (instance.type as ComponentOptions).compatConfig\r\n  if (instanceConfig && key in instanceConfig) {\r\n    return instanceConfig[key]\r\n  }\r\n  return globalCompatConfig[key]\r\n}\r\n\r\nexport function isCompatEnabled(\r\n  key: DeprecationTypes,\r\n  instance: ComponentInternalInstance | null,\r\n  enableForBuiltIn = false\r\n): boolean {\r\n  // skip compat for built-in components\r\n  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {\r\n    return false\r\n  }\r\n\r\n  const rawMode = getCompatConfigForKey('MODE', instance) || 2\r\n  const val = getCompatConfigForKey(key, instance)\r\n\r\n  const mode = isFunction(rawMode)\r\n    ? rawMode(instance && instance.type)\r\n    : rawMode\r\n\r\n  if (mode === 2) {\r\n    return val !== false\r\n  } else {\r\n    return val === true || val === 'suppress-warning'\r\n  }\r\n}\r\n\r\n/**\r\n * Use this for features that are completely removed in non-compat build.\r\n */\r\nexport function assertCompatEnabled(\r\n  key: DeprecationTypes,\r\n  instance: ComponentInternalInstance | null,\r\n  ...args: any[]\r\n) {\r\n  if (!isCompatEnabled(key, instance)) {\r\n    throw new Error(`${key} compat has been disabled.`)\r\n  } else if (__DEV__) {\r\n    warnDeprecation(key, instance, ...args)\r\n  }\r\n}\r\n\r\n/**\r\n * Use this for features where legacy usage is still possible, but will likely\r\n * lead to runtime error if compat is disabled. (warn in all cases)\r\n */\r\nexport function softAssertCompatEnabled(\r\n  key: DeprecationTypes,\r\n  instance: ComponentInternalInstance | null,\r\n  ...args: any[]\r\n) {\r\n  if (__DEV__) {\r\n    warnDeprecation(key, instance, ...args)\r\n  }\r\n  return isCompatEnabled(key, instance)\r\n}\r\n\r\n/**\r\n * Use this for features with the same syntax but with mutually exclusive\r\n * behavior in 2 vs 3. Only warn if compat is enabled.\r\n * e.g. render function\r\n */\r\nexport function checkCompatEnabled(\r\n  key: DeprecationTypes,\r\n  instance: ComponentInternalInstance | null,\r\n  ...args: any[]\r\n) {\r\n  const enabled = isCompatEnabled(key, instance)\r\n  if (__DEV__ && enabled) {\r\n    warnDeprecation(key, instance, ...args)\r\n  }\r\n  return enabled\r\n}\r\n\r\n// run tests in v3 mode by default\r\nif (__TEST__) {\r\n  configureCompat({\r\n    MODE: 3\r\n  })\r\n}\r\n", "import {\r\n  camelize,\r\n  EMPTY_OBJ,\r\n  toHandlerKey,\r\n  extend,\r\n  hasOwn,\r\n  hyphenate,\r\n  isArray,\r\n  isFunction,\r\n  isObject,\r\n  isString,\r\n  isOn,\r\n  UnionToIntersection,\r\n  looseToNumber\r\n} from '@vue/shared'\r\nimport {\r\n  ComponentInternalInstance,\r\n  ComponentOptions,\r\n  ConcreteComponent,\r\n  formatComponentName\r\n} from './component'\r\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\r\nimport { warn } from './warning'\r\nimport { devtoolsComponentEmit } from './devtools'\r\nimport { AppContext } from './apiCreateApp'\r\nimport { emit as compatInstanceEmit } from './compat/instanceEventEmitter'\r\nimport {\r\n  compatModelEventPrefix,\r\n  compatModelEmit\r\n} from './compat/componentVModel'\r\n\r\nexport type ObjectEmitsOptions = Record<\r\n  string,\r\n  ((...args: any[]) => any) | null\r\n>\r\n\r\nexport type EmitsOptions = ObjectEmitsOptions | string[]\r\n\r\nexport type EmitsToProps<T extends EmitsOptions> = T extends string[]\r\n  ? {\r\n      [K in `on${Capitalize<T[number]>}`]?: (...args: any[]) => any\r\n    }\r\n  : T extends ObjectEmitsOptions\r\n    ? {\r\n        [K in `on${Capitalize<string & keyof T>}`]?: K extends `on${infer C}`\r\n          ? (\r\n              ...args: T[Uncapitalize<C>] extends (...args: infer P) => any\r\n                ? P\r\n                : T[Uncapitalize<C>] extends null\r\n                  ? any[]\r\n                  : never\r\n            ) => any\r\n          : never\r\n      }\r\n    : {}\r\n\r\nexport type EmitFn<\r\n  Options = ObjectEmitsOptions,\r\n  Event extends keyof Options = keyof Options\r\n> = Options extends Array<infer V>\r\n  ? (event: V, ...args: any[]) => void\r\n  : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function\r\n    ? (event: string, ...args: any[]) => void\r\n    : UnionToIntersection<\r\n        {\r\n          [key in Event]: Options[key] extends (...args: infer Args) => any\r\n            ? (event: key, ...args: Args) => void\r\n            : (event: key, ...args: any[]) => void\r\n        }[Event]\r\n      >\r\n\r\nexport function emit(\r\n  instance: ComponentInternalInstance,\r\n  event: string,\r\n  ...rawArgs: any[]\r\n) {\r\n  if (instance.isUnmounted) return\r\n  const props = instance.vnode.props || EMPTY_OBJ\r\n\r\n  if (__DEV__) {\r\n    const {\r\n      emitsOptions,\r\n      propsOptions: [propsOptions]\r\n    } = instance\r\n    if (emitsOptions) {\r\n      if (\r\n        !(event in emitsOptions) &&\r\n        !(\r\n          __COMPAT__ &&\r\n          (event.startsWith('hook:') ||\r\n            event.startsWith(compatModelEventPrefix))\r\n        )\r\n      ) {\r\n        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\r\n          warn(\r\n            `Component emitted event \"${event}\" but it is neither declared in ` +\r\n              `the emits option nor as an \"${toHandlerKey(event)}\" prop.`\r\n          )\r\n        }\r\n      } else {\r\n        const validator = emitsOptions[event]\r\n        if (isFunction(validator)) {\r\n          const isValid = validator(...rawArgs)\r\n          if (!isValid) {\r\n            warn(\r\n              `Invalid event arguments: event validation failed for event \"${event}\".`\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let args = rawArgs\r\n  const isModelListener = event.startsWith('update:')\r\n\r\n  // for v-model update:xxx events, apply modifiers on args\r\n  const modelArg = isModelListener && event.slice(7)\r\n  if (modelArg && modelArg in props) {\r\n    const modifiersKey = `${\r\n      modelArg === 'modelValue' ? 'model' : modelArg\r\n    }Modifiers`\r\n    const { number, trim } = props[modifiersKey] || EMPTY_OBJ\r\n    if (trim) {\r\n      args = rawArgs.map(a => (isString(a) ? a.trim() : a))\r\n    }\r\n    if (number) {\r\n      args = rawArgs.map(looseToNumber)\r\n    }\r\n  }\r\n\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    devtoolsComponentEmit(instance, event, args)\r\n  }\r\n\r\n  if (__DEV__) {\r\n    const lowerCaseEvent = event.toLowerCase()\r\n    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\r\n      warn(\r\n        `Event \"${lowerCaseEvent}\" is emitted in component ` +\r\n          `${formatComponentName(\r\n            instance,\r\n            instance.type\r\n          )} but the handler is registered for \"${event}\". ` +\r\n          `Note that HTML attributes are case-insensitive and you cannot use ` +\r\n          `v-on to listen to camelCase events when using in-DOM templates. ` +\r\n          `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`\r\n      )\r\n    }\r\n  }\r\n\r\n  let handlerName\r\n  let handler =\r\n    props[(handlerName = toHandlerKey(event))] ||\r\n    // also try camelCase event handler (#2249)\r\n    props[(handlerName = toHandlerKey(camelize(event)))]\r\n  // for v-model update:xxx events, also trigger kebab-case equivalent\r\n  // for props passed via kebab-case\r\n  if (!handler && isModelListener) {\r\n    handler = props[(handlerName = toHandlerKey(hyphenate(event)))]\r\n  }\r\n\r\n  if (handler) {\r\n    callWithAsyncErrorHandling(\r\n      handler,\r\n      instance,\r\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\r\n      args\r\n    )\r\n  }\r\n\r\n  const onceHandler = props[handlerName + `Once`]\r\n  if (onceHandler) {\r\n    if (!instance.emitted) {\r\n      instance.emitted = {}\r\n    } else if (instance.emitted[handlerName]) {\r\n      return\r\n    }\r\n    instance.emitted[handlerName] = true\r\n    callWithAsyncErrorHandling(\r\n      onceHandler,\r\n      instance,\r\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\r\n      args\r\n    )\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    compatModelEmit(instance, event, args)\r\n    return compatInstanceEmit(instance, event, args)\r\n  }\r\n}\r\n\r\nexport function normalizeEmitsOptions(\r\n  comp: ConcreteComponent,\r\n  appContext: AppContext,\r\n  asMixin = false\r\n): ObjectEmitsOptions | null {\r\n  const cache = appContext.emitsCache\r\n  const cached = cache.get(comp)\r\n  if (cached !== undefined) {\r\n    return cached\r\n  }\r\n\r\n  const raw = comp.emits\r\n  let normalized: ObjectEmitsOptions = {}\r\n\r\n  // apply mixin/extends props\r\n  let hasExtends = false\r\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\r\n    const extendEmits = (raw: ComponentOptions) => {\r\n      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true)\r\n      if (normalizedFromExtend) {\r\n        hasExtends = true\r\n        extend(normalized, normalizedFromExtend)\r\n      }\r\n    }\r\n    if (!asMixin && appContext.mixins.length) {\r\n      appContext.mixins.forEach(extendEmits)\r\n    }\r\n    if (comp.extends) {\r\n      extendEmits(comp.extends)\r\n    }\r\n    if (comp.mixins) {\r\n      comp.mixins.forEach(extendEmits)\r\n    }\r\n  }\r\n\r\n  if (!raw && !hasExtends) {\r\n    if (isObject(comp)) {\r\n      cache.set(comp, null)\r\n    }\r\n    return null\r\n  }\r\n\r\n  if (isArray(raw)) {\r\n    raw.forEach(key => (normalized[key] = null))\r\n  } else {\r\n    extend(normalized, raw)\r\n  }\r\n\r\n  if (isObject(comp)) {\r\n    cache.set(comp, normalized)\r\n  }\r\n  return normalized\r\n}\r\n\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nexport function isEmitListener(\r\n  options: ObjectEmitsOptions | null,\r\n  key: string\r\n): boolean {\r\n  if (!options || !isOn(key)) {\r\n    return false\r\n  }\r\n\r\n  if (__COMPAT__ && key.startsWith(compatModelEventPrefix)) {\r\n    return true\r\n  }\r\n\r\n  key = key.slice(2).replace(/Once$/, '')\r\n  return (\r\n    hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n    hasOwn(options, hyphenate(key)) ||\r\n    hasOwn(options, key)\r\n  )\r\n}\r\n", "import { ComponentInternalInstance } from './component'\r\nimport { devtoolsComponentUpdated } from './devtools'\r\nimport { setBlockTracking } from './vnode'\r\n\r\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nexport let currentRenderingInstance: ComponentInternalInstance | null = null\r\nexport let currentScopeId: string | null = null\r\n\r\n/**\r\n * Note: rendering calls maybe nested. The function returns the parent rendering\r\n * instance if present, which should be restored after the render is done:\r\n *\r\n * ```js\r\n * const prev = setCurrentRenderingInstance(i)\r\n * // ...render\r\n * setCurrentRenderingInstance(prev)\r\n * ```\r\n */\r\nexport function setCurrentRenderingInstance(\r\n  instance: ComponentInternalInstance | null\r\n): ComponentInternalInstance | null {\r\n  const prev = currentRenderingInstance\r\n  currentRenderingInstance = instance\r\n  currentScopeId = (instance && instance.type.__scopeId) || null\r\n  // v2 pre-compiled components uses _scopeId instead of __scopeId\r\n  if (__COMPAT__ && !currentScopeId) {\r\n    currentScopeId = (instance && (instance.type as any)._scopeId) || null\r\n  }\r\n  return prev\r\n}\r\n\r\n/**\r\n * Set scope id when creating hoisted vnodes.\r\n * @private compiler helper\r\n */\r\nexport function pushScopeId(id: string | null) {\r\n  currentScopeId = id\r\n}\r\n\r\n/**\r\n * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n * API for backwards compat w/ code generated by compilers.\r\n * @private\r\n */\r\nexport function popScopeId() {\r\n  currentScopeId = null\r\n}\r\n\r\n/**\r\n * Only for backwards compat\r\n * @private\r\n */\r\nexport const withScopeId = (_id: string) => withCtx\r\n\r\nexport type ContextualRenderFn = {\r\n  (...args: any[]): any\r\n  _n: boolean /* already normalized */\r\n  _c: boolean /* compiled */\r\n  _d: boolean /* disableTracking */\r\n  _ns: boolean /* nonScoped */\r\n}\r\n\r\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private compiler helper\r\n */\r\nexport function withCtx(\r\n  fn: Function,\r\n  ctx: ComponentInternalInstance | null = currentRenderingInstance,\r\n  isNonScopedSlot?: boolean // __COMPAT__ only\r\n) {\r\n  if (!ctx) return fn\r\n\r\n  // already normalized\r\n  if ((fn as ContextualRenderFn)._n) {\r\n    return fn\r\n  }\r\n\r\n  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {\r\n    // If a user calls a compiled slot inside a template expression (#1745), it\r\n    // can mess up block tracking, so by default we disable block tracking and\r\n    // force bail out when invoking a compiled slot (indicated by the ._d flag).\r\n    // This isn't necessary if rendering a compiled `<slot>`, so we flip the\r\n    // ._d flag off when invoking the wrapped fn inside `renderSlot`.\r\n    if (renderFnWithContext._d) {\r\n      setBlockTracking(-1)\r\n    }\r\n    const prevInstance = setCurrentRenderingInstance(ctx)\r\n    let res\r\n    try {\r\n      res = fn(...args)\r\n    } finally {\r\n      setCurrentRenderingInstance(prevInstance)\r\n      if (renderFnWithContext._d) {\r\n        setBlockTracking(1)\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      devtoolsComponentUpdated(ctx)\r\n    }\r\n\r\n    return res\r\n  }\r\n\r\n  // mark normalized to avoid duplicated wrapping\r\n  renderFnWithContext._n = true\r\n  // mark this as compiled by default\r\n  // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n  // rendering flag.\r\n  renderFnWithContext._c = true\r\n  // disable block tracking by default\r\n  renderFnWithContext._d = true\r\n  // compat build only flag to distinguish scoped slots from non-scoped ones\r\n  if (__COMPAT__ && isNonScopedSlot) {\r\n    renderFnWithContext._ns = true\r\n  }\r\n  return renderFnWithContext\r\n}\r\n", "import {\r\n  ComponentInternalInstance,\r\n  FunctionalComponent,\r\n  Data,\r\n  getComponentName\r\n} from './component'\r\nimport {\r\n  VNode,\r\n  normalizeVNode,\r\n  createVNode,\r\n  Comment,\r\n  cloneVNode,\r\n  VNodeArrayChildren,\r\n  isVNode,\r\n  blockStack\r\n} from './vnode'\r\nimport { handleError, ErrorCodes } from './errorHandling'\r\nimport { PatchFlags, ShapeFlags, isOn, isModelListener } from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport { isHmrUpdating } from './hmr'\r\nimport { NormalizedProps } from './componentProps'\r\nimport { isEmitListener } from './componentEmits'\r\nimport { setCurrentRenderingInstance } from './componentRenderContext'\r\nimport {\r\n  DeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation\r\n} from './compat/compatConfig'\r\n\r\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs: boolean = false\r\n\r\nexport function markAttrsAccessed() {\r\n  accessedAttrs = true\r\n}\r\n\r\ntype SetRootFn = ((root: VNode) => void) | undefined\r\n\r\nexport function renderComponentRoot(\r\n  instance: ComponentInternalInstance\r\n): VNode {\r\n  const {\r\n    type: Component,\r\n    vnode,\r\n    proxy,\r\n    withProxy,\r\n    props,\r\n    propsOptions: [propsOptions],\r\n    slots,\r\n    attrs,\r\n    emit,\r\n    render,\r\n    renderCache,\r\n    data,\r\n    setupState,\r\n    ctx,\r\n    inheritAttrs\r\n  } = instance\r\n\r\n  let result\r\n  let fallthroughAttrs\r\n  const prev = setCurrentRenderingInstance(instance)\r\n  if (__DEV__) {\r\n    accessedAttrs = false\r\n  }\r\n\r\n  try {\r\n    if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\r\n      // withProxy is a proxy with a different `has` trap only for\r\n      // runtime-compiled render functions using `with` block.\r\n      const proxyToUse = withProxy || proxy\r\n      // 'this' isn't available in production builds with `<script setup>`,\r\n      // so warn if it's used in dev.\r\n      const thisProxy =\r\n        __DEV__ && setupState.__isScriptSetup\r\n          ? new Proxy(proxyToUse!, {\r\n              get(target, key, receiver) {\r\n                warn(\r\n                  `Property '${String(\r\n                    key\r\n                  )}' was accessed via 'this'. Avoid using 'this' in templates.`\r\n                )\r\n                return Reflect.get(target, key, receiver)\r\n              }\r\n            })\r\n          : proxyToUse\r\n      result = normalizeVNode(\r\n        render!.call(\r\n          thisProxy,\r\n          proxyToUse!,\r\n          renderCache,\r\n          props,\r\n          setupState,\r\n          data,\r\n          ctx\r\n        )\r\n      )\r\n      fallthroughAttrs = attrs\r\n    } else {\r\n      // functional\r\n      const render = Component as FunctionalComponent\r\n      // in dev, mark attrs accessed if optional props (attrs === props)\r\n      if (__DEV__ && attrs === props) {\r\n        markAttrsAccessed()\r\n      }\r\n      result = normalizeVNode(\r\n        render.length > 1\r\n          ? render(\r\n              props,\r\n              __DEV__\r\n                ? {\r\n                    get attrs() {\r\n                      markAttrsAccessed()\r\n                      return attrs\r\n                    },\r\n                    slots,\r\n                    emit\r\n                  }\r\n                : { attrs, slots, emit }\r\n            )\r\n          : render(props, null as any /* we know it doesn't need it */)\r\n      )\r\n      fallthroughAttrs = Component.props\r\n        ? attrs\r\n        : getFunctionalFallthrough(attrs)\r\n    }\r\n  } catch (err) {\r\n    blockStack.length = 0\r\n    handleError(err, instance, ErrorCodes.RENDER_FUNCTION)\r\n    result = createVNode(Comment)\r\n  }\r\n\r\n  // attr merging\r\n  // in dev mode, comments are preserved, and it's possible for a template\r\n  // to have comments along side the root element which makes it a fragment\r\n  let root = result\r\n  let setRoot: SetRootFn = undefined\r\n  if (\r\n    __DEV__ &&\r\n    result.patchFlag > 0 &&\r\n    result.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n  ) {\r\n    ;[root, setRoot] = getChildRoot(result)\r\n  }\r\n\r\n  if (fallthroughAttrs && inheritAttrs !== false) {\r\n    const keys = Object.keys(fallthroughAttrs)\r\n    const { shapeFlag } = root\r\n    if (keys.length) {\r\n      if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)) {\r\n        if (propsOptions && keys.some(isModelListener)) {\r\n          // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n          // prop, it indicates this component expects to handle v-model and\r\n          // it should not fallthrough.\r\n          // related: #1543, #1643, #1989\r\n          fallthroughAttrs = filterModelListeners(\r\n            fallthroughAttrs,\r\n            propsOptions\r\n          )\r\n        }\r\n        root = cloneVNode(root, fallthroughAttrs)\r\n      } else if (__DEV__ && !accessedAttrs && root.type !== Comment) {\r\n        const allAttrs = Object.keys(attrs)\r\n        const eventAttrs: string[] = []\r\n        const extraAttrs: string[] = []\r\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\r\n          const key = allAttrs[i]\r\n          if (isOn(key)) {\r\n            // ignore v-model handlers when they fail to fallthrough\r\n            if (!isModelListener(key)) {\r\n              // remove `on`, lowercase first letter to reflect event casing\r\n              // accurately\r\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3))\r\n            }\r\n          } else {\r\n            extraAttrs.push(key)\r\n          }\r\n        }\r\n        if (extraAttrs.length) {\r\n          warn(\r\n            `Extraneous non-props attributes (` +\r\n              `${extraAttrs.join(', ')}) ` +\r\n              `were passed to component but could not be automatically inherited ` +\r\n              `because component renders fragment or text root nodes.`\r\n          )\r\n        }\r\n        if (eventAttrs.length) {\r\n          warn(\r\n            `Extraneous non-emits event listeners (` +\r\n              `${eventAttrs.join(', ')}) ` +\r\n              `were passed to component but could not be automatically inherited ` +\r\n              `because component renders fragment or text root nodes. ` +\r\n              `If the listener is intended to be a component custom event listener only, ` +\r\n              `declare it using the \"emits\" option.`\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    __COMPAT__ &&\r\n    isCompatEnabled(DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE, instance) &&\r\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT &&\r\n    root.shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)\r\n  ) {\r\n    const { class: cls, style } = vnode.props || {}\r\n    if (cls || style) {\r\n      if (__DEV__ && inheritAttrs === false) {\r\n        warnDeprecation(\r\n          DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE,\r\n          instance,\r\n          getComponentName(instance.type)\r\n        )\r\n      }\r\n      root = cloneVNode(root, {\r\n        class: cls,\r\n        style: style\r\n      })\r\n    }\r\n  }\r\n\r\n  // inherit directives\r\n  if (vnode.dirs) {\r\n    if (__DEV__ && !isElementRoot(root)) {\r\n      warn(\r\n        `Runtime directive used on component with non-element root node. ` +\r\n          `The directives will not function as intended.`\r\n      )\r\n    }\r\n    // clone before mutating since the root may be a hoisted vnode\r\n    root = cloneVNode(root)\r\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs\r\n  }\r\n  // inherit transition data\r\n  if (vnode.transition) {\r\n    if (__DEV__ && !isElementRoot(root)) {\r\n      warn(\r\n        `Component inside <Transition> renders non-element root node ` +\r\n          `that cannot be animated.`\r\n      )\r\n    }\r\n    root.transition = vnode.transition\r\n  }\r\n\r\n  if (__DEV__ && setRoot) {\r\n    setRoot(root)\r\n  } else {\r\n    result = root\r\n  }\r\n\r\n  setCurrentRenderingInstance(prev)\r\n  return result\r\n}\r\n\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode: VNode): [VNode, SetRootFn] => {\r\n  const rawChildren = vnode.children as VNodeArrayChildren\r\n  const dynamicChildren = vnode.dynamicChildren\r\n  const childRoot = filterSingleRoot(rawChildren)\r\n  if (!childRoot) {\r\n    return [vnode, undefined]\r\n  }\r\n  const index = rawChildren.indexOf(childRoot)\r\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1\r\n  const setRoot: SetRootFn = (updatedRoot: VNode) => {\r\n    rawChildren[index] = updatedRoot\r\n    if (dynamicChildren) {\r\n      if (dynamicIndex > -1) {\r\n        dynamicChildren[dynamicIndex] = updatedRoot\r\n      } else if (updatedRoot.patchFlag > 0) {\r\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot]\r\n      }\r\n    }\r\n  }\r\n  return [normalizeVNode(childRoot), setRoot]\r\n}\r\n\r\nexport function filterSingleRoot(\r\n  children: VNodeArrayChildren\r\n): VNode | undefined {\r\n  let singleRoot\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    if (isVNode(child)) {\r\n      // ignore user comment\r\n      if (child.type !== Comment || child.children === 'v-if') {\r\n        if (singleRoot) {\r\n          // has more than 1 non-comment child, return now\r\n          return\r\n        } else {\r\n          singleRoot = child\r\n        }\r\n      }\r\n    } else {\r\n      return\r\n    }\r\n  }\r\n  return singleRoot\r\n}\r\n\r\nconst getFunctionalFallthrough = (attrs: Data): Data | undefined => {\r\n  let res: Data | undefined\r\n  for (const key in attrs) {\r\n    if (key === 'class' || key === 'style' || isOn(key)) {\r\n      ;(res || (res = {}))[key] = attrs[key]\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nconst filterModelListeners = (attrs: Data, props: NormalizedProps): Data => {\r\n  const res: Data = {}\r\n  for (const key in attrs) {\r\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\r\n      res[key] = attrs[key]\r\n    }\r\n  }\r\n  return res\r\n}\r\n\r\nconst isElementRoot = (vnode: VNode) => {\r\n  return (\r\n    vnode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.ELEMENT) ||\r\n    vnode.type === Comment // potential v-if branch switch\r\n  )\r\n}\r\n\r\nexport function shouldUpdateComponent(\r\n  prevVNode: VNode,\r\n  nextVNode: VNode,\r\n  optimized?: boolean\r\n): boolean {\r\n  const { props: prevProps, children: prevChildren, component } = prevVNode\r\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode\r\n  const emits = component!.emitsOptions\r\n\r\n  // Parent component's render function was hot-updated. Since this may have\r\n  // caused the child component's slots content to have changed, we need to\r\n  // force the child to update as well.\r\n  if (__DEV__ && (prevChildren || nextChildren) && isHmrUpdating) {\r\n    return true\r\n  }\r\n\r\n  // force child update for runtime directive or transition on component vnode.\r\n  if (nextVNode.dirs || nextVNode.transition) {\r\n    return true\r\n  }\r\n\r\n  if (optimized && patchFlag >= 0) {\r\n    if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {\r\n      // slot content that references values that might have changed,\r\n      // e.g. in a v-for\r\n      return true\r\n    }\r\n    if (patchFlag & PatchFlags.FULL_PROPS) {\r\n      if (!prevProps) {\r\n        return !!nextProps\r\n      }\r\n      // presence of this flag indicates props are always non-null\r\n      return hasPropsChanged(prevProps, nextProps!, emits)\r\n    } else if (patchFlag & PatchFlags.PROPS) {\r\n      const dynamicProps = nextVNode.dynamicProps!\r\n      for (let i = 0; i < dynamicProps.length; i++) {\r\n        const key = dynamicProps[i]\r\n        if (\r\n          nextProps![key] !== prevProps![key] &&\r\n          !isEmitListener(emits, key)\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    // this path is only taken by manually written render functions\r\n    // so presence of any children leads to a forced update\r\n    if (prevChildren || nextChildren) {\r\n      if (!nextChildren || !(nextChildren as any).$stable) {\r\n        return true\r\n      }\r\n    }\r\n    if (prevProps === nextProps) {\r\n      return false\r\n    }\r\n    if (!prevProps) {\r\n      return !!nextProps\r\n    }\r\n    if (!nextProps) {\r\n      return true\r\n    }\r\n    return hasPropsChanged(prevProps, nextProps, emits)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfunction hasPropsChanged(\r\n  prevProps: Data,\r\n  nextProps: Data,\r\n  emitsOptions: ComponentInternalInstance['emitsOptions']\r\n): boolean {\r\n  const nextKeys = Object.keys(nextProps)\r\n  if (nextKeys.length !== Object.keys(prevProps).length) {\r\n    return true\r\n  }\r\n  for (let i = 0; i < nextKeys.length; i++) {\r\n    const key = nextKeys[i]\r\n    if (\r\n      nextProps[key] !== prevProps[key] &&\r\n      !isEmitListener(emitsOptions, key)\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function updateHOCHostEl(\r\n  { vnode, parent }: ComponentInternalInstance,\r\n  el: typeof vnode.el // HostNode\r\n) {\r\n  while (parent && parent.subTree === vnode) {\r\n    ;(vnode = parent.vnode).el = el\r\n    parent = parent.parent\r\n  }\r\n}\r\n", "import {\r\n  isRef,\r\n  isShallow,\r\n  Ref,\r\n  ComputedRef,\r\n  ReactiveEffect,\r\n  isReactive,\r\n  ReactiveFlags,\r\n  EffectScheduler,\r\n  DebuggerOptions,\r\n  getCurrentScope\r\n} from '@vue/reactivity'\r\nimport { SchedulerJob, queueJob } from './scheduler'\r\nimport {\r\n  EMPTY_OBJ,\r\n  isObject,\r\n  isArray,\r\n  isFunction,\r\n  isString,\r\n  hasChanged,\r\n  NOOP,\r\n  remove,\r\n  isMap,\r\n  isSet,\r\n  isPlainObject,\r\n  extend\r\n} from '@vue/shared'\r\nimport {\r\n  currentInstance,\r\n  ComponentInternalInstance,\r\n  isInSSRComponentSetup,\r\n  setCurrentInstance,\r\n  unsetCurrentInstance\r\n} from './component'\r\nimport {\r\n  ErrorCodes,\r\n  callWithErrorHandling,\r\n  callWithAsyncErrorHandling\r\n} from './errorHandling'\r\nimport { queuePostRenderEffect } from './renderer'\r\nimport { warn } from './warning'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport { checkCompatEnabled, isCompatEnabled } from './compat/compatConfig'\r\nimport { ObjectWatchOptionItem } from './componentOptions'\r\nimport { useSSRContext } from '@vue/runtime-core'\r\n\r\nexport type WatchEffect = (onCleanup: OnCleanup) => void\r\n\r\nexport type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T)\r\n\r\nexport type WatchCallback<V = any, OV = any> = (\r\n  value: V,\r\n  oldValue: OV,\r\n  onCleanup: OnCleanup\r\n) => any\r\n\r\ntype MapSources<T, Immediate> = {\r\n  [K in keyof T]: T[K] extends WatchSource<infer V>\r\n    ? Immediate extends true\r\n      ? V | undefined\r\n      : V\r\n    : T[K] extends object\r\n      ? Immediate extends true\r\n        ? T[K] | undefined\r\n        : T[K]\r\n      : never\r\n}\r\n\r\ntype OnCleanup = (cleanupFn: () => void) => void\r\n\r\nexport interface WatchOptionsBase extends DebuggerOptions {\r\n  flush?: 'pre' | 'post' | 'sync'\r\n}\r\n\r\nexport interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {\r\n  immediate?: Immediate\r\n  deep?: boolean\r\n}\r\n\r\nexport type WatchStopHandle = () => void\r\n\r\n// Simple effect.\r\nexport function watchEffect(\r\n  effect: WatchEffect,\r\n  options?: WatchOptionsBase\r\n): WatchStopHandle {\r\n  return doWatch(effect, null, options)\r\n}\r\n\r\nexport function watchPostEffect(\r\n  effect: WatchEffect,\r\n  options?: DebuggerOptions\r\n) {\r\n  return doWatch(\r\n    effect,\r\n    null,\r\n    __DEV__ ? extend({}, options as any, { flush: 'post' }) : { flush: 'post' }\r\n  )\r\n}\r\n\r\nexport function watchSyncEffect(\r\n  effect: WatchEffect,\r\n  options?: DebuggerOptions\r\n) {\r\n  return doWatch(\r\n    effect,\r\n    null,\r\n    __DEV__ ? extend({}, options as any, { flush: 'sync' }) : { flush: 'sync' }\r\n  )\r\n}\r\n\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {}\r\n\r\ntype MultiWatchSources = (WatchSource<unknown> | object)[]\r\n\r\n// overload: array of multiple sources + cb\r\nexport function watch<\r\n  T extends MultiWatchSources,\r\n  Immediate extends Readonly<boolean> = false\r\n>(\r\n  sources: [...T],\r\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\r\n  options?: WatchOptions<Immediate>\r\n): WatchStopHandle\r\n\r\n// overload: multiple sources w/ `as const`\r\n// watch([foo, bar] as const, () => {})\r\n// somehow [...T] breaks when the type is readonly\r\nexport function watch<\r\n  T extends Readonly<MultiWatchSources>,\r\n  Immediate extends Readonly<boolean> = false\r\n>(\r\n  source: T,\r\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\r\n  options?: WatchOptions<Immediate>\r\n): WatchStopHandle\r\n\r\n// overload: single source + cb\r\nexport function watch<T, Immediate extends Readonly<boolean> = false>(\r\n  source: WatchSource<T>,\r\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\r\n  options?: WatchOptions<Immediate>\r\n): WatchStopHandle\r\n\r\n// overload: watching reactive object w/ cb\r\nexport function watch<\r\n  T extends object,\r\n  Immediate extends Readonly<boolean> = false\r\n>(\r\n  source: T,\r\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\r\n  options?: WatchOptions<Immediate>\r\n): WatchStopHandle\r\n\r\n// implementation\r\nexport function watch<T = any, Immediate extends Readonly<boolean> = false>(\r\n  source: T | WatchSource<T>,\r\n  cb: any,\r\n  options?: WatchOptions<Immediate>\r\n): WatchStopHandle {\r\n  if (__DEV__ && !isFunction(cb)) {\r\n    warn(\r\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\r\n        `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\r\n        `supports \\`watch(source, cb, options?) signature.`\r\n    )\r\n  }\r\n  return doWatch(source as any, cb, options)\r\n}\r\n\r\nfunction doWatch(\r\n  source: WatchSource | WatchSource[] | WatchEffect | object,\r\n  cb: WatchCallback | null,\r\n  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ\r\n): WatchStopHandle {\r\n  if (__DEV__ && !cb) {\r\n    if (immediate !== undefined) {\r\n      warn(\r\n        `watch() \"immediate\" option is only respected when using the ` +\r\n          `watch(source, callback, options?) signature.`\r\n      )\r\n    }\r\n    if (deep !== undefined) {\r\n      warn(\r\n        `watch() \"deep\" option is only respected when using the ` +\r\n          `watch(source, callback, options?) signature.`\r\n      )\r\n    }\r\n  }\r\n\r\n  const warnInvalidSource = (s: unknown) => {\r\n    warn(\r\n      `Invalid watch source: `,\r\n      s,\r\n      `A watch source can only be a getter/effect function, a ref, ` +\r\n        `a reactive object, or an array of these types.`\r\n    )\r\n  }\r\n\r\n  const instance =\r\n    getCurrentScope() === currentInstance?.scope ? currentInstance : null\r\n  // const instance = currentInstance\r\n  let getter: () => any\r\n  let forceTrigger = false\r\n  let isMultiSource = false\r\n\r\n  if (isRef(source)) {\r\n    getter = () => source.value\r\n    forceTrigger = isShallow(source)\r\n  } else if (isReactive(source)) {\r\n    getter = () => source\r\n    deep = true\r\n  } else if (isArray(source)) {\r\n    isMultiSource = true\r\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\r\n    getter = () =>\r\n      source.map(s => {\r\n        if (isRef(s)) {\r\n          return s.value\r\n        } else if (isReactive(s)) {\r\n          return traverse(s)\r\n        } else if (isFunction(s)) {\r\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\r\n        } else {\r\n          __DEV__ && warnInvalidSource(s)\r\n        }\r\n      })\r\n  } else if (isFunction(source)) {\r\n    if (cb) {\r\n      // getter with cb\r\n      getter = () =>\r\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\r\n    } else {\r\n      // no cb -> simple effect\r\n      getter = () => {\r\n        if (instance && instance.isUnmounted) {\r\n          return\r\n        }\r\n        if (cleanup) {\r\n          cleanup()\r\n        }\r\n        return callWithAsyncErrorHandling(\r\n          source,\r\n          instance,\r\n          ErrorCodes.WATCH_CALLBACK,\r\n          [onCleanup]\r\n        )\r\n      }\r\n    }\r\n  } else {\r\n    getter = NOOP\r\n    __DEV__ && warnInvalidSource(source)\r\n  }\r\n\r\n  // 2.x array mutation watch compat\r\n  if (__COMPAT__ && cb && !deep) {\r\n    const baseGetter = getter\r\n    getter = () => {\r\n      const val = baseGetter()\r\n      if (\r\n        isArray(val) &&\r\n        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)\r\n      ) {\r\n        traverse(val)\r\n      }\r\n      return val\r\n    }\r\n  }\r\n\r\n  if (cb && deep) {\r\n    const baseGetter = getter\r\n    getter = () => traverse(baseGetter())\r\n  }\r\n\r\n  let cleanup: (() => void) | undefined\r\n  let onCleanup: OnCleanup = (fn: () => void) => {\r\n    cleanup = effect.onStop = () => {\r\n      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)\r\n      cleanup = effect.onStop = undefined\r\n    }\r\n  }\r\n\r\n  // in SSR there is no need to setup an actual effect, and it should be noop\r\n  // unless it's eager or sync flush\r\n  let ssrCleanup: (() => void)[] | undefined\r\n  if (__SSR__ && isInSSRComponentSetup) {\r\n    // we will also not call the invalidate callback (+ runner is not set up)\r\n    onCleanup = NOOP\r\n    if (!cb) {\r\n      getter()\r\n    } else if (immediate) {\r\n      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\r\n        getter(),\r\n        isMultiSource ? [] : undefined,\r\n        onCleanup\r\n      ])\r\n    }\r\n    if (flush === 'sync') {\r\n      const ctx = useSSRContext()!\r\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = [])\r\n    } else {\r\n      return NOOP\r\n    }\r\n  }\r\n\r\n  let oldValue: any = isMultiSource\r\n    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)\r\n    : INITIAL_WATCHER_VALUE\r\n  const job: SchedulerJob = () => {\r\n    if (!effect.active) {\r\n      return\r\n    }\r\n    if (cb) {\r\n      // watch(source, cb)\r\n      const newValue = effect.run()\r\n      if (\r\n        deep ||\r\n        forceTrigger ||\r\n        (isMultiSource\r\n          ? (newValue as any[]).some((v, i) => hasChanged(v, oldValue[i]))\r\n          : hasChanged(newValue, oldValue)) ||\r\n        (__COMPAT__ &&\r\n          isArray(newValue) &&\r\n          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))\r\n      ) {\r\n        // cleanup before running cb again\r\n        if (cleanup) {\r\n          cleanup()\r\n        }\r\n        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\r\n          newValue,\r\n          // pass undefined as the old value when it's changed for the first time\r\n          oldValue === INITIAL_WATCHER_VALUE\r\n            ? undefined\r\n            : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\r\n              ? []\r\n              : oldValue,\r\n          onCleanup\r\n        ])\r\n        oldValue = newValue\r\n      }\r\n    } else {\r\n      // watchEffect\r\n      effect.run()\r\n    }\r\n  }\r\n\r\n  // important: mark the job as a watcher callback so that scheduler knows\r\n  // it is allowed to self-trigger (#1727)\r\n  job.allowRecurse = !!cb\r\n\r\n  let scheduler: EffectScheduler\r\n  if (flush === 'sync') {\r\n    scheduler = job as any // the scheduler function gets called directly\r\n  } else if (flush === 'post') {\r\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\r\n  } else {\r\n    // default: 'pre'\r\n    job.pre = true\r\n    if (instance) job.id = instance.uid\r\n    scheduler = () => queueJob(job)\r\n  }\r\n\r\n  const effect = new ReactiveEffect(getter, scheduler)\r\n\r\n  if (__DEV__) {\r\n    effect.onTrack = onTrack\r\n    effect.onTrigger = onTrigger\r\n  }\r\n\r\n  // initial run\r\n  if (cb) {\r\n    if (immediate) {\r\n      job()\r\n    } else {\r\n      oldValue = effect.run()\r\n    }\r\n  } else if (flush === 'post') {\r\n    queuePostRenderEffect(\r\n      effect.run.bind(effect),\r\n      instance && instance.suspense\r\n    )\r\n  } else {\r\n    effect.run()\r\n  }\r\n\r\n  const unwatch = () => {\r\n    effect.stop()\r\n    if (instance && instance.scope) {\r\n      remove(instance.scope.effects!, effect)\r\n    }\r\n  }\r\n\r\n  if (__SSR__ && ssrCleanup) ssrCleanup.push(unwatch)\r\n  return unwatch\r\n}\r\n\r\n// this.$watch\r\nexport function instanceWatch(\r\n  this: ComponentInternalInstance,\r\n  source: string | Function,\r\n  value: WatchCallback | ObjectWatchOptionItem,\r\n  options?: WatchOptions\r\n): WatchStopHandle {\r\n  const publicThis = this.proxy as any\r\n  const getter = isString(source)\r\n    ? source.includes('.')\r\n      ? createPathGetter(publicThis, source)\r\n      : () => publicThis[source]\r\n    : source.bind(publicThis, publicThis)\r\n  let cb\r\n  if (isFunction(value)) {\r\n    cb = value\r\n  } else {\r\n    cb = value.handler as Function\r\n    options = value\r\n  }\r\n  const cur = currentInstance\r\n  setCurrentInstance(this)\r\n  const res = doWatch(getter, cb.bind(publicThis), options)\r\n  if (cur) {\r\n    setCurrentInstance(cur)\r\n  } else {\r\n    unsetCurrentInstance()\r\n  }\r\n  return res\r\n}\r\n\r\nexport function createPathGetter(ctx: any, path: string) {\r\n  const segments = path.split('.')\r\n  return () => {\r\n    let cur = ctx\r\n    for (let i = 0; i < segments.length && cur; i++) {\r\n      cur = cur[segments[i]]\r\n    }\r\n    return cur\r\n  }\r\n}\r\n\r\nexport function traverse(value: unknown, seen?: Set<unknown>) {\r\n  if (!isObject(value) || (value as any)[ReactiveFlags.SKIP]) {\r\n    return value\r\n  }\r\n  seen = seen || new Set()\r\n  if (seen.has(value)) {\r\n    return value\r\n  }\r\n  seen.add(value)\r\n  if (isRef(value)) {\r\n    traverse(value.value, seen)\r\n  } else if (isArray(value)) {\r\n    for (let i = 0; i < value.length; i++) {\r\n      traverse(value[i], seen)\r\n    }\r\n  } else if (isSet(value) || isMap(value)) {\r\n    value.forEach((v: any) => {\r\n      traverse(v, seen)\r\n    })\r\n  } else if (isPlainObject(value)) {\r\n    for (const key in value) {\r\n      traverse(value[key], seen)\r\n    }\r\n  }\r\n  return value\r\n}\r\n", "/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\r\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\r\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\n\r\nimport { VNode } from './vnode'\r\nimport { isFunction, EMPTY_OBJ, isBuiltInDirective } from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport { ComponentInternalInstance, Data, getExposeProxy } from './component'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\r\nimport { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { mapCompatDirectiveHook } from './compat/customDirective'\r\nimport { pauseTracking, resetTracking } from '@vue/reactivity'\r\nimport { traverse } from './apiWatch'\r\n\r\nexport interface DirectiveBinding<V = any> {\r\n  instance: ComponentPublicInstance | null\r\n  value: V\r\n  oldValue: V | null\r\n  arg?: string\r\n  modifiers: DirectiveModifiers\r\n  dir: ObjectDirective<any, V>\r\n}\r\n\r\nexport type DirectiveHook<T = any, Prev = VNode<any, T> | null, V = any> = (\r\n  el: T,\r\n  binding: DirectiveBinding<V>,\r\n  vnode: VNode<any, T>,\r\n  prevVNode: Prev\r\n) => void\r\n\r\nexport type SSRDirectiveHook = (\r\n  binding: DirectiveBinding,\r\n  vnode: VNode\r\n) => Data | undefined\r\n\r\nexport interface ObjectDirective<T = any, V = any> {\r\n  created?: DirectiveHook<T, null, V>\r\n  beforeMount?: DirectiveHook<T, null, V>\r\n  mounted?: DirectiveHook<T, null, V>\r\n  beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>\r\n  updated?: DirectiveHook<T, VNode<any, T>, V>\r\n  beforeUnmount?: DirectiveHook<T, null, V>\r\n  unmounted?: DirectiveHook<T, null, V>\r\n  getSSRProps?: SSRDirectiveHook\r\n  deep?: boolean\r\n}\r\n\r\nexport type FunctionDirective<T = any, V = any> = DirectiveHook<T, any, V>\r\n\r\nexport type Directive<T = any, V = any> =\r\n  | ObjectDirective<T, V>\r\n  | FunctionDirective<T, V>\r\n\r\nexport type DirectiveModifiers = Record<string, boolean>\r\n\r\nexport function validateDirectiveName(name: string) {\r\n  if (isBuiltInDirective(name)) {\r\n    warn('Do not use built-in directive ids as custom directive id: ' + name)\r\n  }\r\n}\r\n\r\n// Directive, value, argument, modifiers\r\nexport type DirectiveArguments = Array<\r\n  | [Directive | undefined]\r\n  | [Directive | undefined, any]\r\n  | [Directive | undefined, any, string]\r\n  | [Directive | undefined, any, string, DirectiveModifiers]\r\n>\r\n\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nexport function withDirectives<T extends VNode>(\r\n  vnode: T,\r\n  directives: DirectiveArguments\r\n): T {\r\n  const internalInstance = currentRenderingInstance\r\n  if (internalInstance === null) {\r\n    __DEV__ && warn(`withDirectives can only be used inside render functions.`)\r\n    return vnode\r\n  }\r\n  const instance =\r\n    (getExposeProxy(internalInstance) as ComponentPublicInstance) ||\r\n    internalInstance.proxy\r\n  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])\r\n  for (let i = 0; i < directives.length; i++) {\r\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]\r\n    if (dir) {\r\n      if (isFunction(dir)) {\r\n        dir = {\r\n          mounted: dir,\r\n          updated: dir\r\n        } as ObjectDirective\r\n      }\r\n      if (dir.deep) {\r\n        traverse(value)\r\n      }\r\n      bindings.push({\r\n        dir,\r\n        instance,\r\n        value,\r\n        oldValue: void 0,\r\n        arg,\r\n        modifiers\r\n      })\r\n    }\r\n  }\r\n  return vnode\r\n}\r\n\r\nexport function invokeDirectiveHook(\r\n  vnode: VNode,\r\n  prevVNode: VNode | null,\r\n  instance: ComponentInternalInstance | null,\r\n  name: keyof ObjectDirective\r\n) {\r\n  const bindings = vnode.dirs!\r\n  const oldBindings = prevVNode && prevVNode.dirs!\r\n  for (let i = 0; i < bindings.length; i++) {\r\n    const binding = bindings[i]\r\n    if (oldBindings) {\r\n      binding.oldValue = oldBindings[i].value\r\n    }\r\n    let hook = binding.dir[name] as DirectiveHook | DirectiveHook[] | undefined\r\n    if (__COMPAT__ && !hook) {\r\n      hook = mapCompatDirectiveHook(name, binding.dir, instance)\r\n    }\r\n    if (hook) {\r\n      // disable tracking inside all lifecycle hooks\r\n      // since they can potentially be called inside effects.\r\n      pauseTracking()\r\n      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [\r\n        vnode.el,\r\n        binding,\r\n        vnode,\r\n        prevVNode\r\n      ])\r\n      resetTracking()\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  getCurrentInstance,\r\n  SetupContext,\r\n  ComponentInternalInstance,\r\n  ComponentOptions\r\n} from '../component'\r\nimport {\r\n  cloneVNode,\r\n  Comment,\r\n  isSameVNodeType,\r\n  VNode,\r\n  VNodeArrayChildren,\r\n  Fragment\r\n} from '../vnode'\r\nimport { warn } from '../warning'\r\nimport { isKeepAlive } from './KeepAlive'\r\nimport { toRaw } from '@vue/reactivity'\r\nimport { callWithAsyncErrorHandling, ErrorCodes } from '../errorHandling'\r\nimport { ShapeFlags, PatchFlags, isArray } from '@vue/shared'\r\nimport { onBeforeUnmount, onMounted } from '../apiLifecycle'\r\nimport { RendererElement } from '../renderer'\r\n\r\ntype Hook<T = () => void> = T | T[]\r\n\r\nconst leaveCbKey = Symbol('_leaveCb')\r\nconst enterCbKey = Symbol('_enterCb')\r\n\r\nexport interface BaseTransitionProps<HostElement = RendererElement> {\r\n  mode?: 'in-out' | 'out-in' | 'default'\r\n  appear?: boolean\r\n\r\n  // If true, indicates this is a transition that doesn't actually insert/remove\r\n  // the element, but toggles the show / hidden status instead.\r\n  // The transition hooks are injected, but will be skipped by the renderer.\r\n  // Instead, a custom directive can control the transition by calling the\r\n  // injected hooks (e.g. v-show).\r\n  persisted?: boolean\r\n\r\n  // Hooks. Using camel case for easier usage in render functions & JSX.\r\n  // In templates these can be written as @before-enter=\"xxx\" as prop names\r\n  // are camelized.\r\n  onBeforeEnter?: Hook<(el: HostElement) => void>\r\n  onEnter?: Hook<(el: HostElement, done: () => void) => void>\r\n  onAfterEnter?: Hook<(el: HostElement) => void>\r\n  onEnterCancelled?: Hook<(el: HostElement) => void>\r\n  // leave\r\n  onBeforeLeave?: Hook<(el: HostElement) => void>\r\n  onLeave?: Hook<(el: HostElement, done: () => void) => void>\r\n  onAfterLeave?: Hook<(el: HostElement) => void>\r\n  onLeaveCancelled?: Hook<(el: HostElement) => void> // only fired in persisted mode\r\n  // appear\r\n  onBeforeAppear?: Hook<(el: HostElement) => void>\r\n  onAppear?: Hook<(el: HostElement, done: () => void) => void>\r\n  onAfterAppear?: Hook<(el: HostElement) => void>\r\n  onAppearCancelled?: Hook<(el: HostElement) => void>\r\n}\r\n\r\nexport interface TransitionHooks<HostElement = RendererElement> {\r\n  mode: BaseTransitionProps['mode']\r\n  persisted: boolean\r\n  beforeEnter(el: HostElement): void\r\n  enter(el: HostElement): void\r\n  leave(el: HostElement, remove: () => void): void\r\n  clone(vnode: VNode): TransitionHooks<HostElement>\r\n  // optional\r\n  afterLeave?(): void\r\n  delayLeave?(\r\n    el: HostElement,\r\n    earlyRemove: () => void,\r\n    delayedLeave: () => void\r\n  ): void\r\n  delayedLeave?(): void\r\n}\r\n\r\nexport type TransitionHookCaller = <T extends any[] = [el: any]>(\r\n  hook: Hook<(...args: T) => void> | undefined,\r\n  args?: T\r\n) => void\r\n\r\nexport type PendingCallback = (cancelled?: boolean) => void\r\n\r\nexport interface TransitionState {\r\n  isMounted: boolean\r\n  isLeaving: boolean\r\n  isUnmounting: boolean\r\n  // Track pending leave callbacks for children of the same key.\r\n  // This is used to force remove leaving a child when a new copy is entering.\r\n  leavingVNodes: Map<any, Record<string, VNode>>\r\n}\r\n\r\nexport interface TransitionElement {\r\n  // in persisted mode (e.g. v-show), the same element is toggled, so the\r\n  // pending enter/leave callbacks may need to be cancelled if the state is toggled\r\n  // before it finishes.\r\n  [enterCbKey]?: PendingCallback\r\n  [leaveCbKey]?: PendingCallback\r\n}\r\n\r\nexport function useTransitionState(): TransitionState {\r\n  const state: TransitionState = {\r\n    isMounted: false,\r\n    isLeaving: false,\r\n    isUnmounting: false,\r\n    leavingVNodes: new Map()\r\n  }\r\n  onMounted(() => {\r\n    state.isMounted = true\r\n  })\r\n  onBeforeUnmount(() => {\r\n    state.isUnmounting = true\r\n  })\r\n  return state\r\n}\r\n\r\nconst TransitionHookValidator = [Function, Array]\r\n\r\nexport const BaseTransitionPropsValidators = {\r\n  mode: String,\r\n  appear: Boolean,\r\n  persisted: Boolean,\r\n  // enter\r\n  onBeforeEnter: TransitionHookValidator,\r\n  onEnter: TransitionHookValidator,\r\n  onAfterEnter: TransitionHookValidator,\r\n  onEnterCancelled: TransitionHookValidator,\r\n  // leave\r\n  onBeforeLeave: TransitionHookValidator,\r\n  onLeave: TransitionHookValidator,\r\n  onAfterLeave: TransitionHookValidator,\r\n  onLeaveCancelled: TransitionHookValidator,\r\n  // appear\r\n  onBeforeAppear: TransitionHookValidator,\r\n  onAppear: TransitionHookValidator,\r\n  onAfterAppear: TransitionHookValidator,\r\n  onAppearCancelled: TransitionHookValidator\r\n}\r\n\r\nconst BaseTransitionImpl: ComponentOptions = {\r\n  name: `BaseTransition`,\r\n\r\n  props: BaseTransitionPropsValidators,\r\n\r\n  setup(props: BaseTransitionProps, { slots }: SetupContext) {\r\n    const instance = getCurrentInstance()!\r\n    const state = useTransitionState()\r\n\r\n    let prevTransitionKey: any\r\n\r\n    return () => {\r\n      const children =\r\n        slots.default && getTransitionRawChildren(slots.default(), true)\r\n      if (!children || !children.length) {\r\n        return\r\n      }\r\n\r\n      let child: VNode = children[0]\r\n      if (children.length > 1) {\r\n        let hasFound = false\r\n        // locate first non-comment child\r\n        for (const c of children) {\r\n          if (c.type !== Comment) {\r\n            if (__DEV__ && hasFound) {\r\n              // warn more than one non-comment child\r\n              warn(\r\n                '<transition> can only be used on a single element or component. ' +\r\n                  'Use <transition-group> for lists.'\r\n              )\r\n              break\r\n            }\r\n            child = c\r\n            hasFound = true\r\n            if (!__DEV__) break\r\n          }\r\n        }\r\n      }\r\n\r\n      // there's no need to track reactivity for these props so use the raw\r\n      // props for a bit better perf\r\n      const rawProps = toRaw(props)\r\n      const { mode } = rawProps\r\n      // check mode\r\n      if (\r\n        __DEV__ &&\r\n        mode &&\r\n        mode !== 'in-out' &&\r\n        mode !== 'out-in' &&\r\n        mode !== 'default'\r\n      ) {\r\n        warn(`invalid <transition> mode: ${mode}`)\r\n      }\r\n\r\n      if (state.isLeaving) {\r\n        return emptyPlaceholder(child)\r\n      }\r\n\r\n      // in the case of <transition><keep-alive/></transition>, we need to\r\n      // compare the type of the kept-alive children.\r\n      const innerChild = getKeepAliveChild(child)\r\n      if (!innerChild) {\r\n        return emptyPlaceholder(child)\r\n      }\r\n\r\n      const enterHooks = resolveTransitionHooks(\r\n        innerChild,\r\n        rawProps,\r\n        state,\r\n        instance\r\n      )\r\n      setTransitionHooks(innerChild, enterHooks)\r\n\r\n      const oldChild = instance.subTree\r\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild)\r\n\r\n      let transitionKeyChanged = false\r\n      const { getTransitionKey } = innerChild.type as any\r\n      if (getTransitionKey) {\r\n        const key = getTransitionKey()\r\n        if (prevTransitionKey === undefined) {\r\n          prevTransitionKey = key\r\n        } else if (key !== prevTransitionKey) {\r\n          prevTransitionKey = key\r\n          transitionKeyChanged = true\r\n        }\r\n      }\r\n\r\n      // handle mode\r\n      if (\r\n        oldInnerChild &&\r\n        oldInnerChild.type !== Comment &&\r\n        (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)\r\n      ) {\r\n        const leavingHooks = resolveTransitionHooks(\r\n          oldInnerChild,\r\n          rawProps,\r\n          state,\r\n          instance\r\n        )\r\n        // update old tree's hooks in case of dynamic transition\r\n        setTransitionHooks(oldInnerChild, leavingHooks)\r\n        // switching between different views\r\n        if (mode === 'out-in') {\r\n          state.isLeaving = true\r\n          // return placeholder node and queue update when leave finishes\r\n          leavingHooks.afterLeave = () => {\r\n            state.isLeaving = false\r\n            // #6835\r\n            // it also needs to be updated when active is undefined\r\n            if (instance.update.active !== false) {\r\n              instance.update()\r\n            }\r\n          }\r\n          return emptyPlaceholder(child)\r\n        } else if (mode === 'in-out' && innerChild.type !== Comment) {\r\n          leavingHooks.delayLeave = (\r\n            el: TransitionElement,\r\n            earlyRemove,\r\n            delayedLeave\r\n          ) => {\r\n            const leavingVNodesCache = getLeavingNodesForType(\r\n              state,\r\n              oldInnerChild\r\n            )\r\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild\r\n            // early removal callback\r\n            el[leaveCbKey] = () => {\r\n              earlyRemove()\r\n              el[leaveCbKey] = undefined\r\n              delete enterHooks.delayedLeave\r\n            }\r\n            enterHooks.delayedLeave = delayedLeave\r\n          }\r\n        }\r\n      }\r\n\r\n      return child\r\n    }\r\n  }\r\n}\r\n\r\nif (__COMPAT__) {\r\n  BaseTransitionImpl.__isBuiltIn = true\r\n}\r\n\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nexport const BaseTransition = BaseTransitionImpl as unknown as {\r\n  new (): {\r\n    $props: BaseTransitionProps<any>\r\n    $slots: {\r\n      default(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction getLeavingNodesForType(\r\n  state: TransitionState,\r\n  vnode: VNode\r\n): Record<string, VNode> {\r\n  const { leavingVNodes } = state\r\n  let leavingVNodesCache = leavingVNodes.get(vnode.type)!\r\n  if (!leavingVNodesCache) {\r\n    leavingVNodesCache = Object.create(null)\r\n    leavingVNodes.set(vnode.type, leavingVNodesCache)\r\n  }\r\n  return leavingVNodesCache\r\n}\r\n\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nexport function resolveTransitionHooks(\r\n  vnode: VNode,\r\n  props: BaseTransitionProps<any>,\r\n  state: TransitionState,\r\n  instance: ComponentInternalInstance\r\n): TransitionHooks {\r\n  const {\r\n    appear,\r\n    mode,\r\n    persisted = false,\r\n    onBeforeEnter,\r\n    onEnter,\r\n    onAfterEnter,\r\n    onEnterCancelled,\r\n    onBeforeLeave,\r\n    onLeave,\r\n    onAfterLeave,\r\n    onLeaveCancelled,\r\n    onBeforeAppear,\r\n    onAppear,\r\n    onAfterAppear,\r\n    onAppearCancelled\r\n  } = props\r\n  const key = String(vnode.key)\r\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode)\r\n\r\n  const callHook: TransitionHookCaller = (hook, args) => {\r\n    hook &&\r\n      callWithAsyncErrorHandling(\r\n        hook,\r\n        instance,\r\n        ErrorCodes.TRANSITION_HOOK,\r\n        args\r\n      )\r\n  }\r\n\r\n  const callAsyncHook = (\r\n    hook: Hook<(el: any, done: () => void) => void>,\r\n    args: [TransitionElement, () => void]\r\n  ) => {\r\n    const done = args[1]\r\n    callHook(hook, args)\r\n    if (isArray(hook)) {\r\n      if (hook.every(hook => hook.length <= 1)) done()\r\n    } else if (hook.length <= 1) {\r\n      done()\r\n    }\r\n  }\r\n\r\n  const hooks: TransitionHooks<TransitionElement> = {\r\n    mode,\r\n    persisted,\r\n    beforeEnter(el) {\r\n      let hook = onBeforeEnter\r\n      if (!state.isMounted) {\r\n        if (appear) {\r\n          hook = onBeforeAppear || onBeforeEnter\r\n        } else {\r\n          return\r\n        }\r\n      }\r\n      // for same element (v-show)\r\n      if (el[leaveCbKey]) {\r\n        el[leaveCbKey](true /* cancelled */)\r\n      }\r\n      // for toggled element with same key (v-if)\r\n      const leavingVNode = leavingVNodesCache[key]\r\n      if (\r\n        leavingVNode &&\r\n        isSameVNodeType(vnode, leavingVNode) &&\r\n        (leavingVNode.el as TransitionElement)[leaveCbKey]\r\n      ) {\r\n        // force early removal (not cancelled)\r\n        ;(leavingVNode.el as TransitionElement)[leaveCbKey]!()\r\n      }\r\n      callHook(hook, [el])\r\n    },\r\n\r\n    enter(el) {\r\n      let hook = onEnter\r\n      let afterHook = onAfterEnter\r\n      let cancelHook = onEnterCancelled\r\n      if (!state.isMounted) {\r\n        if (appear) {\r\n          hook = onAppear || onEnter\r\n          afterHook = onAfterAppear || onAfterEnter\r\n          cancelHook = onAppearCancelled || onEnterCancelled\r\n        } else {\r\n          return\r\n        }\r\n      }\r\n      let called = false\r\n      const done = (el[enterCbKey] = (cancelled?) => {\r\n        if (called) return\r\n        called = true\r\n        if (cancelled) {\r\n          callHook(cancelHook, [el])\r\n        } else {\r\n          callHook(afterHook, [el])\r\n        }\r\n        if (hooks.delayedLeave) {\r\n          hooks.delayedLeave()\r\n        }\r\n        el[enterCbKey] = undefined\r\n      })\r\n      if (hook) {\r\n        callAsyncHook(hook, [el, done])\r\n      } else {\r\n        done()\r\n      }\r\n    },\r\n\r\n    leave(el, remove) {\r\n      const key = String(vnode.key)\r\n      if (el[enterCbKey]) {\r\n        el[enterCbKey](true /* cancelled */)\r\n      }\r\n      if (state.isUnmounting) {\r\n        return remove()\r\n      }\r\n      callHook(onBeforeLeave, [el])\r\n      let called = false\r\n      const done = (el[leaveCbKey] = (cancelled?) => {\r\n        if (called) return\r\n        called = true\r\n        remove()\r\n        if (cancelled) {\r\n          callHook(onLeaveCancelled, [el])\r\n        } else {\r\n          callHook(onAfterLeave, [el])\r\n        }\r\n        el[leaveCbKey] = undefined\r\n        if (leavingVNodesCache[key] === vnode) {\r\n          delete leavingVNodesCache[key]\r\n        }\r\n      })\r\n      leavingVNodesCache[key] = vnode\r\n      if (onLeave) {\r\n        callAsyncHook(onLeave, [el, done])\r\n      } else {\r\n        done()\r\n      }\r\n    },\r\n\r\n    clone(vnode) {\r\n      return resolveTransitionHooks(vnode, props, state, instance)\r\n    }\r\n  }\r\n\r\n  return hooks\r\n}\r\n\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode: VNode): VNode | undefined {\r\n  if (isKeepAlive(vnode)) {\r\n    vnode = cloneVNode(vnode)\r\n    vnode.children = null\r\n    return vnode\r\n  }\r\n}\r\n\r\nfunction getKeepAliveChild(vnode: VNode): VNode | undefined {\r\n  return isKeepAlive(vnode)\r\n    ? // #7121 ensure get the child component subtree in case\r\n      // it's been replaced during HMR\r\n      __DEV__ && vnode.component\r\n      ? vnode.component.subTree\r\n      : vnode.children\r\n        ? ((vnode.children as VNodeArrayChildren)[0] as VNode)\r\n        : undefined\r\n    : vnode\r\n}\r\n\r\nexport function setTransitionHooks(vnode: VNode, hooks: TransitionHooks) {\r\n  if (vnode.shapeFlag & ShapeFlags.COMPONENT && vnode.component) {\r\n    setTransitionHooks(vnode.component.subTree, hooks)\r\n  } else if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n    vnode.ssContent!.transition = hooks.clone(vnode.ssContent!)\r\n    vnode.ssFallback!.transition = hooks.clone(vnode.ssFallback!)\r\n  } else {\r\n    vnode.transition = hooks\r\n  }\r\n}\r\n\r\nexport function getTransitionRawChildren(\r\n  children: VNode[],\r\n  keepComment: boolean = false,\r\n  parentKey?: VNode['key']\r\n): VNode[] {\r\n  let ret: VNode[] = []\r\n  let keyedFragmentCount = 0\r\n  for (let i = 0; i < children.length; i++) {\r\n    let child = children[i]\r\n    // #5360 inherit parent key in case of <template v-for>\r\n    const key =\r\n      parentKey == null\r\n        ? child.key\r\n        : String(parentKey) + String(child.key != null ? child.key : i)\r\n    // handle fragment children case, e.g. v-for\r\n    if (child.type === Fragment) {\r\n      if (child.patchFlag & PatchFlags.KEYED_FRAGMENT) keyedFragmentCount++\r\n      ret = ret.concat(\r\n        getTransitionRawChildren(child.children as VNode[], keepComment, key)\r\n      )\r\n    }\r\n    // comment placeholders should be skipped, e.g. v-if\r\n    else if (keepComment || child.type !== Comment) {\r\n      ret.push(key != null ? cloneVNode(child, { key }) : child)\r\n    }\r\n  }\r\n  // #1126 if a transition children list contains multiple sub fragments, these\r\n  // fragments will be merged into a flat children array. Since each v-for\r\n  // fragment may contain different static bindings inside, we need to de-op\r\n  // these children to force full diffs to ensure correct behavior.\r\n  if (keyedFragmentCount > 1) {\r\n    for (let i = 0; i < ret.length; i++) {\r\n      ret[i].patchFlag = PatchFlags.BAIL\r\n    }\r\n  }\r\n  return ret\r\n}\r\n", "import {\r\n  ComputedOptions,\r\n  MethodOptions,\r\n  ComponentOptionsWithoutProps,\r\n  ComponentOptionsWithArrayProps,\r\n  ComponentOptionsWithObjectProps,\r\n  ComponentOptionsMixin,\r\n  RenderFunction,\r\n  ComponentOptionsBase,\r\n  ComponentInjectOptions,\r\n  ComponentOptions\r\n} from './componentOptions'\r\nimport {\r\n  SetupContext,\r\n  AllowedComponentProps,\r\n  ComponentCustomProps\r\n} from './component'\r\nimport {\r\n  ExtractPropTypes,\r\n  ComponentPropsOptions,\r\n  ExtractDefaultPropTypes,\r\n  ComponentObjectPropsOptions\r\n} from './componentProps'\r\nimport { EmitsOptions, EmitsToProps } from './componentEmits'\r\nimport { extend, isFunction } from '@vue/shared'\r\nimport { VNodeProps } from './vnode'\r\nimport {\r\n  CreateComponentPublicInstance,\r\n  ComponentPublicInstanceConstructor\r\n} from './componentPublicInstance'\r\nimport { SlotsType } from './componentSlots'\r\n\r\nexport type PublicProps = VNodeProps &\r\n  AllowedComponentProps &\r\n  ComponentCustomProps\r\n\r\ntype ResolveProps<PropsOrPropOptions, E extends EmitsOptions> = Readonly<\r\n  PropsOrPropOptions extends ComponentPropsOptions\r\n    ? ExtractPropTypes<PropsOrPropOptions>\r\n    : PropsOrPropOptions\r\n> &\r\n  ({} extends E ? {} : EmitsToProps<E>)\r\n\r\nexport type DefineComponent<\r\n  PropsOrPropOptions = {},\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions,\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  PP = PublicProps,\r\n  Props = ResolveProps<PropsOrPropOptions, E>,\r\n  Defaults = ExtractDefaultPropTypes<PropsOrPropOptions>,\r\n  S extends SlotsType = {}\r\n> = ComponentPublicInstanceConstructor<\r\n  CreateComponentPublicInstance<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    PP & Props,\r\n    Defaults,\r\n    true,\r\n    {},\r\n    S\r\n  >\r\n> &\r\n  ComponentOptionsBase<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    Defaults,\r\n    {},\r\n    string,\r\n    S\r\n  > &\r\n  PP\r\n\r\n// defineComponent is a utility that is primarily used for type inference\r\n// when declaring components. Type inference is provided in the component\r\n// options (provided as the argument). The returned value has artificial types\r\n// for TSX / manual render function / IDE support.\r\n\r\n// overload 1: direct setup function\r\n// (uses user defined props interface)\r\nexport function defineComponent<\r\n  Props extends Record<string, any>,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  S extends SlotsType = {}\r\n>(\r\n  setup: (\r\n    props: Props,\r\n    ctx: SetupContext<E, S>\r\n  ) => RenderFunction | Promise<RenderFunction>,\r\n  options?: Pick<ComponentOptions, 'name' | 'inheritAttrs'> & {\r\n    props?: (keyof Props)[]\r\n    emits?: E | EE[]\r\n    slots?: S\r\n  }\r\n): (props: Props & EmitsToProps<E>) => any\r\nexport function defineComponent<\r\n  Props extends Record<string, any>,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  S extends SlotsType = {}\r\n>(\r\n  setup: (\r\n    props: Props,\r\n    ctx: SetupContext<E, S>\r\n  ) => RenderFunction | Promise<RenderFunction>,\r\n  options?: Pick<ComponentOptions, 'name' | 'inheritAttrs'> & {\r\n    props?: ComponentObjectPropsOptions<Props>\r\n    emits?: E | EE[]\r\n    slots?: S\r\n  }\r\n): (props: Props & EmitsToProps<E>) => any\r\n\r\n// overload 2: object format with no props\r\n// (uses user defined props interface)\r\n// return type is for Vetur and TSX support\r\nexport function defineComponent<\r\n  Props = {},\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  S extends SlotsType = {},\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string\r\n>(\r\n  options: ComponentOptionsWithoutProps<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  >\r\n): DefineComponent<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  PublicProps,\r\n  ResolveProps<Props, E>,\r\n  ExtractDefaultPropTypes<Props>,\r\n  S\r\n>\r\n\r\n// overload 3: object format with array props declaration\r\n// props inferred as { [key in PropNames]?: any }\r\n// return type is for Vetur and TSX support\r\nexport function defineComponent<\r\n  PropNames extends string,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  S extends SlotsType = {},\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  Props = Readonly<{ [key in PropNames]?: any }>\r\n>(\r\n  options: ComponentOptionsWithArrayProps<\r\n    PropNames,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  >\r\n): DefineComponent<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  PublicProps,\r\n  ResolveProps<Props, E>,\r\n  ExtractDefaultPropTypes<Props>,\r\n  S\r\n>\r\n\r\n// overload 4: object format with object props declaration\r\n// see `ExtractPropTypes` in ./componentProps.ts\r\nexport function defineComponent<\r\n  // the Readonly constraint allows TS to treat the type of { required: true }\r\n  // as constant instead of boolean.\r\n  PropsOptions extends Readonly<ComponentPropsOptions>,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  EE extends string = string,\r\n  S extends SlotsType = {},\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string\r\n>(\r\n  options: ComponentOptionsWithObjectProps<\r\n    PropsOptions,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  >\r\n): DefineComponent<\r\n  PropsOptions,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  PublicProps,\r\n  ResolveProps<PropsOptions, E>,\r\n  ExtractDefaultPropTypes<PropsOptions>,\r\n  S\r\n>\r\n\r\n// implementation, close to no-op\r\n/*! #__NO_SIDE_EFFECTS__ */\r\nexport function defineComponent(\r\n  options: unknown,\r\n  extraOptions?: ComponentOptions\r\n) {\r\n  return isFunction(options)\r\n    ? // #8326: extend call and options.name access are considered side-effects\r\n      // by Rollup, so we have to wrap it in a pure-annotated IIFE.\r\n      /*#__PURE__*/ (() =>\r\n        extend({ name: options.name }, extraOptions, { setup: options }))()\r\n    : options\r\n}\r\n", "import {\r\n  Component,\r\n  ConcreteComponent,\r\n  currentInstance,\r\n  ComponentInternalInstance,\r\n  isInSSRComponentSetup,\r\n  ComponentOptions\r\n} from './component'\r\nimport { isFunction, isObject } from '@vue/shared'\r\nimport { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { createVNode, VNode } from './vnode'\r\nimport { defineComponent } from './apiDefineComponent'\r\nimport { warn } from './warning'\r\nimport { ref } from '@vue/reactivity'\r\nimport { handleError, ErrorCodes } from './errorHandling'\r\nimport { isKeepAlive } from './components/KeepAlive'\r\nimport { queueJob } from './scheduler'\r\n\r\nexport type AsyncComponentResolveResult<T = Component> = T | { default: T } // es modules\r\n\r\nexport type AsyncComponentLoader<T = any> = () => Promise<\r\n  AsyncComponentResolveResult<T>\r\n>\r\n\r\nexport interface AsyncComponentOptions<T = any> {\r\n  loader: AsyncComponentLoader<T>\r\n  loadingComponent?: Component\r\n  errorComponent?: Component\r\n  delay?: number\r\n  timeout?: number\r\n  suspensible?: boolean\r\n  onError?: (\r\n    error: Error,\r\n    retry: () => void,\r\n    fail: () => void,\r\n    attempts: number\r\n  ) => any\r\n}\r\n\r\nexport const isAsyncWrapper = (i: ComponentInternalInstance | VNode): boolean =>\r\n  !!(i.type as ComponentOptions).__asyncLoader\r\n\r\n/*! #__NO_SIDE_EFFECTS__ */\r\nexport function defineAsyncComponent<\r\n  T extends Component = { new (): ComponentPublicInstance }\r\n>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {\r\n  if (isFunction(source)) {\r\n    source = { loader: source }\r\n  }\r\n\r\n  const {\r\n    loader,\r\n    loadingComponent,\r\n    errorComponent,\r\n    delay = 200,\r\n    timeout, // undefined = never times out\r\n    suspensible = true,\r\n    onError: userOnError\r\n  } = source\r\n\r\n  let pendingRequest: Promise<ConcreteComponent> | null = null\r\n  let resolvedComp: ConcreteComponent | undefined\r\n\r\n  let retries = 0\r\n  const retry = () => {\r\n    retries++\r\n    pendingRequest = null\r\n    return load()\r\n  }\r\n\r\n  const load = (): Promise<ConcreteComponent> => {\r\n    let thisRequest: Promise<ConcreteComponent>\r\n    return (\r\n      pendingRequest ||\r\n      (thisRequest = pendingRequest =\r\n        loader()\r\n          .catch(err => {\r\n            err = err instanceof Error ? err : new Error(String(err))\r\n            if (userOnError) {\r\n              return new Promise((resolve, reject) => {\r\n                const userRetry = () => resolve(retry())\r\n                const userFail = () => reject(err)\r\n                userOnError(err, userRetry, userFail, retries + 1)\r\n              })\r\n            } else {\r\n              throw err\r\n            }\r\n          })\r\n          .then((comp: any) => {\r\n            if (thisRequest !== pendingRequest && pendingRequest) {\r\n              return pendingRequest\r\n            }\r\n            if (__DEV__ && !comp) {\r\n              warn(\r\n                `Async component loader resolved to undefined. ` +\r\n                  `If you are using retry(), make sure to return its return value.`\r\n              )\r\n            }\r\n            // interop module default\r\n            if (\r\n              comp &&\r\n              (comp.__esModule || comp[Symbol.toStringTag] === 'Module')\r\n            ) {\r\n              comp = comp.default\r\n            }\r\n            if (__DEV__ && comp && !isObject(comp) && !isFunction(comp)) {\r\n              throw new Error(`Invalid async component load result: ${comp}`)\r\n            }\r\n            resolvedComp = comp\r\n            return comp\r\n          }))\r\n    )\r\n  }\r\n\r\n  return defineComponent({\r\n    name: 'AsyncComponentWrapper',\r\n\r\n    __asyncLoader: load,\r\n\r\n    get __asyncResolved() {\r\n      return resolvedComp\r\n    },\r\n\r\n    setup() {\r\n      const instance = currentInstance!\r\n\r\n      // already resolved\r\n      if (resolvedComp) {\r\n        return () => createInnerComp(resolvedComp!, instance)\r\n      }\r\n\r\n      const onError = (err: Error) => {\r\n        pendingRequest = null\r\n        handleError(\r\n          err,\r\n          instance,\r\n          ErrorCodes.ASYNC_COMPONENT_LOADER,\r\n          !errorComponent /* do not throw in dev if user provided error component */\r\n        )\r\n      }\r\n\r\n      // suspense-controlled or SSR.\r\n      if (\r\n        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||\r\n        (__SSR__ && isInSSRComponentSetup)\r\n      ) {\r\n        return load()\r\n          .then(comp => {\r\n            return () => createInnerComp(comp, instance)\r\n          })\r\n          .catch(err => {\r\n            onError(err)\r\n            return () =>\r\n              errorComponent\r\n                ? createVNode(errorComponent as ConcreteComponent, {\r\n                    error: err\r\n                  })\r\n                : null\r\n          })\r\n      }\r\n\r\n      const loaded = ref(false)\r\n      const error = ref()\r\n      const delayed = ref(!!delay)\r\n\r\n      if (delay) {\r\n        setTimeout(() => {\r\n          delayed.value = false\r\n        }, delay)\r\n      }\r\n\r\n      if (timeout != null) {\r\n        setTimeout(() => {\r\n          if (!loaded.value && !error.value) {\r\n            const err = new Error(\r\n              `Async component timed out after ${timeout}ms.`\r\n            )\r\n            onError(err)\r\n            error.value = err\r\n          }\r\n        }, timeout)\r\n      }\r\n\r\n      load()\r\n        .then(() => {\r\n          loaded.value = true\r\n          if (instance.parent && isKeepAlive(instance.parent.vnode)) {\r\n            // parent is keep-alive, force update so the loaded component's\r\n            // name is taken into account\r\n            queueJob(instance.parent.update)\r\n          }\r\n        })\r\n        .catch(err => {\r\n          onError(err)\r\n          error.value = err\r\n        })\r\n\r\n      return () => {\r\n        if (loaded.value && resolvedComp) {\r\n          return createInnerComp(resolvedComp, instance)\r\n        } else if (error.value && errorComponent) {\r\n          return createVNode(errorComponent, {\r\n            error: error.value\r\n          })\r\n        } else if (loadingComponent && !delayed.value) {\r\n          return createVNode(loadingComponent)\r\n        }\r\n      }\r\n    }\r\n  }) as T\r\n}\r\n\r\nfunction createInnerComp(\r\n  comp: ConcreteComponent,\r\n  parent: ComponentInternalInstance\r\n) {\r\n  const { ref, props, children, ce } = parent.vnode\r\n  const vnode = createVNode(comp, props, children)\r\n  // ensure inner component inherits the async wrapper's ref owner\r\n  vnode.ref = ref\r\n  // pass the custom element callback on to the inner comp\r\n  // and remove it from the async wrapper\r\n  vnode.ce = ce\r\n  delete parent.vnode.ce\r\n\r\n  return vnode\r\n}\r\n", "import {\r\n  ConcreteComponent,\r\n  getCurrentInstance,\r\n  SetupContext,\r\n  ComponentInternalInstance,\r\n  currentInstance,\r\n  getComponentName,\r\n  ComponentOptions\r\n} from '../component'\r\nimport {\r\n  VNode,\r\n  cloneVNode,\r\n  isVNode,\r\n  VNodeProps,\r\n  invokeVNodeHook,\r\n  isSameVNodeType\r\n} from '../vnode'\r\nimport { warn } from '../warning'\r\nimport {\r\n  onBeforeUnmount,\r\n  injectHook,\r\n  onUnmounted,\r\n  onMounted,\r\n  onUpdated\r\n} from '../apiLifecycle'\r\nimport {\r\n  isString,\r\n  isArray,\r\n  isRegExp,\r\n  ShapeFlags,\r\n  remove,\r\n  invokeArrayFns\r\n} from '@vue/shared'\r\nimport { watch } from '../apiWatch'\r\nimport {\r\n  RendererInternals,\r\n  queuePostRenderEffect,\r\n  MoveType,\r\n  RendererElement,\r\n  RendererNode\r\n} from '../renderer'\r\nimport { setTransitionHooks } from './BaseTransition'\r\nimport { ComponentRenderContext } from '../componentPublicInstance'\r\nimport { devtoolsComponentAdded } from '../devtools'\r\nimport { isAsyncWrapper } from '../apiAsyncComponent'\r\nimport { isSuspense } from './Suspense'\r\nimport { LifecycleHooks } from '../enums'\r\n\r\ntype MatchPattern = string | RegExp | (string | RegExp)[]\r\n\r\nexport interface KeepAliveProps {\r\n  include?: MatchPattern\r\n  exclude?: MatchPattern\r\n  max?: number | string\r\n}\r\n\r\ntype CacheKey = string | number | symbol | ConcreteComponent\r\ntype Cache = Map<CacheKey, VNode>\r\ntype Keys = Set<CacheKey>\r\n\r\nexport interface KeepAliveContext extends ComponentRenderContext {\r\n  renderer: RendererInternals\r\n  activate: (\r\n    vnode: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    isSVG: boolean,\r\n    optimized: boolean\r\n  ) => void\r\n  deactivate: (vnode: VNode) => void\r\n}\r\n\r\nexport const isKeepAlive = (vnode: VNode): boolean =>\r\n  (vnode.type as any).__isKeepAlive\r\n\r\nconst KeepAliveImpl: ComponentOptions = {\r\n  name: `KeepAlive`,\r\n\r\n  // Marker for special handling inside the renderer. We are not using a ===\r\n  // check directly on KeepAlive in the renderer, because importing it directly\r\n  // would prevent it from being tree-shaken.\r\n  __isKeepAlive: true,\r\n\r\n  props: {\r\n    include: [String, RegExp, Array],\r\n    exclude: [String, RegExp, Array],\r\n    max: [String, Number]\r\n  },\r\n\r\n  setup(props: KeepAliveProps, { slots }: SetupContext) {\r\n    const instance = getCurrentInstance()!\r\n    // KeepAlive communicates with the instantiated renderer via the\r\n    // ctx where the renderer passes in its internals,\r\n    // and the KeepAlive instance exposes activate/deactivate implementations.\r\n    // The whole point of this is to avoid importing KeepAlive directly in the\r\n    // renderer to facilitate tree-shaking.\r\n    const sharedContext = instance.ctx as KeepAliveContext\r\n\r\n    // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n    // for KeepAlive, we just need to render its children\r\n    if (__SSR__ && !sharedContext.renderer) {\r\n      return () => {\r\n        const children = slots.default && slots.default()\r\n        return children && children.length === 1 ? children[0] : children\r\n      }\r\n    }\r\n\r\n    const cache: Cache = new Map()\r\n    const keys: Keys = new Set()\r\n    let current: VNode | null = null\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      ;(instance as any).__v_cache = cache\r\n    }\r\n\r\n    const parentSuspense = instance.suspense\r\n\r\n    const {\r\n      renderer: {\r\n        p: patch,\r\n        m: move,\r\n        um: _unmount,\r\n        o: { createElement }\r\n      }\r\n    } = sharedContext\r\n    const storageContainer = createElement('div')\r\n\r\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n      const instance = vnode.component!\r\n      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)\r\n      // in case props have changed\r\n      patch(\r\n        instance.vnode,\r\n        vnode,\r\n        container,\r\n        anchor,\r\n        instance,\r\n        parentSuspense,\r\n        isSVG,\r\n        vnode.slotScopeIds,\r\n        optimized\r\n      )\r\n      queuePostRenderEffect(() => {\r\n        instance.isDeactivated = false\r\n        if (instance.a) {\r\n          invokeArrayFns(instance.a)\r\n        }\r\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted\r\n        if (vnodeHook) {\r\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\r\n        }\r\n      }, parentSuspense)\r\n\r\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n        // Update components tree\r\n        devtoolsComponentAdded(instance)\r\n      }\r\n    }\r\n\r\n    sharedContext.deactivate = (vnode: VNode) => {\r\n      const instance = vnode.component!\r\n      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)\r\n      queuePostRenderEffect(() => {\r\n        if (instance.da) {\r\n          invokeArrayFns(instance.da)\r\n        }\r\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted\r\n        if (vnodeHook) {\r\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\r\n        }\r\n        instance.isDeactivated = true\r\n      }, parentSuspense)\r\n\r\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n        // Update components tree\r\n        devtoolsComponentAdded(instance)\r\n      }\r\n    }\r\n\r\n    function unmount(vnode: VNode) {\r\n      // reset the shapeFlag so it can be properly unmounted\r\n      resetShapeFlag(vnode)\r\n      _unmount(vnode, instance, parentSuspense, true)\r\n    }\r\n\r\n    function pruneCache(filter?: (name: string) => boolean) {\r\n      cache.forEach((vnode, key) => {\r\n        const name = getComponentName(vnode.type as ConcreteComponent)\r\n        if (name && (!filter || !filter(name))) {\r\n          pruneCacheEntry(key)\r\n        }\r\n      })\r\n    }\r\n\r\n    function pruneCacheEntry(key: CacheKey) {\r\n      const cached = cache.get(key) as VNode\r\n      if (!current || !isSameVNodeType(cached, current)) {\r\n        unmount(cached)\r\n      } else if (current) {\r\n        // current active instance should no longer be kept-alive.\r\n        // we can't unmount it now but it might be later, so reset its flag now.\r\n        resetShapeFlag(current)\r\n      }\r\n      cache.delete(key)\r\n      keys.delete(key)\r\n    }\r\n\r\n    // prune cache on include/exclude prop change\r\n    watch(\r\n      () => [props.include, props.exclude],\r\n      ([include, exclude]) => {\r\n        include && pruneCache(name => matches(include, name))\r\n        exclude && pruneCache(name => !matches(exclude, name))\r\n      },\r\n      // prune post-render after `current` has been updated\r\n      { flush: 'post', deep: true }\r\n    )\r\n\r\n    // cache sub tree after render\r\n    let pendingCacheKey: CacheKey | null = null\r\n    const cacheSubtree = () => {\r\n      // fix #1621, the pendingCacheKey could be 0\r\n      if (pendingCacheKey != null) {\r\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree))\r\n      }\r\n    }\r\n    onMounted(cacheSubtree)\r\n    onUpdated(cacheSubtree)\r\n\r\n    onBeforeUnmount(() => {\r\n      cache.forEach(cached => {\r\n        const { subTree, suspense } = instance\r\n        const vnode = getInnerChild(subTree)\r\n        if (cached.type === vnode.type && cached.key === vnode.key) {\r\n          // current instance will be unmounted as part of keep-alive's unmount\r\n          resetShapeFlag(vnode)\r\n          // but invoke its deactivated hook here\r\n          const da = vnode.component!.da\r\n          da && queuePostRenderEffect(da, suspense)\r\n          return\r\n        }\r\n        unmount(cached)\r\n      })\r\n    })\r\n\r\n    return () => {\r\n      pendingCacheKey = null\r\n\r\n      if (!slots.default) {\r\n        return null\r\n      }\r\n\r\n      const children = slots.default()\r\n      const rawVNode = children[0]\r\n      if (children.length > 1) {\r\n        if (__DEV__) {\r\n          warn(`KeepAlive should contain exactly one component child.`)\r\n        }\r\n        current = null\r\n        return children\r\n      } else if (\r\n        !isVNode(rawVNode) ||\r\n        (!(rawVNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) &&\r\n          !(rawVNode.shapeFlag & ShapeFlags.SUSPENSE))\r\n      ) {\r\n        current = null\r\n        return rawVNode\r\n      }\r\n\r\n      let vnode = getInnerChild(rawVNode)\r\n      const comp = vnode.type as ConcreteComponent\r\n\r\n      // for async components, name check should be based in its loaded\r\n      // inner component if available\r\n      const name = getComponentName(\r\n        isAsyncWrapper(vnode)\r\n          ? (vnode.type as ComponentOptions).__asyncResolved || {}\r\n          : comp\r\n      )\r\n\r\n      const { include, exclude, max } = props\r\n\r\n      if (\r\n        (include && (!name || !matches(include, name))) ||\r\n        (exclude && name && matches(exclude, name))\r\n      ) {\r\n        current = vnode\r\n        return rawVNode\r\n      }\r\n\r\n      const key = vnode.key == null ? comp : vnode.key\r\n      const cachedVNode = cache.get(key)\r\n\r\n      // clone vnode if it's reused because we are going to mutate it\r\n      if (vnode.el) {\r\n        vnode = cloneVNode(vnode)\r\n        if (rawVNode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n          rawVNode.ssContent = vnode\r\n        }\r\n      }\r\n      // #1513 it's possible for the returned vnode to be cloned due to attr\r\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n      // that is mounted. Instead of caching it directly, we store the pending\r\n      // key and cache `instance.subTree` (the normalized vnode) in\r\n      // beforeMount/beforeUpdate hooks.\r\n      pendingCacheKey = key\r\n\r\n      if (cachedVNode) {\r\n        // copy over mounted state\r\n        vnode.el = cachedVNode.el\r\n        vnode.component = cachedVNode.component\r\n        if (vnode.transition) {\r\n          // recursively update transition hooks on subTree\r\n          setTransitionHooks(vnode, vnode.transition!)\r\n        }\r\n        // avoid vnode being mounted as fresh\r\n        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE\r\n        // make this key the freshest\r\n        keys.delete(key)\r\n        keys.add(key)\r\n      } else {\r\n        keys.add(key)\r\n        // prune oldest entry\r\n        if (max && keys.size > parseInt(max as string, 10)) {\r\n          pruneCacheEntry(keys.values().next().value)\r\n        }\r\n      }\r\n      // avoid vnode being unmounted\r\n      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n\r\n      current = vnode\r\n      return isSuspense(rawVNode.type) ? rawVNode : vnode\r\n    }\r\n  }\r\n}\r\n\r\nif (__COMPAT__) {\r\n  KeepAliveImpl.__isBuildIn = true\r\n}\r\n\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nexport const KeepAlive = KeepAliveImpl as any as {\r\n  __isKeepAlive: true\r\n  new (): {\r\n    $props: VNodeProps & KeepAliveProps\r\n    $slots: {\r\n      default(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction matches(pattern: MatchPattern, name: string): boolean {\r\n  if (isArray(pattern)) {\r\n    return pattern.some((p: string | RegExp) => matches(p, name))\r\n  } else if (isString(pattern)) {\r\n    return pattern.split(',').includes(name)\r\n  } else if (isRegExp(pattern)) {\r\n    return pattern.test(name)\r\n  }\r\n  /* istanbul ignore next */\r\n  return false\r\n}\r\n\r\nexport function onActivated(\r\n  hook: Function,\r\n  target?: ComponentInternalInstance | null\r\n) {\r\n  registerKeepAliveHook(hook, LifecycleHooks.ACTIVATED, target)\r\n}\r\n\r\nexport function onDeactivated(\r\n  hook: Function,\r\n  target?: ComponentInternalInstance | null\r\n) {\r\n  registerKeepAliveHook(hook, LifecycleHooks.DEACTIVATED, target)\r\n}\r\n\r\nfunction registerKeepAliveHook(\r\n  hook: Function & { __wdc?: Function },\r\n  type: LifecycleHooks,\r\n  target: ComponentInternalInstance | null = currentInstance\r\n) {\r\n  // cache the deactivate branch check wrapper for injected hooks so the same\r\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n  // deactivation check\".\r\n  const wrappedHook =\r\n    hook.__wdc ||\r\n    (hook.__wdc = () => {\r\n      // only fire the hook if the target instance is NOT in a deactivated branch.\r\n      let current: ComponentInternalInstance | null = target\r\n      while (current) {\r\n        if (current.isDeactivated) {\r\n          return\r\n        }\r\n        current = current.parent\r\n      }\r\n      return hook()\r\n    })\r\n  injectHook(type, wrappedHook, target)\r\n  // In addition to registering it on the target instance, we walk up the parent\r\n  // chain and register it on all ancestor instances that are keep-alive roots.\r\n  // This avoids the need to walk the entire component tree when invoking these\r\n  // hooks, and more importantly, avoids the need to track child components in\r\n  // arrays.\r\n  if (target) {\r\n    let current = target.parent\r\n    while (current && current.parent) {\r\n      if (isKeepAlive(current.parent.vnode)) {\r\n        injectToKeepAliveRoot(wrappedHook, type, target, current)\r\n      }\r\n      current = current.parent\r\n    }\r\n  }\r\n}\r\n\r\nfunction injectToKeepAliveRoot(\r\n  hook: Function & { __weh?: Function },\r\n  type: LifecycleHooks,\r\n  target: ComponentInternalInstance,\r\n  keepAliveRoot: ComponentInternalInstance\r\n) {\r\n  // injectHook wraps the original for error handling, so make sure to remove\r\n  // the wrapped version.\r\n  const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */)\r\n  onUnmounted(() => {\r\n    remove(keepAliveRoot[type]!, injected)\r\n  }, target)\r\n}\r\n\r\nfunction resetShapeFlag(vnode: VNode) {\r\n  // bitwise operations to remove keep alive flags\r\n  vnode.shapeFlag &= ~ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n  vnode.shapeFlag &= ~ShapeFlags.COMPONENT_KEPT_ALIVE\r\n}\r\n\r\nfunction getInnerChild(vnode: VNode) {\r\n  return vnode.shapeFlag & ShapeFlags.SUSPENSE ? vnode.ssContent! : vnode\r\n}\r\n", "import {\r\n  ComponentInternalInstance,\r\n  currentInstance,\r\n  isInSSRComponentSetup,\r\n  setCurrentInstance,\r\n  unsetCurrentInstance\r\n} from './component'\r\nimport { ComponentPublicInstance } from './componentPublicInstance'\r\nimport { callWithAsyncErrorHandling, ErrorTypeStrings } from './errorHandling'\r\nimport { warn } from './warning'\r\nimport { toHandlerKey } from '@vue/shared'\r\nimport { DebuggerEvent, pauseTracking, resetTracking } from '@vue/reactivity'\r\nimport { LifecycleHooks } from './enums'\r\n\r\nexport { onActivated, onDeactivated } from './components/KeepAlive'\r\n\r\nexport function injectHook(\r\n  type: LifecycleHooks,\r\n  hook: Function & { __weh?: Function },\r\n  target: ComponentInternalInstance | null = currentInstance,\r\n  prepend: boolean = false\r\n): Function | undefined {\r\n  if (target) {\r\n    const hooks = target[type] || (target[type] = [])\r\n    // cache the error handling wrapper for injected hooks so the same hook\r\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n    // handling\".\r\n    const wrappedHook =\r\n      hook.__weh ||\r\n      (hook.__weh = (...args: unknown[]) => {\r\n        if (target.isUnmounted) {\r\n          return\r\n        }\r\n        // disable tracking inside all lifecycle hooks\r\n        // since they can potentially be called inside effects.\r\n        pauseTracking()\r\n        // Set currentInstance during hook invocation.\r\n        // This assumes the hook does not synchronously trigger other hooks, which\r\n        // can only be false when the user does something really funky.\r\n        setCurrentInstance(target)\r\n        const res = callWithAsyncErrorHandling(hook, target, type, args)\r\n        unsetCurrentInstance()\r\n        resetTracking()\r\n        return res\r\n      })\r\n    if (prepend) {\r\n      hooks.unshift(wrappedHook)\r\n    } else {\r\n      hooks.push(wrappedHook)\r\n    }\r\n    return wrappedHook\r\n  } else if (__DEV__) {\r\n    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''))\r\n    warn(\r\n      `${apiName} is called when there is no active component instance to be ` +\r\n        `associated with. ` +\r\n        `Lifecycle injection APIs can only be used during execution of setup().` +\r\n        (__FEATURE_SUSPENSE__\r\n          ? ` If you are using async setup(), make sure to register lifecycle ` +\r\n            `hooks before the first await statement.`\r\n          : ``)\r\n    )\r\n  }\r\n}\r\n\r\nexport const createHook =\r\n  <T extends Function = () => any>(lifecycle: LifecycleHooks) =>\r\n  (hook: T, target: ComponentInternalInstance | null = currentInstance) =>\r\n    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\r\n    (!isInSSRComponentSetup || lifecycle === LifecycleHooks.SERVER_PREFETCH) &&\r\n    injectHook(lifecycle, (...args: unknown[]) => hook(...args), target)\r\n\r\nexport const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT)\r\nexport const onMounted = createHook(LifecycleHooks.MOUNTED)\r\nexport const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE)\r\nexport const onUpdated = createHook(LifecycleHooks.UPDATED)\r\nexport const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT)\r\nexport const onUnmounted = createHook(LifecycleHooks.UNMOUNTED)\r\nexport const onServerPrefetch = createHook(LifecycleHooks.SERVER_PREFETCH)\r\n\r\nexport type DebuggerHook = (e: DebuggerEvent) => void\r\nexport const onRenderTriggered = createHook<DebuggerHook>(\r\n  LifecycleHooks.RENDER_TRIGGERED\r\n)\r\nexport const onRenderTracked = createHook<DebuggerHook>(\r\n  LifecycleHooks.RENDER_TRACKED\r\n)\r\n\r\nexport type ErrorCapturedHook<TError = unknown> = (\r\n  err: TError,\r\n  instance: ComponentPublicInstance | null,\r\n  info: string\r\n) => boolean | void\r\n\r\nexport function onErrorCaptured<TError = Error>(\r\n  hook: ErrorCapturedHook<TError>,\r\n  target: ComponentInternalInstance | null = currentInstance\r\n) {\r\n  injectHook(LifecycleHooks.ERROR_CAPTURED, hook, target)\r\n}\r\n", "import {\r\n  currentInstance,\r\n  ConcreteComponent,\r\n  ComponentOptions,\r\n  getComponentName\r\n} from '../component'\r\nimport { currentRenderingInstance } from '../componentRenderContext'\r\nimport { Directive } from '../directives'\r\nimport { camelize, capitalize, isString } from '@vue/shared'\r\nimport { warn } from '../warning'\r\nimport { VNodeTypes } from '../vnode'\r\n\r\nexport const COMPONENTS = 'components'\r\nexport const DIRECTIVES = 'directives'\r\nexport const FILTERS = 'filters'\r\n\r\nexport type AssetTypes = typeof COMPONENTS | typeof DIRECTIVES | typeof FILTERS\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveComponent(\r\n  name: string,\r\n  maybeSelfReference?: boolean\r\n): ConcreteComponent | string {\r\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name\r\n}\r\n\r\nexport const NULL_DYNAMIC_COMPONENT = Symbol.for('v-ndc')\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveDynamicComponent(component: unknown): VNodeTypes {\r\n  if (isString(component)) {\r\n    return resolveAsset(COMPONENTS, component, false) || component\r\n  } else {\r\n    // invalid types will fallthrough to createVNode and raise warning\r\n    return (component || NULL_DYNAMIC_COMPONENT) as any\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function resolveDirective(name: string): Directive | undefined {\r\n  return resolveAsset(DIRECTIVES, name)\r\n}\r\n\r\n/**\r\n * v2 compat only\r\n * @internal\r\n */\r\nexport function resolveFilter(name: string): Function | undefined {\r\n  return resolveAsset(FILTERS, name)\r\n}\r\n\r\n/**\r\n * @private\r\n * overload 1: components\r\n */\r\nfunction resolveAsset(\r\n  type: typeof COMPONENTS,\r\n  name: string,\r\n  warnMissing?: boolean,\r\n  maybeSelfReference?: boolean\r\n): ConcreteComponent | undefined\r\n// overload 2: directives\r\nfunction resolveAsset(\r\n  type: typeof DIRECTIVES,\r\n  name: string\r\n): Directive | undefined\r\n// implementation\r\n// overload 3: filters (compat only)\r\nfunction resolveAsset(type: typeof FILTERS, name: string): Function | undefined\r\n// implementation\r\nfunction resolveAsset(\r\n  type: AssetTypes,\r\n  name: string,\r\n  warnMissing = true,\r\n  maybeSelfReference = false\r\n) {\r\n  const instance = currentRenderingInstance || currentInstance\r\n  if (instance) {\r\n    const Component = instance.type\r\n\r\n    // explicit self name has highest priority\r\n    if (type === COMPONENTS) {\r\n      const selfName = getComponentName(\r\n        Component,\r\n        false /* do not include inferred name to avoid breaking existing code */\r\n      )\r\n      if (\r\n        selfName &&\r\n        (selfName === name ||\r\n          selfName === camelize(name) ||\r\n          selfName === capitalize(camelize(name)))\r\n      ) {\r\n        return Component\r\n      }\r\n    }\r\n\r\n    const res =\r\n      // local registration\r\n      // check instance[type] first which is resolved for options API\r\n      resolve(instance[type] || (Component as ComponentOptions)[type], name) ||\r\n      // global registration\r\n      resolve(instance.appContext[type], name)\r\n\r\n    if (!res && maybeSelfReference) {\r\n      // fallback to implicit self-reference\r\n      return Component\r\n    }\r\n\r\n    if (__DEV__ && warnMissing && !res) {\r\n      const extra =\r\n        type === COMPONENTS\r\n          ? `\\nIf this is a native custom element, make sure to exclude it from ` +\r\n            `component resolution via compilerOptions.isCustomElement.`\r\n          : ``\r\n      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`)\r\n    }\r\n\r\n    return res\r\n  } else if (__DEV__) {\r\n    warn(\r\n      `resolve${capitalize(type.slice(0, -1))} ` +\r\n        `can only be used in render() or setup().`\r\n    )\r\n  }\r\n}\r\n\r\nfunction resolve(registry: Record<string, any> | undefined, name: string) {\r\n  return (\r\n    registry &&\r\n    (registry[name] ||\r\n      registry[camelize(name)] ||\r\n      registry[capitalize(camelize(name))])\r\n  )\r\n}\r\n", "import { VNode, VNodeChild } from '../vnode'\r\nimport { isArray, isString, isObject } from '@vue/shared'\r\nimport { warn } from '../warning'\r\n\r\n/**\r\n * v-for string\r\n * @private\r\n */\r\nexport function renderList(\r\n  source: string,\r\n  renderItem: (value: string, index: number) => VNodeChild\r\n): VNodeChild[]\r\n\r\n/**\r\n * v-for number\r\n */\r\nexport function renderList(\r\n  source: number,\r\n  renderItem: (value: number, index: number) => VNodeChild\r\n): VNodeChild[]\r\n\r\n/**\r\n * v-for array\r\n */\r\nexport function renderList<T>(\r\n  source: T[],\r\n  renderItem: (value: T, index: number) => VNodeChild\r\n): VNodeChild[]\r\n\r\n/**\r\n * v-for iterable\r\n */\r\nexport function renderList<T>(\r\n  source: Iterable<T>,\r\n  renderItem: (value: T, index: number) => VNodeChild\r\n): VNodeChild[]\r\n\r\n/**\r\n * v-for object\r\n */\r\nexport function renderList<T>(\r\n  source: T,\r\n  renderItem: <K extends keyof T>(\r\n    value: T[K],\r\n    key: K,\r\n    index: number\r\n  ) => VNodeChild\r\n): VNodeChild[]\r\n\r\n/**\r\n * Actual implementation\r\n */\r\nexport function renderList(\r\n  source: any,\r\n  renderItem: (...args: any[]) => VNodeChild,\r\n  cache?: any[],\r\n  index?: number\r\n): VNodeChild[] {\r\n  let ret: VNodeChild[]\r\n  const cached = (cache && cache[index!]) as VNode[] | undefined\r\n\r\n  if (isArray(source) || isString(source)) {\r\n    ret = new Array(source.length)\r\n    for (let i = 0, l = source.length; i < l; i++) {\r\n      ret[i] = renderItem(source[i], i, undefined, cached && cached[i])\r\n    }\r\n  } else if (typeof source === 'number') {\r\n    if (__DEV__ && !Number.isInteger(source)) {\r\n      warn(`The v-for range expect an integer value but got ${source}.`)\r\n    }\r\n    ret = new Array(source)\r\n    for (let i = 0; i < source; i++) {\r\n      ret[i] = renderItem(i + 1, i, undefined, cached && cached[i])\r\n    }\r\n  } else if (isObject(source)) {\r\n    if (source[Symbol.iterator as any]) {\r\n      ret = Array.from(source as Iterable<any>, (item, i) =>\r\n        renderItem(item, i, undefined, cached && cached[i])\r\n      )\r\n    } else {\r\n      const keys = Object.keys(source)\r\n      ret = new Array(keys.length)\r\n      for (let i = 0, l = keys.length; i < l; i++) {\r\n        const key = keys[i]\r\n        ret[i] = renderItem(source[key], key, i, cached && cached[i])\r\n      }\r\n    }\r\n  } else {\r\n    ret = []\r\n  }\r\n\r\n  if (cache) {\r\n    cache[index!] = ret\r\n  }\r\n  return ret\r\n}\r\n", "import { isArray } from '@vue/shared'\r\nimport { VNode } from '../vnode'\r\n\r\n// #6651 res can be undefined in SSR in string push mode\r\ntype SSRSlot = (...args: any[]) => VNode[] | undefined\r\n\r\ninterface CompiledSlotDescriptor {\r\n  name: string\r\n  fn: SSRSlot\r\n  key?: string\r\n}\r\n\r\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nexport function createSlots(\r\n  slots: Record<string, SSRSlot>,\r\n  dynamicSlots: (\r\n    | CompiledSlotDescriptor\r\n    | CompiledSlotDescriptor[]\r\n    | undefined\r\n  )[]\r\n): Record<string, SSRSlot> {\r\n  for (let i = 0; i < dynamicSlots.length; i++) {\r\n    const slot = dynamicSlots[i]\r\n    // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n    if (isArray(slot)) {\r\n      for (let j = 0; j < slot.length; j++) {\r\n        slots[slot[j].name] = slot[j].fn\r\n      }\r\n    } else if (slot) {\r\n      // conditional single slot generated by <template v-if=\"...\" #foo>\r\n      slots[slot.name] = slot.key\r\n        ? (...args: any[]) => {\r\n            const res = slot.fn(...args)\r\n            // attach branch key so each conditional branch is considered a\r\n            // different fragment\r\n            if (res) (res as any).key = slot.key\r\n            return res\r\n          }\r\n        : slot.fn\r\n    }\r\n  }\r\n  return slots\r\n}\r\n", "import { Data } from '../component'\r\nimport { Slots, RawSlots } from '../componentSlots'\r\nimport {\r\n  ContextualRenderFn,\r\n  currentRenderingInstance\r\n} from '../componentRenderContext'\r\nimport {\r\n  Comment,\r\n  isVNode,\r\n  VNodeArrayChildren,\r\n  openBlock,\r\n  createBlock,\r\n  Fragment,\r\n  VNode\r\n} from '../vnode'\r\nimport { PatchFlags, SlotFlags } from '@vue/shared'\r\nimport { warn } from '../warning'\r\nimport { createVNode } from '@vue/runtime-core'\r\nimport { isAsyncWrapper } from '../apiAsyncComponent'\r\n\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nexport function renderSlot(\r\n  slots: Slots,\r\n  name: string,\r\n  props: Data = {},\r\n  // this is not a user-facing function, so the fallback is always generated by\r\n  // the compiler and guaranteed to be a function returning an array\r\n  fallback?: () => VNodeArrayChildren,\r\n  noSlotted?: boolean\r\n): VNode {\r\n  if (\r\n    currentRenderingInstance!.isCE ||\r\n    (currentRenderingInstance!.parent &&\r\n      isAsyncWrapper(currentRenderingInstance!.parent) &&\r\n      currentRenderingInstance!.parent.isCE)\r\n  ) {\r\n    if (name !== 'default') props.name = name\r\n    return createVNode('slot', props, fallback && fallback())\r\n  }\r\n\r\n  let slot = slots[name]\r\n\r\n  if (__DEV__ && slot && slot.length > 1) {\r\n    warn(\r\n      `SSR-optimized slot function detected in a non-SSR-optimized render ` +\r\n        `function. You need to mark this component with $dynamic-slots in the ` +\r\n        `parent template.`\r\n    )\r\n    slot = () => []\r\n  }\r\n\r\n  // a compiled slot disables block tracking by default to avoid manual\r\n  // invocation interfering with template-based block tracking, but in\r\n  // `renderSlot` we can be sure that it's template-based so we can force\r\n  // enable it.\r\n  if (slot && (slot as ContextualRenderFn)._c) {\r\n    ;(slot as ContextualRenderFn)._d = false\r\n  }\r\n  openBlock()\r\n  const validSlotContent = slot && ensureValidVNode(slot(props))\r\n  const rendered = createBlock(\r\n    Fragment,\r\n    {\r\n      key:\r\n        props.key ||\r\n        // slot content array of a dynamic conditional slot may have a branch\r\n        // key attached in the `createSlots` helper, respect that\r\n        (validSlotContent && (validSlotContent as any).key) ||\r\n        `_${name}`\r\n    },\r\n    validSlotContent || (fallback ? fallback() : []),\r\n    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE\r\n      ? PatchFlags.STABLE_FRAGMENT\r\n      : PatchFlags.BAIL\r\n  )\r\n  if (!noSlotted && rendered.scopeId) {\r\n    rendered.slotScopeIds = [rendered.scopeId + '-s']\r\n  }\r\n  if (slot && (slot as ContextualRenderFn)._c) {\r\n    ;(slot as ContextualRenderFn)._d = true\r\n  }\r\n  return rendered\r\n}\r\n\r\nfunction ensureValidVNode(vnodes: VNodeArrayChildren) {\r\n  return vnodes.some(child => {\r\n    if (!isVNode(child)) return true\r\n    if (child.type === Comment) return false\r\n    if (\r\n      child.type === Fragment &&\r\n      !ensureValidVNode(child.children as VNodeArrayChildren)\r\n    )\r\n      return false\r\n    return true\r\n  })\r\n    ? vnodes\r\n    : null\r\n}\r\n", "import { toHandlerKey, isObject } from '@vue/shared'\r\nimport { warn } from '../warning'\r\n\r\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\r\nexport function toHandlers(\r\n  obj: Record<string, any>,\r\n  preserveCaseIfNecessary?: boolean\r\n): Record<string, any> {\r\n  const ret: Record<string, any> = {}\r\n  if (__DEV__ && !isObject(obj)) {\r\n    warn(`v-on with no argument expects an object value.`)\r\n    return ret\r\n  }\r\n  for (const key in obj) {\r\n    ret[\r\n      preserveCaseIfNecessary && /[A-Z]/.test(key)\r\n        ? `on:${key}`\r\n        : toHandlerKey(key)\r\n    ] = obj[key]\r\n  }\r\n  return ret\r\n}\r\n", "import {\r\n  ComponentInternalInstance,\r\n  Data,\r\n  getExposeProxy,\r\n  isStatefulComponent\r\n} from './component'\r\nimport { nextTick, queueJob } from './scheduler'\r\nimport { instanceWatch, WatchOptions, WatchStopHandle } from './apiWatch'\r\nimport {\r\n  EMPTY_OBJ,\r\n  hasOwn,\r\n  isGloballyAllowed,\r\n  NOOP,\r\n  extend,\r\n  isString,\r\n  isFunction,\r\n  UnionToIntersection,\r\n  Prettify,\r\n  IfAny\r\n} from '@vue/shared'\r\nimport {\r\n  toRaw,\r\n  shallowReadonly,\r\n  track,\r\n  TrackOpTypes,\r\n  ShallowUnwrapRef,\r\n  UnwrapNestedRefs\r\n} from '@vue/reactivity'\r\nimport {\r\n  ExtractComputedReturns,\r\n  ComponentOptionsBase,\r\n  ComputedOptions,\r\n  MethodOptions,\r\n  ComponentOptionsMixin,\r\n  OptionTypesType,\r\n  OptionTypesKeys,\r\n  resolveMergedOptions,\r\n  shouldCacheAccess,\r\n  MergedComponentOptionsOverride,\r\n  InjectToObject,\r\n  ComponentInjectOptions\r\n} from './componentOptions'\r\nimport { EmitsOptions, EmitFn } from './componentEmits'\r\nimport { SlotsType, UnwrapSlotsType } from './componentSlots'\r\nimport { markAttrsAccessed } from './componentRenderUtils'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { warn } from './warning'\r\nimport { installCompatInstanceProperties } from './compat/instance'\r\n\r\n/**\r\n * Custom properties added to component instances in any way and can be accessed through `this`\r\n *\r\n * @example\r\n * Here is an example of adding a property `$router` to every component instance:\r\n * ```ts\r\n * import { createApp } from 'vue'\r\n * import { Router, createRouter } from 'vue-router'\r\n *\r\n * declare module '@vue/runtime-core' {\r\n *   interface ComponentCustomProperties {\r\n *     $router: Router\r\n *   }\r\n * }\r\n *\r\n * // effectively adding the router to every component instance\r\n * const app = createApp({})\r\n * const router = createRouter()\r\n * app.config.globalProperties.$router = router\r\n *\r\n * const vm = app.mount('#app')\r\n * // we can access the router from the instance\r\n * vm.$router.push('/')\r\n * ```\r\n */\r\nexport interface ComponentCustomProperties {}\r\n\r\ntype IsDefaultMixinComponent<T> = T extends ComponentOptionsMixin\r\n  ? ComponentOptionsMixin extends T\r\n    ? true\r\n    : false\r\n  : false\r\n\r\ntype MixinToOptionTypes<T> = T extends ComponentOptionsBase<\r\n  infer P,\r\n  infer B,\r\n  infer D,\r\n  infer C,\r\n  infer M,\r\n  infer Mixin,\r\n  infer Extends,\r\n  any,\r\n  any,\r\n  infer Defaults,\r\n  any,\r\n  any,\r\n  any\r\n>\r\n  ? OptionTypesType<P & {}, B & {}, D & {}, C & {}, M & {}, Defaults & {}> &\r\n      IntersectionMixin<Mixin> &\r\n      IntersectionMixin<Extends>\r\n  : never\r\n\r\n// ExtractMixin(map type) is used to resolve circularly references\r\ntype ExtractMixin<T> = {\r\n  Mixin: MixinToOptionTypes<T>\r\n}[T extends ComponentOptionsMixin ? 'Mixin' : never]\r\n\r\nexport type IntersectionMixin<T> = IsDefaultMixinComponent<T> extends true\r\n  ? OptionTypesType\r\n  : UnionToIntersection<ExtractMixin<T>>\r\n\r\nexport type UnwrapMixinsType<\r\n  T,\r\n  Type extends OptionTypesKeys\r\n> = T extends OptionTypesType ? T[Type] : never\r\n\r\ntype EnsureNonVoid<T> = T extends void ? {} : T\r\n\r\nexport type ComponentPublicInstanceConstructor<\r\n  T extends ComponentPublicInstance<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M\r\n  > = ComponentPublicInstance<any>,\r\n  Props = any,\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions\r\n> = {\r\n  __isFragment?: never\r\n  __isTeleport?: never\r\n  __isSuspense?: never\r\n  new (...args: any[]): T\r\n}\r\n\r\nexport type CreateComponentPublicInstance<\r\n  P = {},\r\n  B = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = {},\r\n  PublicProps = P,\r\n  Defaults = {},\r\n  MakeDefaultsOptional extends boolean = false,\r\n  I extends ComponentInjectOptions = {},\r\n  S extends SlotsType = {},\r\n  PublicMixin = IntersectionMixin<Mixin> & IntersectionMixin<Extends>,\r\n  PublicP = UnwrapMixinsType<PublicMixin, 'P'> & EnsureNonVoid<P>,\r\n  PublicB = UnwrapMixinsType<PublicMixin, 'B'> & EnsureNonVoid<B>,\r\n  PublicD = UnwrapMixinsType<PublicMixin, 'D'> & EnsureNonVoid<D>,\r\n  PublicC extends ComputedOptions = UnwrapMixinsType<PublicMixin, 'C'> &\r\n    EnsureNonVoid<C>,\r\n  PublicM extends MethodOptions = UnwrapMixinsType<PublicMixin, 'M'> &\r\n    EnsureNonVoid<M>,\r\n  PublicDefaults = UnwrapMixinsType<PublicMixin, 'Defaults'> &\r\n    EnsureNonVoid<Defaults>\r\n> = ComponentPublicInstance<\r\n  PublicP,\r\n  PublicB,\r\n  PublicD,\r\n  PublicC,\r\n  PublicM,\r\n  E,\r\n  PublicProps,\r\n  PublicDefaults,\r\n  MakeDefaultsOptional,\r\n  ComponentOptionsBase<\r\n    P,\r\n    B,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    string,\r\n    Defaults,\r\n    {},\r\n    string,\r\n    S\r\n  >,\r\n  I,\r\n  S\r\n>\r\n// public properties exposed on the proxy, which is used as the render context\r\n// in templates (as `this` in the render option)\r\nexport type ComponentPublicInstance<\r\n  P = {}, // props type extracted from props option\r\n  B = {}, // raw bindings returned from setup()\r\n  D = {}, // return from data()\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  E extends EmitsOptions = {},\r\n  PublicProps = P,\r\n  Defaults = {},\r\n  MakeDefaultsOptional extends boolean = false,\r\n  Options = ComponentOptionsBase<any, any, any, any, any, any, any, any, any>,\r\n  I extends ComponentInjectOptions = {},\r\n  S extends SlotsType = {}\r\n> = {\r\n  $: ComponentInternalInstance\r\n  $data: D\r\n  $props: MakeDefaultsOptional extends true\r\n    ? Partial<Defaults> & Omit<Prettify<P> & PublicProps, keyof Defaults>\r\n    : Prettify<P> & PublicProps\r\n  $attrs: Data\r\n  $refs: Data\r\n  $slots: UnwrapSlotsType<S>\r\n  $root: ComponentPublicInstance | null\r\n  $parent: ComponentPublicInstance | null\r\n  $emit: EmitFn<E>\r\n  $el: any\r\n  $options: Options & MergedComponentOptionsOverride\r\n  $forceUpdate: () => void\r\n  $nextTick: typeof nextTick\r\n  $watch<T extends string | ((...args: any) => any)>(\r\n    source: T,\r\n    cb: T extends (...args: any) => infer R\r\n      ? (...args: [R, R]) => any\r\n      : (...args: any) => any,\r\n    options?: WatchOptions\r\n  ): WatchStopHandle\r\n} & IfAny<P, P, Omit<P, keyof ShallowUnwrapRef<B>>> &\r\n  ShallowUnwrapRef<B> &\r\n  UnwrapNestedRefs<D> &\r\n  ExtractComputedReturns<C> &\r\n  M &\r\n  ComponentCustomProperties &\r\n  InjectToObject<I>\r\n\r\nexport type PublicPropertiesMap = Record<\r\n  string,\r\n  (i: ComponentInternalInstance) => any\r\n>\r\n\r\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (\r\n  i: ComponentInternalInstance | null\r\n): ComponentPublicInstance | ComponentInternalInstance['exposed'] | null => {\r\n  if (!i) return null\r\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy\r\n  return getPublicInstance(i.parent)\r\n}\r\n\r\nexport const publicPropertiesMap: PublicPropertiesMap =\r\n  // Move PURE marker to new line to workaround compiler discarding it\r\n  // due to type annotation\r\n  /*#__PURE__*/ extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (__DEV__ ? shallowReadonly(i.props) : i.props),\r\n    $attrs: i => (__DEV__ ? shallowReadonly(i.attrs) : i.attrs),\r\n    $slots: i => (__DEV__ ? shallowReadonly(i.slots) : i.slots),\r\n    $refs: i => (__DEV__ ? shallowReadonly(i.refs) : i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (__FEATURE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\r\n    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\r\n    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy!)),\r\n    $watch: i => (__FEATURE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\r\n  } as PublicPropertiesMap)\r\n\r\nif (__COMPAT__) {\r\n  installCompatInstanceProperties(publicPropertiesMap)\r\n}\r\n\r\nconst enum AccessTypes {\r\n  OTHER,\r\n  SETUP,\r\n  DATA,\r\n  PROPS,\r\n  CONTEXT\r\n}\r\n\r\nexport interface ComponentRenderContext {\r\n  [key: string]: any\r\n  _: ComponentInternalInstance\r\n}\r\n\r\nexport const isReservedPrefix = (key: string) => key === '_' || key === '$'\r\n\r\nconst hasSetupBinding = (state: Data, key: string) =>\r\n  state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key)\r\n\r\nexport const PublicInstanceProxyHandlers: ProxyHandler<any> = {\r\n  get({ _: instance }: ComponentRenderContext, key: string) {\r\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\r\n      instance\r\n\r\n    // for internal formatters to know that this is a Vue instance\r\n    if (__DEV__ && key === '__isVue') {\r\n      return true\r\n    }\r\n\r\n    // data / props / ctx\r\n    // This getter gets called for every property access on the render context\r\n    // during render and is a major hotspot. The most expensive part of this\r\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n    // access on a plain object, so we use an accessCache object (with null\r\n    // prototype) to memoize what access type a key corresponds to.\r\n    let normalizedProps\r\n    if (key[0] !== '$') {\r\n      const n = accessCache![key]\r\n      if (n !== undefined) {\r\n        switch (n) {\r\n          case AccessTypes.SETUP:\r\n            return setupState[key]\r\n          case AccessTypes.DATA:\r\n            return data[key]\r\n          case AccessTypes.CONTEXT:\r\n            return ctx[key]\r\n          case AccessTypes.PROPS:\r\n            return props![key]\r\n          // default: just fallthrough\r\n        }\r\n      } else if (hasSetupBinding(setupState, key)) {\r\n        accessCache![key] = AccessTypes.SETUP\r\n        return setupState[key]\r\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n        accessCache![key] = AccessTypes.DATA\r\n        return data[key]\r\n      } else if (\r\n        // only cache other properties when instance has declared (thus stable)\r\n        // props\r\n        (normalizedProps = instance.propsOptions[0]) &&\r\n        hasOwn(normalizedProps, key)\r\n      ) {\r\n        accessCache![key] = AccessTypes.PROPS\r\n        return props![key]\r\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n        accessCache![key] = AccessTypes.CONTEXT\r\n        return ctx[key]\r\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\r\n        accessCache![key] = AccessTypes.OTHER\r\n      }\r\n    }\r\n\r\n    const publicGetter = publicPropertiesMap[key]\r\n    let cssModule, globalProperties\r\n    // public $xxx properties\r\n    if (publicGetter) {\r\n      if (key === '$attrs') {\r\n        track(instance, TrackOpTypes.GET, key)\r\n        __DEV__ && markAttrsAccessed()\r\n      } else if (__DEV__ && key === '$slots') {\r\n        track(instance, TrackOpTypes.GET, key)\r\n      }\r\n      return publicGetter(instance)\r\n    } else if (\r\n      // css module (injected by vue-loader)\r\n      (cssModule = type.__cssModules) &&\r\n      (cssModule = cssModule[key])\r\n    ) {\r\n      return cssModule\r\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\r\n      // user may set custom properties to `this` that start with `$`\r\n      accessCache![key] = AccessTypes.CONTEXT\r\n      return ctx[key]\r\n    } else if (\r\n      // global properties\r\n      ((globalProperties = appContext.config.globalProperties),\r\n      hasOwn(globalProperties, key))\r\n    ) {\r\n      if (__COMPAT__) {\r\n        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!\r\n        if (desc.get) {\r\n          return desc.get.call(instance.proxy)\r\n        } else {\r\n          const val = globalProperties[key]\r\n          return isFunction(val)\r\n            ? Object.assign(val.bind(instance.proxy), val)\r\n            : val\r\n        }\r\n      } else {\r\n        return globalProperties[key]\r\n      }\r\n    } else if (\r\n      __DEV__ &&\r\n      currentRenderingInstance &&\r\n      (!isString(key) ||\r\n        // #1091 avoid internal isRef/isVNode checks on component instance leading\r\n        // to infinite warning loop\r\n        key.indexOf('__v') !== 0)\r\n    ) {\r\n      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {\r\n        warn(\r\n          `Property ${JSON.stringify(\r\n            key\r\n          )} must be accessed via $data because it starts with a reserved ` +\r\n            `character (\"$\" or \"_\") and is not proxied on the render context.`\r\n        )\r\n      } else if (instance === currentRenderingInstance) {\r\n        warn(\r\n          `Property ${JSON.stringify(key)} was accessed during render ` +\r\n            `but is not defined on instance.`\r\n        )\r\n      }\r\n    }\r\n  },\r\n\r\n  set(\r\n    { _: instance }: ComponentRenderContext,\r\n    key: string,\r\n    value: any\r\n  ): boolean {\r\n    const { data, setupState, ctx } = instance\r\n    if (hasSetupBinding(setupState, key)) {\r\n      setupState[key] = value\r\n      return true\r\n    } else if (\r\n      __DEV__ &&\r\n      setupState.__isScriptSetup &&\r\n      hasOwn(setupState, key)\r\n    ) {\r\n      warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`)\r\n      return false\r\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\r\n      data[key] = value\r\n      return true\r\n    } else if (hasOwn(instance.props, key)) {\r\n      __DEV__ && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\r\n      return false\r\n    }\r\n    if (key[0] === '$' && key.slice(1) in instance) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Attempting to mutate public property \"${key}\". ` +\r\n            `Properties starting with $ are reserved and readonly.`\r\n        )\r\n      return false\r\n    } else {\r\n      if (__DEV__ && key in instance.appContext.config.globalProperties) {\r\n        Object.defineProperty(ctx, key, {\r\n          enumerable: true,\r\n          configurable: true,\r\n          value\r\n        })\r\n      } else {\r\n        ctx[key] = value\r\n      }\r\n    }\r\n    return true\r\n  },\r\n\r\n  has(\r\n    {\r\n      _: { data, setupState, accessCache, ctx, appContext, propsOptions }\r\n    }: ComponentRenderContext,\r\n    key: string\r\n  ) {\r\n    let normalizedProps\r\n    return (\r\n      !!accessCache![key] ||\r\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\r\n      hasSetupBinding(setupState, key) ||\r\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\r\n      hasOwn(ctx, key) ||\r\n      hasOwn(publicPropertiesMap, key) ||\r\n      hasOwn(appContext.config.globalProperties, key)\r\n    )\r\n  },\r\n\r\n  defineProperty(\r\n    target: ComponentRenderContext,\r\n    key: string,\r\n    descriptor: PropertyDescriptor\r\n  ) {\r\n    if (descriptor.get != null) {\r\n      // invalidate key cache of a getter based property #5417\r\n      target._.accessCache![key] = 0\r\n    } else if (hasOwn(descriptor, 'value')) {\r\n      this.set!(target, key, descriptor.value, null)\r\n    }\r\n    return Reflect.defineProperty(target, key, descriptor)\r\n  }\r\n}\r\n\r\nif (__DEV__ && !__TEST__) {\r\n  PublicInstanceProxyHandlers.ownKeys = (target: ComponentRenderContext) => {\r\n    warn(\r\n      `Avoid app logic that relies on enumerating keys on a component instance. ` +\r\n        `The keys will be empty in production mode to avoid performance overhead.`\r\n    )\r\n    return Reflect.ownKeys(target)\r\n  }\r\n}\r\n\r\nexport const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend(\r\n  {},\r\n  PublicInstanceProxyHandlers,\r\n  {\r\n    get(target: ComponentRenderContext, key: string) {\r\n      // fast path for unscopables when using `with` block\r\n      if ((key as any) === Symbol.unscopables) {\r\n        return\r\n      }\r\n      return PublicInstanceProxyHandlers.get!(target, key, target)\r\n    },\r\n    has(_: ComponentRenderContext, key: string) {\r\n      const has = key[0] !== '_' && !isGloballyAllowed(key)\r\n      if (__DEV__ && !has && PublicInstanceProxyHandlers.has!(_, key)) {\r\n        warn(\r\n          `Property ${JSON.stringify(\r\n            key\r\n          )} should not start with _ which is a reserved prefix for Vue internals.`\r\n        )\r\n      }\r\n      return has\r\n    }\r\n  }\r\n)\r\n\r\n// dev only\r\n// In dev mode, the proxy target exposes the same properties as seen on `this`\r\n// for easier console inspection. In prod mode it will be an empty object so\r\n// these properties definitions can be skipped.\r\nexport function createDevRenderContext(instance: ComponentInternalInstance) {\r\n  const target: Record<string, any> = {}\r\n\r\n  // expose internal instance for proxy handlers\r\n  Object.defineProperty(target, `_`, {\r\n    configurable: true,\r\n    enumerable: false,\r\n    get: () => instance\r\n  })\r\n\r\n  // expose public properties\r\n  Object.keys(publicPropertiesMap).forEach(key => {\r\n    Object.defineProperty(target, key, {\r\n      configurable: true,\r\n      enumerable: false,\r\n      get: () => publicPropertiesMap[key](instance),\r\n      // intercepted by the proxy so no need for implementation,\r\n      // but needed to prevent set errors\r\n      set: NOOP\r\n    })\r\n  })\r\n\r\n  return target as ComponentRenderContext\r\n}\r\n\r\n// dev only\r\nexport function exposePropsOnRenderContext(\r\n  instance: ComponentInternalInstance\r\n) {\r\n  const {\r\n    ctx,\r\n    propsOptions: [propsOptions]\r\n  } = instance\r\n  if (propsOptions) {\r\n    Object.keys(propsOptions).forEach(key => {\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => instance.props[key],\r\n        set: NOOP\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\n// dev only\r\nexport function exposeSetupStateOnRenderContext(\r\n  instance: ComponentInternalInstance\r\n) {\r\n  const { ctx, setupState } = instance\r\n  Object.keys(toRaw(setupState)).forEach(key => {\r\n    if (!setupState.__isScriptSetup) {\r\n      if (isReservedPrefix(key[0])) {\r\n        warn(\r\n          `setup() return property ${JSON.stringify(\r\n            key\r\n          )} should not start with \"$\" or \"_\" ` +\r\n            `which are reserved prefixes for Vue internals.`\r\n        )\r\n        return\r\n      }\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => setupState[key],\r\n        set: NOOP\r\n      })\r\n    }\r\n  })\r\n}\r\n", "import {\r\n  isArray,\r\n  isPromise,\r\n  isFunction,\r\n  Prettify,\r\n  UnionToIntersection,\r\n  extend,\r\n  LooseRequired\r\n} from '@vue/shared'\r\nimport {\r\n  getCurrentInstance,\r\n  setCurrentInstance,\r\n  SetupContext,\r\n  createSetupContext,\r\n  unsetCurrentInstance\r\n} from './component'\r\nimport { EmitFn, EmitsOptions, ObjectEmitsOptions } from './componentEmits'\r\nimport {\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithoutProps,\r\n  ComputedOptions,\r\n  MethodOptions\r\n} from './componentOptions'\r\nimport {\r\n  ComponentPropsOptions,\r\n  ComponentObjectPropsOptions,\r\n  ExtractPropTypes,\r\n  NormalizedProps,\r\n  PropOptions\r\n} from './componentProps'\r\nimport { warn } from './warning'\r\nimport { SlotsType, StrictUnwrapSlotsType } from './componentSlots'\r\nimport { Ref, ref } from '@vue/reactivity'\r\nimport { watch } from './apiWatch'\r\n\r\n// dev only\r\nconst warnRuntimeUsage = (method: string) =>\r\n  warn(\r\n    `${method}() is a compiler-hint helper that is only usable inside ` +\r\n      `<script setup> of a single file component. Its arguments should be ` +\r\n      `compiled away and passing it at runtime has no effect.`\r\n  )\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring component props. The\r\n * expected argument is the same as the component `props` option.\r\n *\r\n * Example runtime declaration:\r\n * ```js\r\n * // using Array syntax\r\n * const props = defineProps(['foo', 'bar'])\r\n * // using Object syntax\r\n * const props = defineProps({\r\n *   foo: String,\r\n *   bar: {\r\n *     type: Number,\r\n *     required: true\r\n *   }\r\n * })\r\n * ```\r\n *\r\n * Equivalent type-based declaration:\r\n * ```ts\r\n * // will be compiled into equivalent runtime declarations\r\n * const props = defineProps<{\r\n *   foo?: string\r\n *   bar: number\r\n * }>()\r\n * ```\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n */\r\n// overload 1: runtime props w/ array\r\nexport function defineProps<PropNames extends string = string>(\r\n  props: PropNames[]\r\n): Prettify<Readonly<{ [key in PropNames]?: any }>>\r\n// overload 2: runtime props w/ object\r\nexport function defineProps<\r\n  PP extends ComponentObjectPropsOptions = ComponentObjectPropsOptions\r\n>(props: PP): Prettify<Readonly<ExtractPropTypes<PP>>>\r\n// overload 3: typed-based declaration\r\nexport function defineProps<TypeProps>(): DefineProps<\r\n  LooseRequired<TypeProps>,\r\n  BooleanKey<TypeProps>\r\n>\r\n// implementation\r\nexport function defineProps() {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineProps`)\r\n  }\r\n  return null as any\r\n}\r\n\r\ntype DefineProps<T, BKeys extends keyof T> = Readonly<T> & {\r\n  readonly [K in BKeys]-?: boolean\r\n}\r\n\r\ntype BooleanKey<T, K extends keyof T = keyof T> = K extends any\r\n  ? [T[K]] extends [boolean | undefined]\r\n    ? K\r\n    : never\r\n  : never\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's emitted\r\n * events. The expected argument is the same as the component `emits` option.\r\n *\r\n * Example runtime declaration:\r\n * ```js\r\n * const emit = defineEmits(['change', 'update'])\r\n * ```\r\n *\r\n * Example type-based declaration:\r\n * ```ts\r\n * const emit = defineEmits<{\r\n *   // <eventName>: <expected arguments>\r\n *   change: []\r\n *   update: [value: string] // named tuple syntax\r\n * }>()\r\n *\r\n * emit('change')\r\n * emit('update', 1)\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineprops-defineemits}\r\n */\r\n// overload 1: runtime emits w/ array\r\nexport function defineEmits<EE extends string = string>(\r\n  emitOptions: EE[]\r\n): EmitFn<EE[]>\r\nexport function defineEmits<E extends EmitsOptions = EmitsOptions>(\r\n  emitOptions: E\r\n): EmitFn<E>\r\nexport function defineEmits<\r\n  T extends ((...args: any[]) => any) | Record<string, any[]>\r\n>(): T extends (...args: any[]) => any ? T : ShortEmits<T>\r\n// implementation\r\nexport function defineEmits() {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineEmits`)\r\n  }\r\n  return null as any\r\n}\r\n\r\ntype RecordToUnion<T extends Record<string, any>> = T[keyof T]\r\n\r\ntype ShortEmits<T extends Record<string, any>> = UnionToIntersection<\r\n  RecordToUnion<{\r\n    [K in keyof T]: (evt: K, ...args: T[K]) => void\r\n  }>\r\n>\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's exposed\r\n * instance properties when it is accessed by a parent component via template\r\n * refs.\r\n *\r\n * `<script setup>` components are closed by default - i.e. variables inside\r\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\r\n * via `defineExpose`.\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the\r\n * output and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineexpose}\r\n */\r\nexport function defineExpose<\r\n  Exposed extends Record<string, any> = Record<string, any>\r\n>(exposed?: Exposed) {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineExpose`)\r\n  }\r\n}\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for declaring a component's additional\r\n * options. This should be used only for options that cannot be expressed via\r\n * Composition API - e.g. `inheritAttrs`.\r\n *\r\n * @see {@link https://vuejs.org/api/sfc-script-setup.html#defineoptions}\r\n */\r\nexport function defineOptions<\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin\r\n>(\r\n  options?: ComponentOptionsWithoutProps<\r\n    {},\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends\r\n  > & { emits?: undefined; expose?: undefined; slots?: undefined }\r\n): void {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineOptions`)\r\n  }\r\n}\r\n\r\nexport function defineSlots<\r\n  S extends Record<string, any> = Record<string, any>\r\n>(): StrictUnwrapSlotsType<SlotsType<S>> {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`defineSlots`)\r\n  }\r\n  return null as any\r\n}\r\n\r\n/**\r\n * (**Experimental**) Vue `<script setup>` compiler macro for declaring a\r\n * two-way binding prop that can be consumed via `v-model` from the parent\r\n * component. This will declare a prop with the same name and a corresponding\r\n * `update:propName` event.\r\n *\r\n * If the first argument is a string, it will be used as the prop name;\r\n * Otherwise the prop name will default to \"modelValue\". In both cases, you\r\n * can also pass an additional object which will be used as the prop's options.\r\n *\r\n * The options object can also specify an additional option, `local`. When set\r\n * to `true`, the ref can be locally mutated even if the parent did not pass\r\n * the matching `v-model`.\r\n *\r\n * @example\r\n * ```ts\r\n * // default model (consumed via `v-model`)\r\n * const modelValue = defineModel<string>()\r\n * modelValue.value = \"hello\"\r\n *\r\n * // default model with options\r\n * const modelValue = defineModel<string>({ required: true })\r\n *\r\n * // with specified name (consumed via `v-model:count`)\r\n * const count = defineModel<number>('count')\r\n * count.value++\r\n *\r\n * // with specified name and default value\r\n * const count = defineModel<number>('count', { default: 0 })\r\n *\r\n * // local mutable model, can be mutated locally\r\n * // even if the parent did not pass the matching `v-model`.\r\n * const count = defineModel<number>('count', { local: true, default: 0 })\r\n * ```\r\n */\r\nexport function defineModel<T>(\r\n  options: { required: true } & PropOptions<T> & DefineModelOptions\r\n): Ref<T>\r\nexport function defineModel<T>(\r\n  options: { default: any } & PropOptions<T> & DefineModelOptions\r\n): Ref<T>\r\nexport function defineModel<T>(\r\n  options?: PropOptions<T> & DefineModelOptions\r\n): Ref<T | undefined>\r\nexport function defineModel<T>(\r\n  name: string,\r\n  options: { required: true } & PropOptions<T> & DefineModelOptions\r\n): Ref<T>\r\nexport function defineModel<T>(\r\n  name: string,\r\n  options: { default: any } & PropOptions<T> & DefineModelOptions\r\n): Ref<T>\r\nexport function defineModel<T>(\r\n  name: string,\r\n  options?: PropOptions<T> & DefineModelOptions\r\n): Ref<T | undefined>\r\nexport function defineModel(): any {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage('defineModel')\r\n  }\r\n}\r\n\r\ninterface DefineModelOptions {\r\n  local?: boolean\r\n}\r\n\r\ntype NotUndefined<T> = T extends undefined ? never : T\r\n\r\ntype InferDefaults<T> = {\r\n  [K in keyof T]?: InferDefault<T, T[K]>\r\n}\r\n\r\ntype NativeType = null | number | string | boolean | symbol | Function\r\n\r\ntype InferDefault<P, T> =\r\n  | ((props: P) => T & {})\r\n  | (T extends NativeType ? T : never)\r\n\r\ntype PropsWithDefaults<\r\n  T,\r\n  Defaults extends InferDefaults<T>,\r\n  BKeys extends keyof T\r\n> = Readonly<Omit<T, keyof Defaults>> & {\r\n  readonly [K in keyof Defaults]-?: K extends keyof T\r\n    ? Defaults[K] extends undefined\r\n      ? T[K]\r\n      : NotUndefined<T[K]>\r\n    : never\r\n} & {\r\n  readonly [K in BKeys]-?: K extends keyof Defaults\r\n    ? Defaults[K] extends undefined\r\n      ? boolean | undefined\r\n      : boolean\r\n    : boolean\r\n}\r\n\r\n/**\r\n * Vue `<script setup>` compiler macro for providing props default values when\r\n * using type-based `defineProps` declaration.\r\n *\r\n * Example usage:\r\n * ```ts\r\n * withDefaults(defineProps<{\r\n *   size?: number\r\n *   labels?: string[]\r\n * }>(), {\r\n *   size: 3,\r\n *   labels: () => ['default label']\r\n * })\r\n * ```\r\n *\r\n * This is only usable inside `<script setup>`, is compiled away in the output\r\n * and should **not** be actually called at runtime.\r\n *\r\n * @see {@link https://vuejs.org/guide/typescript/composition-api.html#typing-component-props}\r\n */\r\nexport function withDefaults<\r\n  T,\r\n  BKeys extends keyof T,\r\n  Defaults extends InferDefaults<T>\r\n>(\r\n  props: DefineProps<T, BKeys>,\r\n  defaults: Defaults\r\n): PropsWithDefaults<T, Defaults, BKeys> {\r\n  if (__DEV__) {\r\n    warnRuntimeUsage(`withDefaults`)\r\n  }\r\n  return null as any\r\n}\r\n\r\nexport function useSlots(): SetupContext['slots'] {\r\n  return getContext().slots\r\n}\r\n\r\nexport function useAttrs(): SetupContext['attrs'] {\r\n  return getContext().attrs\r\n}\r\n\r\nexport function useModel<T extends Record<string, any>, K extends keyof T>(\r\n  props: T,\r\n  name: K,\r\n  options?: { local?: boolean }\r\n): Ref<T[K]>\r\nexport function useModel(\r\n  props: Record<string, any>,\r\n  name: string,\r\n  options?: { local?: boolean }\r\n): Ref {\r\n  const i = getCurrentInstance()!\r\n  if (__DEV__ && !i) {\r\n    warn(`useModel() called without active instance.`)\r\n    return ref() as any\r\n  }\r\n\r\n  if (__DEV__ && !(i.propsOptions[0] as NormalizedProps)[name]) {\r\n    warn(`useModel() called with prop \"${name}\" which is not declared.`)\r\n    return ref() as any\r\n  }\r\n\r\n  if (options && options.local) {\r\n    const proxy = ref<any>(props[name])\r\n\r\n    watch(\r\n      () => props[name],\r\n      v => (proxy.value = v)\r\n    )\r\n\r\n    watch(proxy, value => {\r\n      if (value !== props[name]) {\r\n        i.emit(`update:${name}`, value)\r\n      }\r\n    })\r\n\r\n    return proxy\r\n  } else {\r\n    return {\r\n      __v_isRef: true,\r\n      get value() {\r\n        return props[name]\r\n      },\r\n      set value(value) {\r\n        i.emit(`update:${name}`, value)\r\n      }\r\n    } as any\r\n  }\r\n}\r\n\r\nfunction getContext(): SetupContext {\r\n  const i = getCurrentInstance()!\r\n  if (__DEV__ && !i) {\r\n    warn(`useContext() called without active instance.`)\r\n  }\r\n  return i.setupContext || (i.setupContext = createSetupContext(i))\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function normalizePropsOrEmits(\r\n  props: ComponentPropsOptions | EmitsOptions\r\n) {\r\n  return isArray(props)\r\n    ? props.reduce(\r\n        (normalized, p) => ((normalized[p] = null), normalized),\r\n        {} as ComponentObjectPropsOptions | ObjectEmitsOptions\r\n      )\r\n    : props\r\n}\r\n\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nexport function mergeDefaults(\r\n  raw: ComponentPropsOptions,\r\n  defaults: Record<string, any>\r\n): ComponentObjectPropsOptions {\r\n  const props = normalizePropsOrEmits(raw)\r\n  for (const key in defaults) {\r\n    if (key.startsWith('__skip')) continue\r\n    let opt = props[key]\r\n    if (opt) {\r\n      if (isArray(opt) || isFunction(opt)) {\r\n        opt = props[key] = { type: opt, default: defaults[key] }\r\n      } else {\r\n        opt.default = defaults[key]\r\n      }\r\n    } else if (opt === null) {\r\n      opt = props[key] = { default: defaults[key] }\r\n    } else if (__DEV__) {\r\n      warn(`props default key \"${key}\" has no corresponding declaration.`)\r\n    }\r\n    if (opt && defaults[`__skip_${key}`]) {\r\n      opt.skipFactory = true\r\n    }\r\n  }\r\n  return props\r\n}\r\n\r\n/**\r\n * Runtime helper for merging model declarations.\r\n * Imported by compiled code only.\r\n * @internal\r\n */\r\nexport function mergeModels(\r\n  a: ComponentPropsOptions | EmitsOptions,\r\n  b: ComponentPropsOptions | EmitsOptions\r\n) {\r\n  if (!a || !b) return a || b\r\n  if (isArray(a) && isArray(b)) return a.concat(b)\r\n  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b))\r\n}\r\n\r\n/**\r\n * Used to create a proxy for the rest element when destructuring props with\r\n * defineProps().\r\n * @internal\r\n */\r\nexport function createPropsRestProxy(\r\n  props: any,\r\n  excludedKeys: string[]\r\n): Record<string, any> {\r\n  const ret: Record<string, any> = {}\r\n  for (const key in props) {\r\n    if (!excludedKeys.includes(key)) {\r\n      Object.defineProperty(ret, key, {\r\n        enumerable: true,\r\n        get: () => props[key]\r\n      })\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\n/**\r\n * `<script setup>` helper for persisting the current instance context over\r\n * async/await flows.\r\n *\r\n * `@vue/compiler-sfc` converts the following:\r\n *\r\n * ```ts\r\n * const x = await foo()\r\n * ```\r\n *\r\n * into:\r\n *\r\n * ```ts\r\n * let __temp, __restore\r\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\r\n * ```\r\n * @internal\r\n */\r\nexport function withAsyncContext(getAwaitable: () => any) {\r\n  const ctx = getCurrentInstance()!\r\n  if (__DEV__ && !ctx) {\r\n    warn(\r\n      `withAsyncContext called without active current instance. ` +\r\n        `This is likely a bug.`\r\n    )\r\n  }\r\n  let awaitable = getAwaitable()\r\n  unsetCurrentInstance()\r\n  if (isPromise(awaitable)) {\r\n    awaitable = awaitable.catch(e => {\r\n      setCurrentInstance(ctx)\r\n      throw e\r\n    })\r\n  }\r\n  return [awaitable, () => setCurrentInstance(ctx)]\r\n}\r\n", "import {\r\n  ComponentInternalInstance,\r\n  Data,\r\n  SetupContext,\r\n  ComponentInternalOptions,\r\n  Component,\r\n  ConcreteComponent,\r\n  InternalRenderFunction\r\n} from './component'\r\nimport {\r\n  isFunction,\r\n  extend,\r\n  isString,\r\n  isObject,\r\n  isArray,\r\n  NOOP,\r\n  isPromise,\r\n  LooseRequired,\r\n  Prettify\r\n} from '@vue/shared'\r\nimport { isRef, Ref } from '@vue/reactivity'\r\nimport { computed } from './apiComputed'\r\nimport {\r\n  watch,\r\n  WatchOptions,\r\n  WatchCallback,\r\n  createPathGetter\r\n} from './apiWatch'\r\nimport { provide, inject } from './apiInject'\r\nimport {\r\n  onBeforeMount,\r\n  onMounted,\r\n  onBeforeUpdate,\r\n  onUpdated,\r\n  onErrorCaptured,\r\n  onRenderTracked,\r\n  onBeforeUnmount,\r\n  onUnmounted,\r\n  onActivated,\r\n  onDeactivated,\r\n  onRenderTriggered,\r\n  DebuggerHook,\r\n  ErrorCapturedHook,\r\n  onServerPrefetch\r\n} from './apiLifecycle'\r\nimport {\r\n  reactive,\r\n  ComputedGetter,\r\n  WritableComputedOptions\r\n} from '@vue/reactivity'\r\nimport {\r\n  ComponentObjectPropsOptions,\r\n  ExtractPropTypes,\r\n  ExtractDefaultPropTypes,\r\n  ComponentPropsOptions\r\n} from './componentProps'\r\nimport { EmitsOptions, EmitsToProps } from './componentEmits'\r\nimport { Directive } from './directives'\r\nimport {\r\n  CreateComponentPublicInstance,\r\n  ComponentPublicInstance,\r\n  isReservedPrefix,\r\n  IntersectionMixin,\r\n  UnwrapMixinsType\r\n} from './componentPublicInstance'\r\nimport { warn } from './warning'\r\nimport { VNodeChild } from './vnode'\r\nimport { callWithAsyncErrorHandling } from './errorHandling'\r\nimport { deepMergeData } from './compat/data'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport {\r\n  CompatConfig,\r\n  isCompatEnabled,\r\n  softAssertCompatEnabled\r\n} from './compat/compatConfig'\r\nimport { OptionMergeFunction } from './apiCreateApp'\r\nimport { LifecycleHooks } from './enums'\r\nimport { SlotsType } from './componentSlots'\r\nimport { normalizePropsOrEmits } from './apiSetupHelpers'\r\n\r\n/**\r\n * Interface for declaring custom options.\r\n *\r\n * @example\r\n * ```ts\r\n * declare module '@vue/runtime-core' {\r\n *   interface ComponentCustomOptions {\r\n *     beforeRouteUpdate?(\r\n *       to: Route,\r\n *       from: Route,\r\n *       next: () => void\r\n *     ): void\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport interface ComponentCustomOptions {}\r\n\r\nexport type RenderFunction = () => VNodeChild\r\n\r\nexport interface ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions,\r\n  M extends MethodOptions,\r\n  Mixin extends ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin,\r\n  E extends EmitsOptions,\r\n  EE extends string = string,\r\n  Defaults = {},\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {}\r\n> extends LegacyOptions<Props, D, C, M, Mixin, Extends, I, II>,\r\n    ComponentInternalOptions,\r\n    ComponentCustomOptions {\r\n  setup?: (\r\n    this: void,\r\n    props: LooseRequired<\r\n      Props &\r\n        Prettify<\r\n          UnwrapMixinsType<\r\n            IntersectionMixin<Mixin> & IntersectionMixin<Extends>,\r\n            'P'\r\n          >\r\n        >\r\n    >,\r\n    ctx: SetupContext<E, S>\r\n  ) => Promise<RawBindings> | RawBindings | RenderFunction | void\r\n  name?: string\r\n  template?: string | object // can be a direct DOM node\r\n  // Note: we are intentionally using the signature-less `Function` type here\r\n  // since any type with signature will cause the whole inference to fail when\r\n  // the return expression contains reference to `this`.\r\n  // Luckily `render()` doesn't need any arguments nor does it care about return\r\n  // type.\r\n  render?: Function\r\n  components?: Record<string, Component>\r\n  directives?: Record<string, Directive>\r\n  inheritAttrs?: boolean\r\n  emits?: (E | EE[]) & ThisType<void>\r\n  slots?: S\r\n  // TODO infer public instance type based on exposed keys\r\n  expose?: string[]\r\n  serverPrefetch?(): void | Promise<any>\r\n\r\n  // Runtime compiler only -----------------------------------------------------\r\n  compilerOptions?: RuntimeCompilerOptions\r\n\r\n  // Internal ------------------------------------------------------------------\r\n\r\n  /**\r\n   * SSR only. This is produced by compiler-ssr and attached in compiler-sfc\r\n   * not user facing, so the typing is lax and for test only.\r\n   * @internal\r\n   */\r\n  ssrRender?: (\r\n    ctx: any,\r\n    push: (item: any) => void,\r\n    parentInstance: ComponentInternalInstance,\r\n    attrs: Data | undefined,\r\n    // for compiler-optimized bindings\r\n    $props: ComponentInternalInstance['props'],\r\n    $setup: ComponentInternalInstance['setupState'],\r\n    $data: ComponentInternalInstance['data'],\r\n    $options: ComponentInternalInstance['ctx']\r\n  ) => void\r\n\r\n  /**\r\n   * Only generated by compiler-sfc to mark a ssr render function inlined and\r\n   * returned from setup()\r\n   * @internal\r\n   */\r\n  __ssrInlineRender?: boolean\r\n\r\n  /**\r\n   * marker for AsyncComponentWrapper\r\n   * @internal\r\n   */\r\n  __asyncLoader?: () => Promise<ConcreteComponent>\r\n  /**\r\n   * the inner component resolved by the AsyncComponentWrapper\r\n   * @internal\r\n   */\r\n  __asyncResolved?: ConcreteComponent\r\n\r\n  // Type differentiators ------------------------------------------------------\r\n\r\n  // Note these are internal but need to be exposed in d.ts for type inference\r\n  // to work!\r\n\r\n  // type-only differentiator to separate OptionWithoutProps from a constructor\r\n  // type returned by defineComponent() or FunctionalComponent\r\n  call?: (this: unknown, ...args: unknown[]) => never\r\n  // type-only differentiators for built-in Vnode types\r\n  __isFragment?: never\r\n  __isTeleport?: never\r\n  __isSuspense?: never\r\n\r\n  __defaults?: Defaults\r\n}\r\n\r\n/**\r\n * Subset of compiler options that makes sense for the runtime.\r\n */\r\nexport interface RuntimeCompilerOptions {\r\n  isCustomElement?: (tag: string) => boolean\r\n  whitespace?: 'preserve' | 'condense'\r\n  comments?: boolean\r\n  delimiters?: [string, string]\r\n}\r\n\r\nexport type ComponentOptionsWithoutProps<\r\n  Props = {},\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  PE = Props & EmitsToProps<E>\r\n> = ComponentOptionsBase<\r\n  PE,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  {},\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props?: undefined\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      PE,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      PE,\r\n      {},\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsWithArrayProps<\r\n  PropNames extends string = string,\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  Props = Prettify<Readonly<{ [key in PropNames]?: any } & EmitsToProps<E>>>\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  {},\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props: PropNames[]\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      Props,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Props,\r\n      {},\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsWithObjectProps<\r\n  PropsOptions = ComponentObjectPropsOptions,\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {},\r\n  Props = Prettify<Readonly<ExtractPropTypes<PropsOptions> & EmitsToProps<E>>>,\r\n  Defaults = ExtractDefaultPropTypes<PropsOptions>\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  EE,\r\n  Defaults,\r\n  I,\r\n  II,\r\n  S\r\n> & {\r\n  props: PropsOptions & ThisType<void>\r\n} & ThisType<\r\n    CreateComponentPublicInstance<\r\n      Props,\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Props,\r\n      Defaults,\r\n      false,\r\n      I,\r\n      S\r\n    >\r\n  >\r\n\r\nexport type ComponentOptions<\r\n  Props = {},\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = any,\r\n  M extends MethodOptions = any,\r\n  Mixin extends ComponentOptionsMixin = any,\r\n  Extends extends ComponentOptionsMixin = any,\r\n  E extends EmitsOptions = any,\r\n  S extends SlotsType = any\r\n> = ComponentOptionsBase<\r\n  Props,\r\n  RawBindings,\r\n  D,\r\n  C,\r\n  M,\r\n  Mixin,\r\n  Extends,\r\n  E,\r\n  string,\r\n  S\r\n> &\r\n  ThisType<\r\n    CreateComponentPublicInstance<\r\n      {},\r\n      RawBindings,\r\n      D,\r\n      C,\r\n      M,\r\n      Mixin,\r\n      Extends,\r\n      E,\r\n      Readonly<Props>\r\n    >\r\n  >\r\n\r\nexport type ComponentOptionsMixin = ComponentOptionsBase<\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any,\r\n  any\r\n>\r\n\r\nexport type ComputedOptions = Record<\r\n  string,\r\n  ComputedGetter<any> | WritableComputedOptions<any>\r\n>\r\n\r\nexport interface MethodOptions {\r\n  [key: string]: Function\r\n}\r\n\r\nexport type ExtractComputedReturns<T extends any> = {\r\n  [key in keyof T]: T[key] extends { get: (...args: any[]) => infer TReturn }\r\n    ? TReturn\r\n    : T[key] extends (...args: any[]) => infer TReturn\r\n      ? TReturn\r\n      : never\r\n}\r\n\r\nexport type ObjectWatchOptionItem = {\r\n  handler: WatchCallback | string\r\n} & WatchOptions\r\n\r\ntype WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem\r\n\r\ntype ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[]\r\n\r\ntype ComponentWatchOptions = Record<string, ComponentWatchOptionItem>\r\n\r\nexport type ComponentProvideOptions = ObjectProvideOptions | Function\r\n\r\ntype ObjectProvideOptions = Record<string | symbol, unknown>\r\n\r\nexport type ComponentInjectOptions = string[] | ObjectInjectOptions\r\n\r\ntype ObjectInjectOptions = Record<\r\n  string | symbol,\r\n  string | symbol | { from?: string | symbol; default?: unknown }\r\n>\r\n\r\nexport type InjectToObject<T extends ComponentInjectOptions> =\r\n  T extends string[]\r\n    ? {\r\n        [K in T[number]]?: unknown\r\n      }\r\n    : T extends ObjectInjectOptions\r\n      ? {\r\n          [K in keyof T]?: unknown\r\n        }\r\n      : never\r\n\r\ninterface LegacyOptions<\r\n  Props,\r\n  D,\r\n  C extends ComputedOptions,\r\n  M extends MethodOptions,\r\n  Mixin extends ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin,\r\n  I extends ComponentInjectOptions,\r\n  II extends string\r\n> {\r\n  compatConfig?: CompatConfig\r\n\r\n  // allow any custom options\r\n  [key: string]: any\r\n\r\n  // state\r\n  // Limitation: we cannot expose RawBindings on the `this` context for data\r\n  // since that leads to some sort of circular inference and breaks ThisType\r\n  // for the entire component.\r\n  data?: (\r\n    this: CreateComponentPublicInstance<\r\n      Props,\r\n      {},\r\n      {},\r\n      {},\r\n      MethodOptions,\r\n      Mixin,\r\n      Extends\r\n    >,\r\n    vm: CreateComponentPublicInstance<\r\n      Props,\r\n      {},\r\n      {},\r\n      {},\r\n      MethodOptions,\r\n      Mixin,\r\n      Extends\r\n    >\r\n  ) => D\r\n  computed?: C\r\n  methods?: M\r\n  watch?: ComponentWatchOptions\r\n  provide?: ComponentProvideOptions\r\n  inject?: I | II[]\r\n\r\n  // assets\r\n  filters?: Record<string, Function>\r\n\r\n  // composition\r\n  mixins?: Mixin[]\r\n  extends?: Extends\r\n\r\n  // lifecycle\r\n  beforeCreate?(): void\r\n  created?(): void\r\n  beforeMount?(): void\r\n  mounted?(): void\r\n  beforeUpdate?(): void\r\n  updated?(): void\r\n  activated?(): void\r\n  deactivated?(): void\r\n  /** @deprecated use `beforeUnmount` instead */\r\n  beforeDestroy?(): void\r\n  beforeUnmount?(): void\r\n  /** @deprecated use `unmounted` instead */\r\n  destroyed?(): void\r\n  unmounted?(): void\r\n  renderTracked?: DebuggerHook\r\n  renderTriggered?: DebuggerHook\r\n  errorCaptured?: ErrorCapturedHook\r\n\r\n  /**\r\n   * runtime compile only\r\n   * @deprecated use `compilerOptions.delimiters` instead.\r\n   */\r\n  delimiters?: [string, string]\r\n\r\n  /**\r\n   * #3468\r\n   *\r\n   * type-only, used to assist Mixin's type inference,\r\n   * typescript will try to simplify the inferred `Mixin` type,\r\n   * with the `__differentiator`, typescript won't be able to combine different mixins,\r\n   * because the `__differentiator` will be different\r\n   */\r\n  __differentiator?: keyof D | keyof C | keyof M\r\n}\r\n\r\ntype MergedHook<T = () => void> = T | T[]\r\n\r\nexport type MergedComponentOptions = ComponentOptions &\r\n  MergedComponentOptionsOverride\r\n\r\nexport type MergedComponentOptionsOverride = {\r\n  beforeCreate?: MergedHook\r\n  created?: MergedHook\r\n  beforeMount?: MergedHook\r\n  mounted?: MergedHook\r\n  beforeUpdate?: MergedHook\r\n  updated?: MergedHook\r\n  activated?: MergedHook\r\n  deactivated?: MergedHook\r\n  /** @deprecated use `beforeUnmount` instead */\r\n  beforeDestroy?: MergedHook\r\n  beforeUnmount?: MergedHook\r\n  /** @deprecated use `unmounted` instead */\r\n  destroyed?: MergedHook\r\n  unmounted?: MergedHook\r\n  renderTracked?: MergedHook<DebuggerHook>\r\n  renderTriggered?: MergedHook<DebuggerHook>\r\n  errorCaptured?: MergedHook<ErrorCapturedHook>\r\n}\r\n\r\nexport type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults'\r\n\r\nexport type OptionTypesType<\r\n  P = {},\r\n  B = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Defaults = {}\r\n> = {\r\n  P: P\r\n  B: B\r\n  D: D\r\n  C: C\r\n  M: M\r\n  Defaults: Defaults\r\n}\r\n\r\nconst enum OptionTypes {\r\n  PROPS = 'Props',\r\n  DATA = 'Data',\r\n  COMPUTED = 'Computed',\r\n  METHODS = 'Methods',\r\n  INJECT = 'Inject'\r\n}\r\n\r\nfunction createDuplicateChecker() {\r\n  const cache = Object.create(null)\r\n  return (type: OptionTypes, key: string) => {\r\n    if (cache[key]) {\r\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`)\r\n    } else {\r\n      cache[key] = type\r\n    }\r\n  }\r\n}\r\n\r\nexport let shouldCacheAccess = true\r\n\r\nexport function applyOptions(instance: ComponentInternalInstance) {\r\n  const options = resolveMergedOptions(instance)\r\n  const publicThis = instance.proxy! as any\r\n  const ctx = instance.ctx\r\n\r\n  // do not cache property access on public proxy during state initialization\r\n  shouldCacheAccess = false\r\n\r\n  // call beforeCreate first before accessing other options since\r\n  // the hook may mutate resolved options (#2791)\r\n  if (options.beforeCreate) {\r\n    callHook(options.beforeCreate, instance, LifecycleHooks.BEFORE_CREATE)\r\n  }\r\n\r\n  const {\r\n    // state\r\n    data: dataOptions,\r\n    computed: computedOptions,\r\n    methods,\r\n    watch: watchOptions,\r\n    provide: provideOptions,\r\n    inject: injectOptions,\r\n    // lifecycle\r\n    created,\r\n    beforeMount,\r\n    mounted,\r\n    beforeUpdate,\r\n    updated,\r\n    activated,\r\n    deactivated,\r\n    beforeDestroy,\r\n    beforeUnmount,\r\n    destroyed,\r\n    unmounted,\r\n    render,\r\n    renderTracked,\r\n    renderTriggered,\r\n    errorCaptured,\r\n    serverPrefetch,\r\n    // public API\r\n    expose,\r\n    inheritAttrs,\r\n    // assets\r\n    components,\r\n    directives,\r\n    filters\r\n  } = options\r\n\r\n  const checkDuplicateProperties = __DEV__ ? createDuplicateChecker() : null\r\n\r\n  if (__DEV__) {\r\n    const [propsOptions] = instance.propsOptions\r\n    if (propsOptions) {\r\n      for (const key in propsOptions) {\r\n        checkDuplicateProperties!(OptionTypes.PROPS, key)\r\n      }\r\n    }\r\n  }\r\n\r\n  // options initialization order (to be consistent with Vue 2):\r\n  // - props (already done outside of this function)\r\n  // - inject\r\n  // - methods\r\n  // - data (deferred since it relies on `this` access)\r\n  // - computed\r\n  // - watch (deferred since it relies on `this` access)\r\n\r\n  if (injectOptions) {\r\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties)\r\n  }\r\n\r\n  if (methods) {\r\n    for (const key in methods) {\r\n      const methodHandler = (methods as MethodOptions)[key]\r\n      if (isFunction(methodHandler)) {\r\n        // In dev mode, we use the `createRenderContext` function to define\r\n        // methods to the proxy target, and those are read-only but\r\n        // reconfigurable, so it needs to be redefined here\r\n        if (__DEV__) {\r\n          Object.defineProperty(ctx, key, {\r\n            value: methodHandler.bind(publicThis),\r\n            configurable: true,\r\n            enumerable: true,\r\n            writable: true\r\n          })\r\n        } else {\r\n          ctx[key] = methodHandler.bind(publicThis)\r\n        }\r\n        if (__DEV__) {\r\n          checkDuplicateProperties!(OptionTypes.METHODS, key)\r\n        }\r\n      } else if (__DEV__) {\r\n        warn(\r\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\r\n            `Did you reference the function correctly?`\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (dataOptions) {\r\n    if (__DEV__ && !isFunction(dataOptions)) {\r\n      warn(\r\n        `The data option must be a function. ` +\r\n          `Plain object usage is no longer supported.`\r\n      )\r\n    }\r\n    const data = dataOptions.call(publicThis, publicThis)\r\n    if (__DEV__ && isPromise(data)) {\r\n      warn(\r\n        `data() returned a Promise - note data() cannot be async; If you ` +\r\n          `intend to perform data fetching before component renders, use ` +\r\n          `async setup() + <Suspense>.`\r\n      )\r\n    }\r\n    if (!isObject(data)) {\r\n      __DEV__ && warn(`data() should return an object.`)\r\n    } else {\r\n      instance.data = reactive(data)\r\n      if (__DEV__) {\r\n        for (const key in data) {\r\n          checkDuplicateProperties!(OptionTypes.DATA, key)\r\n          // expose data on ctx during dev\r\n          if (!isReservedPrefix(key[0])) {\r\n            Object.defineProperty(ctx, key, {\r\n              configurable: true,\r\n              enumerable: true,\r\n              get: () => data[key],\r\n              set: NOOP\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // state initialization complete at this point - start caching access\r\n  shouldCacheAccess = true\r\n\r\n  if (computedOptions) {\r\n    for (const key in computedOptions) {\r\n      const opt = (computedOptions as ComputedOptions)[key]\r\n      const get = isFunction(opt)\r\n        ? opt.bind(publicThis, publicThis)\r\n        : isFunction(opt.get)\r\n          ? opt.get.bind(publicThis, publicThis)\r\n          : NOOP\r\n      if (__DEV__ && get === NOOP) {\r\n        warn(`Computed property \"${key}\" has no getter.`)\r\n      }\r\n      const set =\r\n        !isFunction(opt) && isFunction(opt.set)\r\n          ? opt.set.bind(publicThis)\r\n          : __DEV__\r\n            ? () => {\r\n                warn(\r\n                  `Write operation failed: computed property \"${key}\" is readonly.`\r\n                )\r\n              }\r\n            : NOOP\r\n      const c = computed({\r\n        get,\r\n        set\r\n      })\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => c.value,\r\n        set: v => (c.value = v)\r\n      })\r\n      if (__DEV__) {\r\n        checkDuplicateProperties!(OptionTypes.COMPUTED, key)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (watchOptions) {\r\n    for (const key in watchOptions) {\r\n      createWatcher(watchOptions[key], ctx, publicThis, key)\r\n    }\r\n  }\r\n\r\n  if (provideOptions) {\r\n    const provides = isFunction(provideOptions)\r\n      ? provideOptions.call(publicThis)\r\n      : provideOptions\r\n    Reflect.ownKeys(provides).forEach(key => {\r\n      provide(key, provides[key])\r\n    })\r\n  }\r\n\r\n  if (created) {\r\n    callHook(created, instance, LifecycleHooks.CREATED)\r\n  }\r\n\r\n  function registerLifecycleHook(\r\n    register: Function,\r\n    hook?: Function | Function[]\r\n  ) {\r\n    if (isArray(hook)) {\r\n      hook.forEach(_hook => register(_hook.bind(publicThis)))\r\n    } else if (hook) {\r\n      register(hook.bind(publicThis))\r\n    }\r\n  }\r\n\r\n  registerLifecycleHook(onBeforeMount, beforeMount)\r\n  registerLifecycleHook(onMounted, mounted)\r\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate)\r\n  registerLifecycleHook(onUpdated, updated)\r\n  registerLifecycleHook(onActivated, activated)\r\n  registerLifecycleHook(onDeactivated, deactivated)\r\n  registerLifecycleHook(onErrorCaptured, errorCaptured)\r\n  registerLifecycleHook(onRenderTracked, renderTracked)\r\n  registerLifecycleHook(onRenderTriggered, renderTriggered)\r\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount)\r\n  registerLifecycleHook(onUnmounted, unmounted)\r\n  registerLifecycleHook(onServerPrefetch, serverPrefetch)\r\n\r\n  if (__COMPAT__) {\r\n    if (\r\n      beforeDestroy &&\r\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_BEFORE_DESTROY, instance)\r\n    ) {\r\n      registerLifecycleHook(onBeforeUnmount, beforeDestroy)\r\n    }\r\n    if (\r\n      destroyed &&\r\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_DESTROYED, instance)\r\n    ) {\r\n      registerLifecycleHook(onUnmounted, destroyed)\r\n    }\r\n  }\r\n\r\n  if (isArray(expose)) {\r\n    if (expose.length) {\r\n      const exposed = instance.exposed || (instance.exposed = {})\r\n      expose.forEach(key => {\r\n        Object.defineProperty(exposed, key, {\r\n          get: () => publicThis[key],\r\n          set: val => (publicThis[key] = val)\r\n        })\r\n      })\r\n    } else if (!instance.exposed) {\r\n      instance.exposed = {}\r\n    }\r\n  }\r\n\r\n  // options that are handled when creating the instance but also need to be\r\n  // applied from mixins\r\n  if (render && instance.render === NOOP) {\r\n    instance.render = render as InternalRenderFunction\r\n  }\r\n  if (inheritAttrs != null) {\r\n    instance.inheritAttrs = inheritAttrs\r\n  }\r\n\r\n  // asset options.\r\n  if (components) instance.components = components as any\r\n  if (directives) instance.directives = directives\r\n  if (\r\n    __COMPAT__ &&\r\n    filters &&\r\n    isCompatEnabled(DeprecationTypes.FILTERS, instance)\r\n  ) {\r\n    instance.filters = filters\r\n  }\r\n}\r\n\r\nexport function resolveInjections(\r\n  injectOptions: ComponentInjectOptions,\r\n  ctx: any,\r\n  checkDuplicateProperties = NOOP as any\r\n) {\r\n  if (isArray(injectOptions)) {\r\n    injectOptions = normalizeInject(injectOptions)!\r\n  }\r\n  for (const key in injectOptions) {\r\n    const opt = injectOptions[key]\r\n    let injected: unknown\r\n    if (isObject(opt)) {\r\n      if ('default' in opt) {\r\n        injected = inject(\r\n          opt.from || key,\r\n          opt.default,\r\n          true /* treat default function as factory */\r\n        )\r\n      } else {\r\n        injected = inject(opt.from || key)\r\n      }\r\n    } else {\r\n      injected = inject(opt)\r\n    }\r\n    if (isRef(injected)) {\r\n      // unwrap injected refs (ref #4196)\r\n      Object.defineProperty(ctx, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: () => (injected as Ref).value,\r\n        set: v => ((injected as Ref).value = v)\r\n      })\r\n    } else {\r\n      ctx[key] = injected\r\n    }\r\n    if (__DEV__) {\r\n      checkDuplicateProperties!(OptionTypes.INJECT, key)\r\n    }\r\n  }\r\n}\r\n\r\nfunction callHook(\r\n  hook: Function,\r\n  instance: ComponentInternalInstance,\r\n  type: LifecycleHooks\r\n) {\r\n  callWithAsyncErrorHandling(\r\n    isArray(hook)\r\n      ? hook.map(h => h.bind(instance.proxy!))\r\n      : hook.bind(instance.proxy!),\r\n    instance,\r\n    type\r\n  )\r\n}\r\n\r\nexport function createWatcher(\r\n  raw: ComponentWatchOptionItem,\r\n  ctx: Data,\r\n  publicThis: ComponentPublicInstance,\r\n  key: string\r\n) {\r\n  const getter = key.includes('.')\r\n    ? createPathGetter(publicThis, key)\r\n    : () => (publicThis as any)[key]\r\n  if (isString(raw)) {\r\n    const handler = ctx[raw]\r\n    if (isFunction(handler)) {\r\n      watch(getter, handler as WatchCallback)\r\n    } else if (__DEV__) {\r\n      warn(`Invalid watch handler specified by key \"${raw}\"`, handler)\r\n    }\r\n  } else if (isFunction(raw)) {\r\n    watch(getter, raw.bind(publicThis))\r\n  } else if (isObject(raw)) {\r\n    if (isArray(raw)) {\r\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key))\r\n    } else {\r\n      const handler = isFunction(raw.handler)\r\n        ? raw.handler.bind(publicThis)\r\n        : (ctx[raw.handler] as WatchCallback)\r\n      if (isFunction(handler)) {\r\n        watch(getter, handler, raw)\r\n      } else if (__DEV__) {\r\n        warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler)\r\n      }\r\n    }\r\n  } else if (__DEV__) {\r\n    warn(`Invalid watch option: \"${key}\"`, raw)\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve merged options and cache it on the component.\r\n * This is done only once per-component since the merging does not involve\r\n * instances.\r\n */\r\nexport function resolveMergedOptions(\r\n  instance: ComponentInternalInstance\r\n): MergedComponentOptions {\r\n  const base = instance.type as ComponentOptions\r\n  const { mixins, extends: extendsOptions } = base\r\n  const {\r\n    mixins: globalMixins,\r\n    optionsCache: cache,\r\n    config: { optionMergeStrategies }\r\n  } = instance.appContext\r\n  const cached = cache.get(base)\r\n\r\n  let resolved: MergedComponentOptions\r\n\r\n  if (cached) {\r\n    resolved = cached\r\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.PRIVATE_APIS, instance)\r\n    ) {\r\n      resolved = extend({}, base) as MergedComponentOptions\r\n      resolved.parent = instance.parent && instance.parent.proxy\r\n      resolved.propsData = instance.vnode.props\r\n    } else {\r\n      resolved = base as MergedComponentOptions\r\n    }\r\n  } else {\r\n    resolved = {}\r\n    if (globalMixins.length) {\r\n      globalMixins.forEach(m =>\r\n        mergeOptions(resolved, m, optionMergeStrategies, true)\r\n      )\r\n    }\r\n    mergeOptions(resolved, base, optionMergeStrategies)\r\n  }\r\n  if (isObject(base)) {\r\n    cache.set(base, resolved)\r\n  }\r\n  return resolved\r\n}\r\n\r\nexport function mergeOptions(\r\n  to: any,\r\n  from: any,\r\n  strats: Record<string, OptionMergeFunction>,\r\n  asMixin = false\r\n) {\r\n  if (__COMPAT__ && isFunction(from)) {\r\n    from = from.options\r\n  }\r\n\r\n  const { mixins, extends: extendsOptions } = from\r\n\r\n  if (extendsOptions) {\r\n    mergeOptions(to, extendsOptions, strats, true)\r\n  }\r\n  if (mixins) {\r\n    mixins.forEach((m: ComponentOptionsMixin) =>\r\n      mergeOptions(to, m, strats, true)\r\n    )\r\n  }\r\n\r\n  for (const key in from) {\r\n    if (asMixin && key === 'expose') {\r\n      __DEV__ &&\r\n        warn(\r\n          `\"expose\" option is ignored when declared in mixins or extends. ` +\r\n            `It should only be declared in the base component itself.`\r\n        )\r\n    } else {\r\n      const strat = internalOptionMergeStrats[key] || (strats && strats[key])\r\n      to[key] = strat ? strat(to[key], from[key]) : from[key]\r\n    }\r\n  }\r\n  return to\r\n}\r\n\r\nexport const internalOptionMergeStrats: Record<string, Function> = {\r\n  data: mergeDataFn,\r\n  props: mergeEmitsOrPropsOptions,\r\n  emits: mergeEmitsOrPropsOptions,\r\n  // objects\r\n  methods: mergeObjectOptions,\r\n  computed: mergeObjectOptions,\r\n  // lifecycle\r\n  beforeCreate: mergeAsArray,\r\n  created: mergeAsArray,\r\n  beforeMount: mergeAsArray,\r\n  mounted: mergeAsArray,\r\n  beforeUpdate: mergeAsArray,\r\n  updated: mergeAsArray,\r\n  beforeDestroy: mergeAsArray,\r\n  beforeUnmount: mergeAsArray,\r\n  destroyed: mergeAsArray,\r\n  unmounted: mergeAsArray,\r\n  activated: mergeAsArray,\r\n  deactivated: mergeAsArray,\r\n  errorCaptured: mergeAsArray,\r\n  serverPrefetch: mergeAsArray,\r\n  // assets\r\n  components: mergeObjectOptions,\r\n  directives: mergeObjectOptions,\r\n  // watch\r\n  watch: mergeWatchOptions,\r\n  // provide / inject\r\n  provide: mergeDataFn,\r\n  inject: mergeInject\r\n}\r\n\r\nif (__COMPAT__) {\r\n  internalOptionMergeStrats.filters = mergeObjectOptions\r\n}\r\n\r\nfunction mergeDataFn(to: any, from: any) {\r\n  if (!from) {\r\n    return to\r\n  }\r\n  if (!to) {\r\n    return from\r\n  }\r\n  return function mergedDataFn(this: ComponentPublicInstance) {\r\n    return (\r\n      __COMPAT__ && isCompatEnabled(DeprecationTypes.OPTIONS_DATA_MERGE, null)\r\n        ? deepMergeData\r\n        : extend\r\n    )(\r\n      isFunction(to) ? to.call(this, this) : to,\r\n      isFunction(from) ? from.call(this, this) : from\r\n    )\r\n  }\r\n}\r\n\r\nfunction mergeInject(\r\n  to: ComponentInjectOptions | undefined,\r\n  from: ComponentInjectOptions\r\n) {\r\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from))\r\n}\r\n\r\nfunction normalizeInject(\r\n  raw: ComponentInjectOptions | undefined\r\n): ObjectInjectOptions | undefined {\r\n  if (isArray(raw)) {\r\n    const res: ObjectInjectOptions = {}\r\n    for (let i = 0; i < raw.length; i++) {\r\n      res[raw[i]] = raw[i]\r\n    }\r\n    return res\r\n  }\r\n  return raw\r\n}\r\n\r\nfunction mergeAsArray<T = Function>(to: T[] | T | undefined, from: T | T[]) {\r\n  return to ? [...new Set([].concat(to as any, from as any))] : from\r\n}\r\n\r\nfunction mergeObjectOptions(to: Object | undefined, from: Object | undefined) {\r\n  return to ? extend(Object.create(null), to, from) : from\r\n}\r\n\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: EmitsOptions | undefined,\r\n  from: EmitsOptions | undefined\r\n): EmitsOptions | undefined\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: ComponentPropsOptions | undefined,\r\n  from: ComponentPropsOptions | undefined\r\n): ComponentPropsOptions | undefined\r\nfunction mergeEmitsOrPropsOptions(\r\n  to: ComponentPropsOptions | EmitsOptions | undefined,\r\n  from: ComponentPropsOptions | EmitsOptions | undefined\r\n) {\r\n  if (to) {\r\n    if (isArray(to) && isArray(from)) {\r\n      return [...new Set([...to, ...from])]\r\n    }\r\n    return extend(\r\n      Object.create(null),\r\n      normalizePropsOrEmits(to),\r\n      normalizePropsOrEmits(from ?? {})\r\n    )\r\n  } else {\r\n    return from\r\n  }\r\n}\r\n\r\nfunction mergeWatchOptions(\r\n  to: ComponentWatchOptions | undefined,\r\n  from: ComponentWatchOptions | undefined\r\n) {\r\n  if (!to) return from\r\n  if (!from) return to\r\n  const merged = extend(Object.create(null), to)\r\n  for (const key in from) {\r\n    merged[key] = mergeAsArray(to[key], from[key])\r\n  }\r\n  return merged\r\n}\r\n", "import {\r\n  ConcreteComponent,\r\n  Data,\r\n  validateComponentName,\r\n  Component,\r\n  ComponentInternalInstance,\r\n  getExposeProxy\r\n} from './component'\r\nimport {\r\n  ComponentOptions,\r\n  MergedComponentOptions,\r\n  RuntimeCompilerOptions\r\n} from './componentOptions'\r\nimport {\r\n  ComponentCustomProperties,\r\n  ComponentPublicInstance\r\n} from './componentPublicInstance'\r\nimport { Directive, validateDirectiveName } from './directives'\r\nimport { RootRenderFunction } from './renderer'\r\nimport { InjectionKey } from './apiInject'\r\nimport { warn } from './warning'\r\nimport { createVNode, cloneVNode, VNode } from './vnode'\r\nimport { RootHydrateFunction } from './hydration'\r\nimport { devtoolsInitApp, devtoolsUnmountApp } from './devtools'\r\nimport { isFunction, NO, isObject, extend } from '@vue/shared'\r\nimport { version } from '.'\r\nimport { installAppCompatProperties } from './compat/global'\r\nimport { NormalizedPropsOptions } from './componentProps'\r\nimport { ObjectEmitsOptions } from './componentEmits'\r\nimport { DefineComponent } from './apiDefineComponent'\r\n\r\nexport interface App<HostElement = any> {\r\n  version: string\r\n  config: AppConfig\r\n\r\n  use<Options extends unknown[]>(\r\n    plugin: Plugin<Options>,\r\n    ...options: Options\r\n  ): this\r\n  use<Options>(plugin: Plugin<Options>, options: Options): this\r\n\r\n  mixin(mixin: ComponentOptions): this\r\n  component(name: string): Component | undefined\r\n  component(name: string, component: Component | DefineComponent): this\r\n  directive(name: string): Directive | undefined\r\n  directive(name: string, directive: Directive): this\r\n  mount(\r\n    rootContainer: HostElement | string,\r\n    isHydrate?: boolean,\r\n    isSVG?: boolean\r\n  ): ComponentPublicInstance\r\n  unmount(): void\r\n  provide<T>(key: InjectionKey<T> | string, value: T): this\r\n\r\n  /**\r\n   * Runs a function with the app as active instance. This allows using of `inject()` within the function to get access\r\n   * to variables provided via `app.provide()`.\r\n   *\r\n   * @param fn - function to run with the app as active instance\r\n   */\r\n  runWithContext<T>(fn: () => T): T\r\n\r\n  // internal, but we need to expose these for the server-renderer and devtools\r\n  _uid: number\r\n  _component: ConcreteComponent\r\n  _props: Data | null\r\n  _container: HostElement | null\r\n  _context: AppContext\r\n  _instance: ComponentInternalInstance | null\r\n\r\n  /**\r\n   * v2 compat only\r\n   */\r\n  filter?(name: string): Function | undefined\r\n  filter?(name: string, filter: Function): this\r\n\r\n  /**\r\n   * @internal v3 compat only\r\n   */\r\n  _createRoot?(options: ComponentOptions): ComponentPublicInstance\r\n}\r\n\r\nexport type OptionMergeFunction = (to: unknown, from: unknown) => any\r\n\r\nexport interface AppConfig {\r\n  // @private\r\n  readonly isNativeTag?: (tag: string) => boolean\r\n\r\n  performance: boolean\r\n  optionMergeStrategies: Record<string, OptionMergeFunction>\r\n  globalProperties: ComponentCustomProperties & Record<string, any>\r\n  errorHandler?: (\r\n    err: unknown,\r\n    instance: ComponentPublicInstance | null,\r\n    info: string\r\n  ) => void\r\n  warnHandler?: (\r\n    msg: string,\r\n    instance: ComponentPublicInstance | null,\r\n    trace: string\r\n  ) => void\r\n\r\n  /**\r\n   * Options to pass to `@vue/compiler-dom`.\r\n   * Only supported in runtime compiler build.\r\n   */\r\n  compilerOptions: RuntimeCompilerOptions\r\n\r\n  /**\r\n   * @deprecated use config.compilerOptions.isCustomElement\r\n   */\r\n  isCustomElement?: (tag: string) => boolean\r\n\r\n  // TODO remove in 3.4\r\n  /**\r\n   * Temporary config for opt-in to unwrap injected refs.\r\n   * @deprecated this no longer has effect. 3.3 always unwraps injected refs.\r\n   */\r\n  unwrapInjectedRef?: boolean\r\n}\r\n\r\nexport interface AppContext {\r\n  app: App // for devtools\r\n  config: AppConfig\r\n  mixins: ComponentOptions[]\r\n  components: Record<string, Component>\r\n  directives: Record<string, Directive>\r\n  provides: Record<string | symbol, any>\r\n\r\n  /**\r\n   * Cache for merged/normalized component options\r\n   * Each app instance has its own cache because app-level global mixins and\r\n   * optionMergeStrategies can affect merge behavior.\r\n   * @internal\r\n   */\r\n  optionsCache: WeakMap<ComponentOptions, MergedComponentOptions>\r\n  /**\r\n   * Cache for normalized props options\r\n   * @internal\r\n   */\r\n  propsCache: WeakMap<ConcreteComponent, NormalizedPropsOptions>\r\n  /**\r\n   * Cache for normalized emits options\r\n   * @internal\r\n   */\r\n  emitsCache: WeakMap<ConcreteComponent, ObjectEmitsOptions | null>\r\n  /**\r\n   * HMR only\r\n   * @internal\r\n   */\r\n  reload?: () => void\r\n  /**\r\n   * v2 compat only\r\n   * @internal\r\n   */\r\n  filters?: Record<string, Function>\r\n}\r\n\r\ntype PluginInstallFunction<Options> = Options extends unknown[]\r\n  ? (app: App, ...options: Options) => any\r\n  : (app: App, options: Options) => any\r\n\r\nexport type Plugin<Options = any[]> =\r\n  | (PluginInstallFunction<Options> & {\r\n      install?: PluginInstallFunction<Options>\r\n    })\r\n  | {\r\n      install: PluginInstallFunction<Options>\r\n    }\r\n\r\nexport function createAppContext(): AppContext {\r\n  return {\r\n    app: null as any,\r\n    config: {\r\n      isNativeTag: NO,\r\n      performance: false,\r\n      globalProperties: {},\r\n      optionMergeStrategies: {},\r\n      errorHandler: undefined,\r\n      warnHandler: undefined,\r\n      compilerOptions: {}\r\n    },\r\n    mixins: [],\r\n    components: {},\r\n    directives: {},\r\n    provides: Object.create(null),\r\n    optionsCache: new WeakMap(),\r\n    propsCache: new WeakMap(),\r\n    emitsCache: new WeakMap()\r\n  }\r\n}\r\n\r\nexport type CreateAppFunction<HostElement> = (\r\n  rootComponent: Component,\r\n  rootProps?: Data | null\r\n) => App<HostElement>\r\n\r\nlet uid = 0\r\n\r\nexport function createAppAPI<HostElement>(\r\n  render: RootRenderFunction<HostElement>,\r\n  hydrate?: RootHydrateFunction\r\n): CreateAppFunction<HostElement> {\r\n  return function createApp(rootComponent, rootProps = null) {\r\n    if (!isFunction(rootComponent)) {\r\n      rootComponent = extend({}, rootComponent)\r\n    }\r\n\r\n    if (rootProps != null && !isObject(rootProps)) {\r\n      __DEV__ && warn(`root props passed to app.mount() must be an object.`)\r\n      rootProps = null\r\n    }\r\n\r\n    const context = createAppContext()\r\n\r\n    // TODO remove in 3.4\r\n    if (__DEV__) {\r\n      Object.defineProperty(context.config, 'unwrapInjectedRef', {\r\n        get() {\r\n          return true\r\n        },\r\n        set() {\r\n          warn(\r\n            `app.config.unwrapInjectedRef has been deprecated. ` +\r\n              `3.3 now always unwraps injected refs in Options API.`\r\n          )\r\n        }\r\n      })\r\n    }\r\n\r\n    const installedPlugins = new WeakSet()\r\n\r\n    let isMounted = false\r\n\r\n    const app: App = (context.app = {\r\n      _uid: uid++,\r\n      _component: rootComponent as ConcreteComponent,\r\n      _props: rootProps,\r\n      _container: null,\r\n      _context: context,\r\n      _instance: null,\r\n\r\n      version,\r\n\r\n      get config() {\r\n        return context.config\r\n      },\r\n\r\n      set config(v) {\r\n        if (__DEV__) {\r\n          warn(\r\n            `app.config cannot be replaced. Modify individual options instead.`\r\n          )\r\n        }\r\n      },\r\n\r\n      use(plugin: Plugin, ...options: any[]) {\r\n        if (installedPlugins.has(plugin)) {\r\n          __DEV__ && warn(`Plugin has already been applied to target app.`)\r\n        } else if (plugin && isFunction(plugin.install)) {\r\n          installedPlugins.add(plugin)\r\n          plugin.install(app, ...options)\r\n        } else if (isFunction(plugin)) {\r\n          installedPlugins.add(plugin)\r\n          plugin(app, ...options)\r\n        } else if (__DEV__) {\r\n          warn(\r\n            `A plugin must either be a function or an object with an \"install\" ` +\r\n              `function.`\r\n          )\r\n        }\r\n        return app\r\n      },\r\n\r\n      mixin(mixin: ComponentOptions) {\r\n        if (__FEATURE_OPTIONS_API__) {\r\n          if (!context.mixins.includes(mixin)) {\r\n            context.mixins.push(mixin)\r\n          } else if (__DEV__) {\r\n            warn(\r\n              'Mixin has already been applied to target app' +\r\n                (mixin.name ? `: ${mixin.name}` : '')\r\n            )\r\n          }\r\n        } else if (__DEV__) {\r\n          warn('Mixins are only available in builds supporting Options API')\r\n        }\r\n        return app\r\n      },\r\n\r\n      component(name: string, component?: Component): any {\r\n        if (__DEV__) {\r\n          validateComponentName(name, context.config)\r\n        }\r\n        if (!component) {\r\n          return context.components[name]\r\n        }\r\n        if (__DEV__ && context.components[name]) {\r\n          warn(`Component \"${name}\" has already been registered in target app.`)\r\n        }\r\n        context.components[name] = component\r\n        return app\r\n      },\r\n\r\n      directive(name: string, directive?: Directive) {\r\n        if (__DEV__) {\r\n          validateDirectiveName(name)\r\n        }\r\n\r\n        if (!directive) {\r\n          return context.directives[name] as any\r\n        }\r\n        if (__DEV__ && context.directives[name]) {\r\n          warn(`Directive \"${name}\" has already been registered in target app.`)\r\n        }\r\n        context.directives[name] = directive\r\n        return app\r\n      },\r\n\r\n      mount(\r\n        rootContainer: HostElement,\r\n        isHydrate?: boolean,\r\n        isSVG?: boolean\r\n      ): any {\r\n        if (!isMounted) {\r\n          // #5571\r\n          if (__DEV__ && (rootContainer as any).__vue_app__) {\r\n            warn(\r\n              `There is already an app instance mounted on the host container.\\n` +\r\n                ` If you want to mount another app on the same host container,` +\r\n                ` you need to unmount the previous app by calling \\`app.unmount()\\` first.`\r\n            )\r\n          }\r\n          const vnode = createVNode(rootComponent, rootProps)\r\n          // store app context on the root VNode.\r\n          // this will be set on the root instance on initial mount.\r\n          vnode.appContext = context\r\n\r\n          // HMR root reload\r\n          if (__DEV__) {\r\n            context.reload = () => {\r\n              render(cloneVNode(vnode), rootContainer, isSVG)\r\n            }\r\n          }\r\n\r\n          if (isHydrate && hydrate) {\r\n            hydrate(vnode as VNode<Node, Element>, rootContainer as any)\r\n          } else {\r\n            render(vnode, rootContainer, isSVG)\r\n          }\r\n          isMounted = true\r\n          app._container = rootContainer\r\n          // for devtools and telemetry\r\n          ;(rootContainer as any).__vue_app__ = app\r\n\r\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            app._instance = vnode.component\r\n            devtoolsInitApp(app, version)\r\n          }\r\n\r\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\r\n        } else if (__DEV__) {\r\n          warn(\r\n            `App has already been mounted.\\n` +\r\n              `If you want to remount the same app, move your app creation logic ` +\r\n              `into a factory function and create fresh app instances for each ` +\r\n              `mount - e.g. \\`const createMyApp = () => createApp(App)\\``\r\n          )\r\n        }\r\n      },\r\n\r\n      unmount() {\r\n        if (isMounted) {\r\n          render(null, app._container)\r\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n            app._instance = null\r\n            devtoolsUnmountApp(app)\r\n          }\r\n          delete app._container.__vue_app__\r\n        } else if (__DEV__) {\r\n          warn(`Cannot unmount an app that is not mounted.`)\r\n        }\r\n      },\r\n\r\n      provide(key, value) {\r\n        if (__DEV__ && (key as string | symbol) in context.provides) {\r\n          warn(\r\n            `App already provides property with key \"${String(key)}\". ` +\r\n              `It will be overwritten with the new value.`\r\n          )\r\n        }\r\n\r\n        context.provides[key as string | symbol] = value\r\n\r\n        return app\r\n      },\r\n\r\n      runWithContext(fn) {\r\n        currentApp = app\r\n        try {\r\n          return fn()\r\n        } finally {\r\n          currentApp = null\r\n        }\r\n      }\r\n    })\r\n\r\n    if (__COMPAT__) {\r\n      installAppCompatProperties(app, context, render)\r\n    }\r\n\r\n    return app\r\n  }\r\n}\r\n\r\n/**\r\n * @internal Used to identify the current app when using `inject()` within\r\n * `app.runWithContext()`.\r\n */\r\nexport let currentApp: App<unknown> | null = null\r\n", "import { isFunction } from '@vue/shared'\r\nimport { currentInstance } from './component'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { currentApp } from './apiCreateApp'\r\nimport { warn } from './warning'\r\n\r\nexport interface InjectionKey<T> extends Symbol {}\r\n\r\nexport function provide<T, K = InjectionKey<T> | string | number>(\r\n  key: K,\r\n  value: K extends InjectionKey<infer V> ? V : T\r\n) {\r\n  if (!currentInstance) {\r\n    if (__DEV__) {\r\n      warn(`provide() can only be used inside setup().`)\r\n    }\r\n  } else {\r\n    let provides = currentInstance.provides\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    const parentProvides =\r\n      currentInstance.parent && currentInstance.parent.provides\r\n    if (parentProvides === provides) {\r\n      provides = currentInstance.provides = Object.create(parentProvides)\r\n    }\r\n    // TS doesn't allow symbol as index type\r\n    provides[key as string] = value\r\n  }\r\n}\r\n\r\nexport function inject<T>(key: InjectionKey<T> | string): T | undefined\r\nexport function inject<T>(\r\n  key: InjectionKey<T> | string,\r\n  defaultValue: T,\r\n  treatDefaultAsFactory?: false\r\n): T\r\nexport function inject<T>(\r\n  key: InjectionKey<T> | string,\r\n  defaultValue: T | (() => T),\r\n  treatDefaultAsFactory: true\r\n): T\r\nexport function inject(\r\n  key: InjectionKey<any> | string,\r\n  defaultValue?: unknown,\r\n  treatDefaultAsFactory = false\r\n) {\r\n  // fallback to `currentRenderingInstance` so that this can be called in\r\n  // a functional component\r\n  const instance = currentInstance || currentRenderingInstance\r\n\r\n  // also support looking up from app-level provides w/ `app.runWithContext()`\r\n  if (instance || currentApp) {\r\n    // #2400\r\n    // to support `app.use` plugins,\r\n    // fallback to appContext's `provides` if the instance is at root\r\n    const provides = instance\r\n      ? instance.parent == null\r\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n        : instance.parent.provides\r\n      : currentApp!._context.provides\r\n\r\n    if (provides && (key as string | symbol) in provides) {\r\n      // TS doesn't allow symbol as index type\r\n      return provides[key as string]\r\n    } else if (arguments.length > 1) {\r\n      return treatDefaultAsFactory && isFunction(defaultValue)\r\n        ? defaultValue.call(instance && instance.proxy)\r\n        : defaultValue\r\n    } else if (__DEV__) {\r\n      warn(`injection \"${String(key)}\" not found.`)\r\n    }\r\n  } else if (__DEV__) {\r\n    warn(`inject() can only be used inside setup() or functional components.`)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns true if `inject()` can be used without warning about being called in the wrong place (e.g. outside of\r\n * setup()). This is used by libraries that want to use `inject()` internally without triggering a warning to the end\r\n * user. One example is `useRoute()` in `vue-router`.\r\n */\r\nexport function hasInjectionContext(): boolean {\r\n  return !!(currentInstance || currentRenderingInstance || currentApp)\r\n}\r\n", "import {\r\n  toRaw,\r\n  shallowReactive,\r\n  trigger,\r\n  TriggerOpTypes\r\n} from '@vue/reactivity'\r\nimport {\r\n  EMPTY_OBJ,\r\n  camelize,\r\n  hyphenate,\r\n  capitalize,\r\n  isString,\r\n  isFunction,\r\n  isArray,\r\n  isObject,\r\n  hasOwn,\r\n  toRawType,\r\n  PatchFlags,\r\n  makeMap,\r\n  isReservedProp,\r\n  EMPTY_ARR,\r\n  def,\r\n  extend,\r\n  isOn,\r\n  IfAny\r\n} from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport {\r\n  Data,\r\n  ComponentInternalInstance,\r\n  ComponentOptions,\r\n  ConcreteComponent,\r\n  setCurrentInstance,\r\n  unsetCurrentInstance\r\n} from './component'\r\nimport { isEmitListener } from './componentEmits'\r\nimport { InternalObjectKey } from './vnode'\r\nimport { AppContext } from './apiCreateApp'\r\nimport { createPropsDefaultThis } from './compat/props'\r\nimport { isCompatEnabled, softAssertCompatEnabled } from './compat/compatConfig'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport { shouldSkipAttr } from './compat/attrsFallthrough'\r\n\r\nexport type ComponentPropsOptions<P = Data> =\r\n  | ComponentObjectPropsOptions<P>\r\n  | string[]\r\n\r\nexport type ComponentObjectPropsOptions<P = Data> = {\r\n  [K in keyof P]: Prop<P[K]> | null\r\n}\r\n\r\nexport type Prop<T, D = T> = PropOptions<T, D> | PropType<T>\r\n\r\ntype DefaultFactory<T> = (props: Data) => T | null | undefined\r\n\r\nexport interface PropOptions<T = any, D = T> {\r\n  type?: PropType<T> | true | null\r\n  required?: boolean\r\n  default?: D | DefaultFactory<D> | null | undefined | object\r\n  validator?(value: unknown): boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  skipCheck?: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  skipFactory?: boolean\r\n}\r\n\r\nexport type PropType<T> = PropConstructor<T> | PropConstructor<T>[]\r\n\r\ntype PropConstructor<T = any> =\r\n  | { new (...args: any[]): T & {} }\r\n  | { (): T }\r\n  | PropMethod<T>\r\n\r\ntype PropMethod<T, TConstructor = any> = [T] extends [\r\n  ((...args: any) => any) | undefined\r\n] // if is function with args, allowing non-required functions\r\n  ? { new (): TConstructor; (): T; readonly prototype: TConstructor } // Create Function like constructor\r\n  : never\r\n\r\ntype RequiredKeys<T> = {\r\n  [K in keyof T]: T[K] extends\r\n    | { required: true }\r\n    | { default: any }\r\n    // don't mark Boolean props as undefined\r\n    | BooleanConstructor\r\n    | { type: BooleanConstructor }\r\n    ? T[K] extends { default: undefined | (() => undefined) }\r\n      ? never\r\n      : K\r\n    : never\r\n}[keyof T]\r\n\r\ntype OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>\r\n\r\ntype DefaultKeys<T> = {\r\n  [K in keyof T]: T[K] extends\r\n    | { default: any }\r\n    // Boolean implicitly defaults to false\r\n    | BooleanConstructor\r\n    | { type: BooleanConstructor }\r\n    ? T[K] extends { type: BooleanConstructor; required: true } // not default if Boolean is marked as required\r\n      ? never\r\n      : K\r\n    : never\r\n}[keyof T]\r\n\r\ntype InferPropType<T> = [T] extends [null]\r\n  ? any // null & true would fail to infer\r\n  : [T] extends [{ type: null | true }]\r\n    ? any // As TS issue https://github.com/Microsoft/TypeScript/issues/14829 // somehow `ObjectConstructor` when inferred from { (): T } becomes `any` // `BooleanConstructor` when inferred from PropConstructor(with PropMethod) becomes `Boolean`\r\n    : [T] extends [ObjectConstructor | { type: ObjectConstructor }]\r\n      ? Record<string, any>\r\n      : [T] extends [BooleanConstructor | { type: BooleanConstructor }]\r\n        ? boolean\r\n        : [T] extends [DateConstructor | { type: DateConstructor }]\r\n          ? Date\r\n          : [T] extends [(infer U)[] | { type: (infer U)[] }]\r\n            ? U extends DateConstructor\r\n              ? Date | InferPropType<U>\r\n              : InferPropType<U>\r\n            : [T] extends [Prop<infer V, infer D>]\r\n              ? unknown extends V\r\n                ? IfAny<V, V, D>\r\n                : V\r\n              : T\r\n\r\n/**\r\n * Extract prop types from a runtime props options object.\r\n * The extracted types are **internal** - i.e. the resolved props received by\r\n * the component.\r\n * - Boolean props are always present\r\n * - Props with default values are always present\r\n *\r\n * To extract accepted props from the parent, use {@link ExtractPublicPropTypes}.\r\n */\r\nexport type ExtractPropTypes<O> = {\r\n  // use `keyof Pick<O, RequiredKeys<O>>` instead of `RequiredKeys<O>` to\r\n  // support IDE features\r\n  [K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>\r\n} & {\r\n  // use `keyof Pick<O, OptionalKeys<O>>` instead of `OptionalKeys<O>` to\r\n  // support IDE features\r\n  [K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>\r\n}\r\n\r\ntype PublicRequiredKeys<T> = {\r\n  [K in keyof T]: T[K] extends { required: true } ? K : never\r\n}[keyof T]\r\n\r\ntype PublicOptionalKeys<T> = Exclude<keyof T, PublicRequiredKeys<T>>\r\n\r\n/**\r\n * Extract prop types from a runtime props options object.\r\n * The extracted types are **public** - i.e. the expected props that can be\r\n * passed to component.\r\n */\r\nexport type ExtractPublicPropTypes<O> = {\r\n  [K in keyof Pick<O, PublicRequiredKeys<O>>]: InferPropType<O[K]>\r\n} & {\r\n  [K in keyof Pick<O, PublicOptionalKeys<O>>]?: InferPropType<O[K]>\r\n}\r\n\r\nconst enum BooleanFlags {\r\n  shouldCast,\r\n  shouldCastTrue\r\n}\r\n\r\n// extract props which defined with default from prop options\r\nexport type ExtractDefaultPropTypes<O> = O extends object\r\n  ? // use `keyof Pick<O, DefaultKeys<O>>` instead of `DefaultKeys<O>` to support IDE features\r\n    { [K in keyof Pick<O, DefaultKeys<O>>]: InferPropType<O[K]> }\r\n  : {}\r\n\r\ntype NormalizedProp =\r\n  | null\r\n  | (PropOptions & {\r\n      [BooleanFlags.shouldCast]?: boolean\r\n      [BooleanFlags.shouldCastTrue]?: boolean\r\n    })\r\n\r\n// normalized value is a tuple of the actual normalized options\r\n// and an array of prop keys that need value casting (booleans and defaults)\r\nexport type NormalizedProps = Record<string, NormalizedProp>\r\nexport type NormalizedPropsOptions = [NormalizedProps, string[]] | []\r\n\r\nexport function initProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  isStateful: number, // result of bitwise flag comparison\r\n  isSSR = false\r\n) {\r\n  const props: Data = {}\r\n  const attrs: Data = {}\r\n  def(attrs, InternalObjectKey, 1)\r\n\r\n  instance.propsDefaults = Object.create(null)\r\n\r\n  setFullProps(instance, rawProps, props, attrs)\r\n\r\n  // ensure all declared prop keys are present\r\n  for (const key in instance.propsOptions[0]) {\r\n    if (!(key in props)) {\r\n      props[key] = undefined\r\n    }\r\n  }\r\n\r\n  // validation\r\n  if (__DEV__) {\r\n    validateProps(rawProps || {}, props, instance)\r\n  }\r\n\r\n  if (isStateful) {\r\n    // stateful\r\n    instance.props = isSSR ? props : shallowReactive(props)\r\n  } else {\r\n    if (!instance.type.props) {\r\n      // functional w/ optional props, props === attrs\r\n      instance.props = attrs\r\n    } else {\r\n      // functional w/ declared props\r\n      instance.props = props\r\n    }\r\n  }\r\n  instance.attrs = attrs\r\n}\r\n\r\nfunction isInHmrContext(instance: ComponentInternalInstance | null) {\r\n  while (instance) {\r\n    if (instance.type.__hmrId) return true\r\n    instance = instance.parent\r\n  }\r\n}\r\n\r\nexport function updateProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  rawPrevProps: Data | null,\r\n  optimized: boolean\r\n) {\r\n  const {\r\n    props,\r\n    attrs,\r\n    vnode: { patchFlag }\r\n  } = instance\r\n  const rawCurrentProps = toRaw(props)\r\n  const [options] = instance.propsOptions\r\n  let hasAttrsChanged = false\r\n\r\n  if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n    !(__DEV__ && isInHmrContext(instance)) &&\r\n    (optimized || patchFlag > 0) &&\r\n    !(patchFlag & PatchFlags.FULL_PROPS)\r\n  ) {\r\n    if (patchFlag & PatchFlags.PROPS) {\r\n      // Compiler-generated props & no keys change, just set the updated\r\n      // the props.\r\n      const propsToUpdate = instance.vnode.dynamicProps!\r\n      for (let i = 0; i < propsToUpdate.length; i++) {\r\n        let key = propsToUpdate[i]\r\n        // skip if the prop key is a declared emit event listener\r\n        if (isEmitListener(instance.emitsOptions, key)) {\r\n          continue\r\n        }\r\n        // PROPS flag guarantees rawProps to be non-null\r\n        const value = rawProps![key]\r\n        if (options) {\r\n          // attr / props separation was done on init and will be consistent\r\n          // in this code path, so just check if attrs have it.\r\n          if (hasOwn(attrs, key)) {\r\n            if (value !== attrs[key]) {\r\n              attrs[key] = value\r\n              hasAttrsChanged = true\r\n            }\r\n          } else {\r\n            const camelizedKey = camelize(key)\r\n            props[camelizedKey] = resolvePropValue(\r\n              options,\r\n              rawCurrentProps,\r\n              camelizedKey,\r\n              value,\r\n              instance,\r\n              false /* isAbsent */\r\n            )\r\n          }\r\n        } else {\r\n          if (__COMPAT__) {\r\n            if (isOn(key) && key.endsWith('Native')) {\r\n              key = key.slice(0, -6) // remove Native postfix\r\n            } else if (shouldSkipAttr(key, instance)) {\r\n              continue\r\n            }\r\n          }\r\n          if (value !== attrs[key]) {\r\n            attrs[key] = value\r\n            hasAttrsChanged = true\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    // full props update.\r\n    if (setFullProps(instance, rawProps, props, attrs)) {\r\n      hasAttrsChanged = true\r\n    }\r\n    // in case of dynamic props, check if we need to delete keys from\r\n    // the props object\r\n    let kebabKey: string\r\n    for (const key in rawCurrentProps) {\r\n      if (\r\n        !rawProps ||\r\n        // for camelCase\r\n        (!hasOwn(rawProps, key) &&\r\n          // it's possible the original props was passed in as kebab-case\r\n          // and converted to camelCase (#955)\r\n          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))\r\n      ) {\r\n        if (options) {\r\n          if (\r\n            rawPrevProps &&\r\n            // for camelCase\r\n            (rawPrevProps[key] !== undefined ||\r\n              // for kebab-case\r\n              rawPrevProps[kebabKey!] !== undefined)\r\n          ) {\r\n            props[key] = resolvePropValue(\r\n              options,\r\n              rawCurrentProps,\r\n              key,\r\n              undefined,\r\n              instance,\r\n              true /* isAbsent */\r\n            )\r\n          }\r\n        } else {\r\n          delete props[key]\r\n        }\r\n      }\r\n    }\r\n    // in the case of functional component w/o props declaration, props and\r\n    // attrs point to the same object so it should already have been updated.\r\n    if (attrs !== rawCurrentProps) {\r\n      for (const key in attrs) {\r\n        if (\r\n          !rawProps ||\r\n          (!hasOwn(rawProps, key) &&\r\n            (!__COMPAT__ || !hasOwn(rawProps, key + 'Native')))\r\n        ) {\r\n          delete attrs[key]\r\n          hasAttrsChanged = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // trigger updates for $attrs in case it's used in component slots\r\n  if (hasAttrsChanged) {\r\n    trigger(instance, TriggerOpTypes.SET, '$attrs')\r\n  }\r\n\r\n  if (__DEV__) {\r\n    validateProps(rawProps || {}, props, instance)\r\n  }\r\n}\r\n\r\nfunction setFullProps(\r\n  instance: ComponentInternalInstance,\r\n  rawProps: Data | null,\r\n  props: Data,\r\n  attrs: Data\r\n) {\r\n  const [options, needCastKeys] = instance.propsOptions\r\n  let hasAttrsChanged = false\r\n  let rawCastValues: Data | undefined\r\n  if (rawProps) {\r\n    for (let key in rawProps) {\r\n      // key, ref are reserved and never passed down\r\n      if (isReservedProp(key)) {\r\n        continue\r\n      }\r\n\r\n      if (__COMPAT__) {\r\n        if (key.startsWith('onHook:')) {\r\n          softAssertCompatEnabled(\r\n            DeprecationTypes.INSTANCE_EVENT_HOOKS,\r\n            instance,\r\n            key.slice(2).toLowerCase()\r\n          )\r\n        }\r\n        if (key === 'inline-template') {\r\n          continue\r\n        }\r\n      }\r\n\r\n      const value = rawProps[key]\r\n      // prop option names are camelized during normalization, so to support\r\n      // kebab -> camel conversion here we need to camelize the key.\r\n      let camelKey\r\n      if (options && hasOwn(options, (camelKey = camelize(key)))) {\r\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\r\n          props[camelKey] = value\r\n        } else {\r\n          ;(rawCastValues || (rawCastValues = {}))[camelKey] = value\r\n        }\r\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\r\n        // Any non-declared (either as a prop or an emitted event) props are put\r\n        // into a separate `attrs` object for spreading. Make sure to preserve\r\n        // original key casing\r\n        if (__COMPAT__) {\r\n          if (isOn(key) && key.endsWith('Native')) {\r\n            key = key.slice(0, -6) // remove Native postfix\r\n          } else if (shouldSkipAttr(key, instance)) {\r\n            continue\r\n          }\r\n        }\r\n        if (!(key in attrs) || value !== attrs[key]) {\r\n          attrs[key] = value\r\n          hasAttrsChanged = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (needCastKeys) {\r\n    const rawCurrentProps = toRaw(props)\r\n    const castValues = rawCastValues || EMPTY_OBJ\r\n    for (let i = 0; i < needCastKeys.length; i++) {\r\n      const key = needCastKeys[i]\r\n      props[key] = resolvePropValue(\r\n        options!,\r\n        rawCurrentProps,\r\n        key,\r\n        castValues[key],\r\n        instance,\r\n        !hasOwn(castValues, key)\r\n      )\r\n    }\r\n  }\r\n\r\n  return hasAttrsChanged\r\n}\r\n\r\nfunction resolvePropValue(\r\n  options: NormalizedProps,\r\n  props: Data,\r\n  key: string,\r\n  value: unknown,\r\n  instance: ComponentInternalInstance,\r\n  isAbsent: boolean\r\n) {\r\n  const opt = options[key]\r\n  if (opt != null) {\r\n    const hasDefault = hasOwn(opt, 'default')\r\n    // default values\r\n    if (hasDefault && value === undefined) {\r\n      const defaultValue = opt.default\r\n      if (\r\n        opt.type !== Function &&\r\n        !opt.skipFactory &&\r\n        isFunction(defaultValue)\r\n      ) {\r\n        const { propsDefaults } = instance\r\n        if (key in propsDefaults) {\r\n          value = propsDefaults[key]\r\n        } else {\r\n          setCurrentInstance(instance)\r\n          value = propsDefaults[key] = defaultValue.call(\r\n            __COMPAT__ &&\r\n              isCompatEnabled(DeprecationTypes.PROPS_DEFAULT_THIS, instance)\r\n              ? createPropsDefaultThis(instance, props, key)\r\n              : null,\r\n            props\r\n          )\r\n          unsetCurrentInstance()\r\n        }\r\n      } else {\r\n        value = defaultValue\r\n      }\r\n    }\r\n    // boolean casting\r\n    if (opt[BooleanFlags.shouldCast]) {\r\n      if (isAbsent && !hasDefault) {\r\n        value = false\r\n      } else if (\r\n        opt[BooleanFlags.shouldCastTrue] &&\r\n        (value === '' || value === hyphenate(key))\r\n      ) {\r\n        value = true\r\n      }\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\nexport function normalizePropsOptions(\r\n  comp: ConcreteComponent,\r\n  appContext: AppContext,\r\n  asMixin = false\r\n): NormalizedPropsOptions {\r\n  const cache = appContext.propsCache\r\n  const cached = cache.get(comp)\r\n  if (cached) {\r\n    return cached\r\n  }\r\n\r\n  const raw = comp.props\r\n  const normalized: NormalizedPropsOptions[0] = {}\r\n  const needCastKeys: NormalizedPropsOptions[1] = []\r\n\r\n  // apply mixin/extends props\r\n  let hasExtends = false\r\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\r\n    const extendProps = (raw: ComponentOptions) => {\r\n      if (__COMPAT__ && isFunction(raw)) {\r\n        raw = raw.options\r\n      }\r\n      hasExtends = true\r\n      const [props, keys] = normalizePropsOptions(raw, appContext, true)\r\n      extend(normalized, props)\r\n      if (keys) needCastKeys.push(...keys)\r\n    }\r\n    if (!asMixin && appContext.mixins.length) {\r\n      appContext.mixins.forEach(extendProps)\r\n    }\r\n    if (comp.extends) {\r\n      extendProps(comp.extends)\r\n    }\r\n    if (comp.mixins) {\r\n      comp.mixins.forEach(extendProps)\r\n    }\r\n  }\r\n\r\n  if (!raw && !hasExtends) {\r\n    if (isObject(comp)) {\r\n      cache.set(comp, EMPTY_ARR as any)\r\n    }\r\n    return EMPTY_ARR as any\r\n  }\r\n\r\n  if (isArray(raw)) {\r\n    for (let i = 0; i < raw.length; i++) {\r\n      if (__DEV__ && !isString(raw[i])) {\r\n        warn(`props must be strings when using array syntax.`, raw[i])\r\n      }\r\n      const normalizedKey = camelize(raw[i])\r\n      if (validatePropName(normalizedKey)) {\r\n        normalized[normalizedKey] = EMPTY_OBJ\r\n      }\r\n    }\r\n  } else if (raw) {\r\n    if (__DEV__ && !isObject(raw)) {\r\n      warn(`invalid props options`, raw)\r\n    }\r\n    for (const key in raw) {\r\n      const normalizedKey = camelize(key)\r\n      if (validatePropName(normalizedKey)) {\r\n        const opt = raw[key]\r\n        const prop: NormalizedProp = (normalized[normalizedKey] =\r\n          isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt))\r\n        if (prop) {\r\n          const booleanIndex = getTypeIndex(Boolean, prop.type)\r\n          const stringIndex = getTypeIndex(String, prop.type)\r\n          prop[BooleanFlags.shouldCast] = booleanIndex > -1\r\n          prop[BooleanFlags.shouldCastTrue] =\r\n            stringIndex < 0 || booleanIndex < stringIndex\r\n          // if the prop needs boolean casting or default value\r\n          if (booleanIndex > -1 || hasOwn(prop, 'default')) {\r\n            needCastKeys.push(normalizedKey)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const res: NormalizedPropsOptions = [normalized, needCastKeys]\r\n  if (isObject(comp)) {\r\n    cache.set(comp, res)\r\n  }\r\n  return res\r\n}\r\n\r\nfunction validatePropName(key: string) {\r\n  if (key[0] !== '$') {\r\n    return true\r\n  } else if (__DEV__) {\r\n    warn(`Invalid prop name: \"${key}\" is a reserved property.`)\r\n  }\r\n  return false\r\n}\r\n\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor: Prop<any>): string {\r\n  const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/)\r\n  return match ? match[2] : ctor === null ? 'null' : ''\r\n}\r\n\r\nfunction isSameType(a: Prop<any>, b: Prop<any>): boolean {\r\n  return getType(a) === getType(b)\r\n}\r\n\r\nfunction getTypeIndex(\r\n  type: Prop<any>,\r\n  expectedTypes: PropType<any> | void | null | true\r\n): number {\r\n  if (isArray(expectedTypes)) {\r\n    return expectedTypes.findIndex(t => isSameType(t, type))\r\n  } else if (isFunction(expectedTypes)) {\r\n    return isSameType(expectedTypes, type) ? 0 : -1\r\n  }\r\n  return -1\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction validateProps(\r\n  rawProps: Data,\r\n  props: Data,\r\n  instance: ComponentInternalInstance\r\n) {\r\n  const resolvedValues = toRaw(props)\r\n  const options = instance.propsOptions[0]\r\n  for (const key in options) {\r\n    let opt = options[key]\r\n    if (opt == null) continue\r\n    validateProp(\r\n      key,\r\n      resolvedValues[key],\r\n      opt,\r\n      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction validateProp(\r\n  name: string,\r\n  value: unknown,\r\n  prop: PropOptions,\r\n  isAbsent: boolean\r\n) {\r\n  const { type, required, validator, skipCheck } = prop\r\n  // required!\r\n  if (required && isAbsent) {\r\n    warn('Missing required prop: \"' + name + '\"')\r\n    return\r\n  }\r\n  // missing but optional\r\n  if (value == null && !required) {\r\n    return\r\n  }\r\n  // type check\r\n  if (type != null && type !== true && !skipCheck) {\r\n    let isValid = false\r\n    const types = isArray(type) ? type : [type]\r\n    const expectedTypes = []\r\n    // value is valid as long as one of the specified types match\r\n    for (let i = 0; i < types.length && !isValid; i++) {\r\n      const { valid, expectedType } = assertType(value, types[i])\r\n      expectedTypes.push(expectedType || '')\r\n      isValid = valid\r\n    }\r\n    if (!isValid) {\r\n      warn(getInvalidTypeMessage(name, value, expectedTypes))\r\n      return\r\n    }\r\n  }\r\n  // custom validator\r\n  if (validator && !validator(value)) {\r\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".')\r\n  }\r\n}\r\n\r\nconst isSimpleType = /*#__PURE__*/ makeMap(\r\n  'String,Number,Boolean,Function,Symbol,BigInt'\r\n)\r\n\r\ntype AssertionResult = {\r\n  valid: boolean\r\n  expectedType: string\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction assertType(value: unknown, type: PropConstructor): AssertionResult {\r\n  let valid\r\n  const expectedType = getType(type)\r\n  if (isSimpleType(expectedType)) {\r\n    const t = typeof value\r\n    valid = t === expectedType.toLowerCase()\r\n    // for primitive wrapper objects\r\n    if (!valid && t === 'object') {\r\n      valid = value instanceof type\r\n    }\r\n  } else if (expectedType === 'Object') {\r\n    valid = isObject(value)\r\n  } else if (expectedType === 'Array') {\r\n    valid = isArray(value)\r\n  } else if (expectedType === 'null') {\r\n    valid = value === null\r\n  } else {\r\n    valid = value instanceof type\r\n  }\r\n  return {\r\n    valid,\r\n    expectedType\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction getInvalidTypeMessage(\r\n  name: string,\r\n  value: unknown,\r\n  expectedTypes: string[]\r\n): string {\r\n  if (expectedTypes.length === 0) {\r\n    return (\r\n      `Prop type [] for prop \"${name}\" won't match anything.` +\r\n      ` Did you mean to use type Array instead?`\r\n    )\r\n  }\r\n  let message =\r\n    `Invalid prop: type check failed for prop \"${name}\".` +\r\n    ` Expected ${expectedTypes.map(capitalize).join(' | ')}`\r\n  const expectedType = expectedTypes[0]\r\n  const receivedType = toRawType(value)\r\n  const expectedValue = styleValue(value, expectedType)\r\n  const receivedValue = styleValue(value, receivedType)\r\n  // check if we need to specify expected value\r\n  if (\r\n    expectedTypes.length === 1 &&\r\n    isExplicable(expectedType) &&\r\n    !isBoolean(expectedType, receivedType)\r\n  ) {\r\n    message += ` with value ${expectedValue}`\r\n  }\r\n  message += `, got ${receivedType} `\r\n  // check if we need to specify received value\r\n  if (isExplicable(receivedType)) {\r\n    message += `with value ${receivedValue}.`\r\n  }\r\n  return message\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction styleValue(value: unknown, type: string): string {\r\n  if (type === 'String') {\r\n    return `\"${value}\"`\r\n  } else if (type === 'Number') {\r\n    return `${Number(value)}`\r\n  } else {\r\n    return `${value}`\r\n  }\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction isExplicable(type: string): boolean {\r\n  const explicitTypes = ['string', 'number', 'boolean']\r\n  return explicitTypes.some(elem => type.toLowerCase() === elem)\r\n}\r\n\r\n/**\r\n * dev only\r\n */\r\nfunction isBoolean(...args: string[]): boolean {\r\n  return args.some(elem => elem.toLowerCase() === 'boolean')\r\n}\r\n", "import { ComponentInternalInstance, currentInstance } from './component'\r\nimport {\r\n  VNode,\r\n  VNodeNormalizedChildren,\r\n  normalizeVNode,\r\n  VNodeChild,\r\n  InternalObjectKey\r\n} from './vnode'\r\nimport {\r\n  isArray,\r\n  isFunction,\r\n  EMPTY_OBJ,\r\n  ShapeFlags,\r\n  extend,\r\n  def,\r\n  SlotFlags,\r\n  Prettify,\r\n  IfAny\r\n} from '@vue/shared'\r\nimport { warn } from './warning'\r\nimport { isKeepAlive } from './components/KeepAlive'\r\nimport { ContextualRenderFn, withCtx } from './componentRenderContext'\r\nimport { isHmrUpdating } from './hmr'\r\nimport { DeprecationTypes, isCompatEnabled } from './compat/compatConfig'\r\nimport { toRaw } from '@vue/reactivity'\r\nimport { trigger } from '@vue/reactivity'\r\nimport { TriggerOpTypes } from '@vue/reactivity'\r\n\r\nexport type Slot<T extends any = any> = (\r\n  ...args: IfAny<T, any[], [T] | (T extends undefined ? [] : never)>\r\n) => VNode[]\r\n\r\nexport type InternalSlots = {\r\n  [name: string]: Slot | undefined\r\n}\r\n\r\nexport type Slots = Readonly<InternalSlots>\r\n\r\ndeclare const SlotSymbol: unique symbol\r\nexport type SlotsType<T extends Record<string, any> = Record<string, any>> = {\r\n  [SlotSymbol]?: T\r\n}\r\n\r\nexport type StrictUnwrapSlotsType<\r\n  S extends SlotsType,\r\n  T = NonNullable<S[typeof SlotSymbol]>\r\n> = [keyof S] extends [never] ? Slots : Readonly<T> & T\r\n\r\nexport type UnwrapSlotsType<\r\n  S extends SlotsType,\r\n  T = NonNullable<S[typeof SlotSymbol]>\r\n> = [keyof S] extends [never]\r\n  ? Slots\r\n  : Readonly<\r\n      Prettify<{\r\n        [K in keyof T]: NonNullable<T[K]> extends (...args: any[]) => any\r\n          ? T[K]\r\n          : Slot<T[K]>\r\n      }>\r\n    >\r\n\r\nexport type RawSlots = {\r\n  [name: string]: unknown\r\n  // manual render fn hint to skip forced children updates\r\n  $stable?: boolean\r\n  /**\r\n   * for tracking slot owner instance. This is attached during\r\n   * normalizeChildren when the component vnode is created.\r\n   * @internal\r\n   */\r\n  _ctx?: ComponentInternalInstance | null\r\n  /**\r\n   * indicates compiler generated slots\r\n   * we use a reserved property instead of a vnode patchFlag because the slots\r\n   * object may be directly passed down to a child component in a manual\r\n   * render function, and the optimization hint need to be on the slot object\r\n   * itself to be preserved.\r\n   * @internal\r\n   */\r\n  _?: SlotFlags\r\n}\r\n\r\nconst isInternalKey = (key: string) => key[0] === '_' || key === '$stable'\r\n\r\nconst normalizeSlotValue = (value: unknown): VNode[] =>\r\n  isArray(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value as VNodeChild)]\r\n\r\nconst normalizeSlot = (\r\n  key: string,\r\n  rawSlot: Function,\r\n  ctx: ComponentInternalInstance | null | undefined\r\n): Slot => {\r\n  if ((rawSlot as any)._n) {\r\n    // already normalized - #5353\r\n    return rawSlot as Slot\r\n  }\r\n  const normalized = withCtx((...args: any[]) => {\r\n    if (__DEV__ && currentInstance) {\r\n      warn(\r\n        `Slot \"${key}\" invoked outside of the render function: ` +\r\n          `this will not track dependencies used in the slot. ` +\r\n          `Invoke the slot function inside the render function instead.`\r\n      )\r\n    }\r\n    return normalizeSlotValue(rawSlot(...args))\r\n  }, ctx) as Slot\r\n  // NOT a compiled slot\r\n  ;(normalized as ContextualRenderFn)._c = false\r\n  return normalized\r\n}\r\n\r\nconst normalizeObjectSlots = (\r\n  rawSlots: RawSlots,\r\n  slots: InternalSlots,\r\n  instance: ComponentInternalInstance\r\n) => {\r\n  const ctx = rawSlots._ctx\r\n  for (const key in rawSlots) {\r\n    if (isInternalKey(key)) continue\r\n    const value = rawSlots[key]\r\n    if (isFunction(value)) {\r\n      slots[key] = normalizeSlot(key, value, ctx)\r\n    } else if (value != null) {\r\n      if (\r\n        __DEV__ &&\r\n        !(\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance)\r\n        )\r\n      ) {\r\n        warn(\r\n          `Non-function value encountered for slot \"${key}\". ` +\r\n            `Prefer function slots for better performance.`\r\n        )\r\n      }\r\n      const normalized = normalizeSlotValue(value)\r\n      slots[key] = () => normalized\r\n    }\r\n  }\r\n}\r\n\r\nconst normalizeVNodeSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren\r\n) => {\r\n  if (\r\n    __DEV__ &&\r\n    !isKeepAlive(instance.vnode) &&\r\n    !(__COMPAT__ && isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance))\r\n  ) {\r\n    warn(\r\n      `Non-function value encountered for default slot. ` +\r\n        `Prefer function slots for better performance.`\r\n    )\r\n  }\r\n  const normalized = normalizeSlotValue(children)\r\n  instance.slots.default = () => normalized\r\n}\r\n\r\nexport const initSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren\r\n) => {\r\n  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    const type = (children as RawSlots)._\r\n    if (type) {\r\n      // users can get the shallow readonly version of the slots object through `this.$slots`,\r\n      // we should avoid the proxy object polluting the slots of the internal instance\r\n      instance.slots = toRaw(children as InternalSlots)\r\n      // make compiler marker non-enumerable\r\n      def(children as InternalSlots, '_', type)\r\n    } else {\r\n      normalizeObjectSlots(\r\n        children as RawSlots,\r\n        (instance.slots = {}),\r\n        instance\r\n      )\r\n    }\r\n  } else {\r\n    instance.slots = {}\r\n    if (children) {\r\n      normalizeVNodeSlots(instance, children)\r\n    }\r\n  }\r\n  def(instance.slots, InternalObjectKey, 1)\r\n}\r\n\r\nexport const updateSlots = (\r\n  instance: ComponentInternalInstance,\r\n  children: VNodeNormalizedChildren,\r\n  optimized: boolean\r\n) => {\r\n  const { vnode, slots } = instance\r\n  let needDeletionCheck = true\r\n  let deletionComparisonTarget = EMPTY_OBJ\r\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\r\n    const type = (children as RawSlots)._\r\n    if (type) {\r\n      // compiled slots.\r\n      if (__DEV__ && isHmrUpdating) {\r\n        // Parent was HMR updated so slot content may have changed.\r\n        // force update slots and mark instance for hmr as well\r\n        extend(slots, children as Slots)\r\n        trigger(instance, TriggerOpTypes.SET, '$slots')\r\n      } else if (optimized && type === SlotFlags.STABLE) {\r\n        // compiled AND stable.\r\n        // no need to update, and skip stale slots removal.\r\n        needDeletionCheck = false\r\n      } else {\r\n        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n        // normalization.\r\n        extend(slots, children as Slots)\r\n        // #2893\r\n        // when rendering the optimized slots by manually written render function,\r\n        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n        // i.e. let the `renderSlot` create the bailed Fragment\r\n        if (!optimized && type === SlotFlags.STABLE) {\r\n          delete slots._\r\n        }\r\n      }\r\n    } else {\r\n      needDeletionCheck = !(children as RawSlots).$stable\r\n      normalizeObjectSlots(children as RawSlots, slots, instance)\r\n    }\r\n    deletionComparisonTarget = children as RawSlots\r\n  } else if (children) {\r\n    // non slot object children (direct value) passed to a component\r\n    normalizeVNodeSlots(instance, children)\r\n    deletionComparisonTarget = { default: 1 }\r\n  }\r\n\r\n  // delete stale slots\r\n  if (needDeletionCheck) {\r\n    for (const key in slots) {\r\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\r\n        delete slots[key]\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { SuspenseBoundary } from './components/Suspense'\r\nimport { VNode, VNodeNormalizedRef, VNodeNormalizedRefAtom } from './vnode'\r\nimport {\r\n  EMPTY_OBJ,\r\n  hasOwn,\r\n  isArray,\r\n  isFunction,\r\n  isString,\r\n  remove,\r\n  ShapeFlags\r\n} from '@vue/shared'\r\nimport { isAsyncWrapper } from './apiAsyncComponent'\r\nimport { getExposeProxy } from './component'\r\nimport { warn } from './warning'\r\nimport { isRef } from '@vue/reactivity'\r\nimport { callWithErrorHandling, ErrorCodes } from './errorHandling'\r\nimport { SchedulerJob } from './scheduler'\r\nimport { queuePostRenderEffect } from './renderer'\r\n\r\n/**\r\n * Function for handling a template ref\r\n */\r\nexport function setRef(\r\n  rawRef: VNodeNormalizedRef,\r\n  oldRawRef: VNodeNormalizedRef | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  vnode: VNode,\r\n  isUnmount = false\r\n) {\r\n  if (isArray(rawRef)) {\r\n    rawRef.forEach((r, i) =>\r\n      setRef(\r\n        r,\r\n        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\r\n        parentSuspense,\r\n        vnode,\r\n        isUnmount\r\n      )\r\n    )\r\n    return\r\n  }\r\n\r\n  if (isAsyncWrapper(vnode) && !isUnmount) {\r\n    // when mounting async components, nothing needs to be done,\r\n    // because the template ref is forwarded to inner component\r\n    return\r\n  }\r\n\r\n  const refValue =\r\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\r\n      ? getExposeProxy(vnode.component!) || vnode.component!.proxy\r\n      : vnode.el\r\n  const value = isUnmount ? null : refValue\r\n\r\n  const { i: owner, r: ref } = rawRef\r\n  if (__DEV__ && !owner) {\r\n    warn(\r\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\r\n        `A vnode with ref must be created inside the render function.`\r\n    )\r\n    return\r\n  }\r\n  const oldRef = oldRawRef && (oldRawRef as VNodeNormalizedRefAtom).r\r\n  const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs\r\n  const setupState = owner.setupState\r\n\r\n  // dynamic ref changed. unset old ref\r\n  if (oldRef != null && oldRef !== ref) {\r\n    if (isString(oldRef)) {\r\n      refs[oldRef] = null\r\n      if (hasOwn(setupState, oldRef)) {\r\n        setupState[oldRef] = null\r\n      }\r\n    } else if (isRef(oldRef)) {\r\n      oldRef.value = null\r\n    }\r\n  }\r\n\r\n  if (isFunction(ref)) {\r\n    callWithErrorHandling(ref, owner, ErrorCodes.FUNCTION_REF, [value, refs])\r\n  } else {\r\n    const _isString = isString(ref)\r\n    const _isRef = isRef(ref)\r\n    if (_isString || _isRef) {\r\n      const doSet = () => {\r\n        if (rawRef.f) {\r\n          const existing = _isString\r\n            ? hasOwn(setupState, ref)\r\n              ? setupState[ref]\r\n              : refs[ref]\r\n            : ref.value\r\n          if (isUnmount) {\r\n            isArray(existing) && remove(existing, refValue)\r\n          } else {\r\n            if (!isArray(existing)) {\r\n              if (_isString) {\r\n                refs[ref] = [refValue]\r\n                if (hasOwn(setupState, ref)) {\r\n                  setupState[ref] = refs[ref]\r\n                }\r\n              } else {\r\n                ref.value = [refValue]\r\n                if (rawRef.k) refs[rawRef.k] = ref.value\r\n              }\r\n            } else if (!existing.includes(refValue)) {\r\n              existing.push(refValue)\r\n            }\r\n          }\r\n        } else if (_isString) {\r\n          refs[ref] = value\r\n          if (hasOwn(setupState, ref)) {\r\n            setupState[ref] = value\r\n          }\r\n        } else if (_isRef) {\r\n          ref.value = value\r\n          if (rawRef.k) refs[rawRef.k] = value\r\n        } else if (__DEV__) {\r\n          warn('Invalid template ref type:', ref, `(${typeof ref})`)\r\n        }\r\n      }\r\n      if (value) {\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        ;(doSet as SchedulerJob).id = -1\r\n        queuePostRenderEffect(doSet, parentSuspense)\r\n      } else {\r\n        doSet()\r\n      }\r\n    } else if (__DEV__) {\r\n      warn('Invalid template ref type:', ref, `(${typeof ref})`)\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  VNode,\r\n  normalizeVNode,\r\n  Text,\r\n  Comment,\r\n  Static,\r\n  Fragment,\r\n  VNodeHook,\r\n  createVNode,\r\n  createTextVNode,\r\n  invokeVNodeHook\r\n} from './vnode'\r\nimport { flushPostFlushCbs } from './scheduler'\r\nimport { ComponentInternalInstance } from './component'\r\nimport { invokeDirectiveHook } from './directives'\r\nimport { warn } from './warning'\r\nimport { PatchFlags, ShapeFlags, isReservedProp, isOn } from '@vue/shared'\r\nimport { needTransition, RendererInternals } from './renderer'\r\nimport { setRef } from './rendererTemplateRef'\r\nimport {\r\n  SuspenseImpl,\r\n  SuspenseBoundary,\r\n  queueEffectWithSuspense\r\n} from './components/Suspense'\r\nimport { TeleportImpl, TeleportVNode } from './components/Teleport'\r\nimport { isAsyncWrapper } from './apiAsyncComponent'\r\n\r\nexport type RootHydrateFunction = (\r\n  vnode: VNode<Node, Element>,\r\n  container: (Element | ShadowRoot) & { _vnode?: VNode }\r\n) => void\r\n\r\nconst enum DOMNodeTypes {\r\n  ELEMENT = 1,\r\n  TEXT = 3,\r\n  COMMENT = 8\r\n}\r\n\r\nlet hasMismatch = false\r\n\r\nconst isSVGContainer = (container: Element) =>\r\n  /svg/.test(container.namespaceURI!) && container.tagName !== 'foreignObject'\r\n\r\nconst isComment = (node: Node): node is Comment =>\r\n  node.nodeType === DOMNodeTypes.COMMENT\r\n\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nexport function createHydrationFunctions(\r\n  rendererInternals: RendererInternals<Node, Element>\r\n) {\r\n  const {\r\n    mt: mountComponent,\r\n    p: patch,\r\n    o: {\r\n      patchProp,\r\n      createText,\r\n      nextSibling,\r\n      parentNode,\r\n      remove,\r\n      insert,\r\n      createComment\r\n    }\r\n  } = rendererInternals\r\n\r\n  const hydrate: RootHydrateFunction = (vnode, container) => {\r\n    if (!container.hasChildNodes()) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Attempting to hydrate existing markup but container is empty. ` +\r\n            `Performing full mount instead.`\r\n        )\r\n      patch(null, vnode, container)\r\n      flushPostFlushCbs()\r\n      container._vnode = vnode\r\n      return\r\n    }\r\n    hasMismatch = false\r\n    hydrateNode(container.firstChild!, vnode, null, null, null)\r\n    flushPostFlushCbs()\r\n    container._vnode = vnode\r\n    if (hasMismatch && !__TEST__) {\r\n      // this error should show up in production\r\n      console.error(`Hydration completed but contains mismatches.`)\r\n    }\r\n  }\r\n\r\n  const hydrateNode = (\r\n    node: Node,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized = false\r\n  ): Node | null => {\r\n    const isFragmentStart = isComment(node) && node.data === '['\r\n    const onMismatch = () =>\r\n      handleMismatch(\r\n        node,\r\n        vnode,\r\n        parentComponent,\r\n        parentSuspense,\r\n        slotScopeIds,\r\n        isFragmentStart\r\n      )\r\n\r\n    const { type, ref, shapeFlag, patchFlag } = vnode\r\n    let domType = node.nodeType\r\n    vnode.el = node\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      if (!('__vnode' in node)) {\r\n        Object.defineProperty(node, '__vnode', {\r\n          value: vnode,\r\n          enumerable: false\r\n        })\r\n      }\r\n      if (!('__vueParentComponent' in node)) {\r\n        Object.defineProperty(node, '__vueParentComponent', {\r\n          value: parentComponent,\r\n          enumerable: false\r\n        })\r\n      }\r\n    }\r\n\r\n    if (patchFlag === PatchFlags.BAIL) {\r\n      optimized = false\r\n      vnode.dynamicChildren = null\r\n    }\r\n\r\n    let nextNode: Node | null = null\r\n    switch (type) {\r\n      case Text:\r\n        if (domType !== DOMNodeTypes.TEXT) {\r\n          // #5728 empty text node inside a slot can cause hydration failure\r\n          // because the server rendered HTML won't contain a text node\r\n          if (vnode.children === '') {\r\n            insert((vnode.el = createText('')), parentNode(node)!, node)\r\n            nextNode = node\r\n          } else {\r\n            nextNode = onMismatch()\r\n          }\r\n        } else {\r\n          if ((node as Text).data !== vnode.children) {\r\n            hasMismatch = true\r\n            __DEV__ &&\r\n              warn(\r\n                `Hydration text mismatch:` +\r\n                  `\\n- Server rendered: ${JSON.stringify(\r\n                    (node as Text).data\r\n                  )}` +\r\n                  `\\n- Client rendered: ${JSON.stringify(vnode.children)}`\r\n              )\r\n            ;(node as Text).data = vnode.children as string\r\n          }\r\n          nextNode = nextSibling(node)\r\n        }\r\n        break\r\n      case Comment:\r\n        if (isTemplateNode(node)) {\r\n          nextNode = nextSibling(node)\r\n          // wrapped <transition appear>\r\n          // replace <template> node with inner child\r\n          replaceNode(\r\n            (vnode.el = node.content.firstChild!),\r\n            node,\r\n            parentComponent\r\n          )\r\n        } else if (domType !== DOMNodeTypes.COMMENT || isFragmentStart) {\r\n          nextNode = onMismatch()\r\n        } else {\r\n          nextNode = nextSibling(node)\r\n        }\r\n        break\r\n      case Static:\r\n        if (isFragmentStart) {\r\n          // entire template is static but SSRed as a fragment\r\n          node = nextSibling(node)!\r\n          domType = node.nodeType\r\n        }\r\n        if (domType === DOMNodeTypes.ELEMENT || domType === DOMNodeTypes.TEXT) {\r\n          // determine anchor, adopt content\r\n          nextNode = node\r\n          // if the static vnode has its content stripped during build,\r\n          // adopt it from the server-rendered HTML.\r\n          const needToAdoptContent = !(vnode.children as string).length\r\n          for (let i = 0; i < vnode.staticCount!; i++) {\r\n            if (needToAdoptContent)\r\n              vnode.children +=\r\n                nextNode.nodeType === DOMNodeTypes.ELEMENT\r\n                  ? (nextNode as Element).outerHTML\r\n                  : (nextNode as Text).data\r\n            if (i === vnode.staticCount! - 1) {\r\n              vnode.anchor = nextNode\r\n            }\r\n            nextNode = nextSibling(nextNode)!\r\n          }\r\n          return isFragmentStart ? nextSibling(nextNode) : nextNode\r\n        } else {\r\n          onMismatch()\r\n        }\r\n        break\r\n      case Fragment:\r\n        if (!isFragmentStart) {\r\n          nextNode = onMismatch()\r\n        } else {\r\n          nextNode = hydrateFragment(\r\n            node as Comment,\r\n            vnode,\r\n            parentComponent,\r\n            parentSuspense,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        }\r\n        break\r\n      default:\r\n        if (shapeFlag & ShapeFlags.ELEMENT) {\r\n          if (\r\n            (domType !== DOMNodeTypes.ELEMENT ||\r\n              (vnode.type as string).toLowerCase() !==\r\n                (node as Element).tagName.toLowerCase()) &&\r\n            !isTemplateNode(node)\r\n          ) {\r\n            nextNode = onMismatch()\r\n          } else {\r\n            nextNode = hydrateElement(\r\n              node as Element,\r\n              vnode,\r\n              parentComponent,\r\n              parentSuspense,\r\n              slotScopeIds,\r\n              optimized\r\n            )\r\n          }\r\n        } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n          // when setting up the render effect, if the initial vnode already\r\n          // has .el set, the component will perform hydration instead of mount\r\n          // on its sub-tree.\r\n          vnode.slotScopeIds = slotScopeIds\r\n          const container = parentNode(node)!\r\n\r\n          // Locate the next node.\r\n          if (isFragmentStart) {\r\n            // If it's a fragment: since components may be async, we cannot rely\r\n            // on component's rendered output to determine the end of the\r\n            // fragment. Instead, we do a lookahead to find the end anchor node.\r\n            nextNode = locateClosingAnchor(node)\r\n          } else if (isComment(node) && node.data === 'teleport start') {\r\n            // #4293 #6152\r\n            // If a teleport is at component root, look ahead for teleport end.\r\n            nextNode = locateClosingAnchor(node, node.data, 'teleport end')\r\n          } else {\r\n            nextNode = nextSibling(node)\r\n          }\r\n\r\n          mountComponent(\r\n            vnode,\r\n            container,\r\n            null,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVGContainer(container),\r\n            optimized\r\n          )\r\n\r\n          // #3787\r\n          // if component is async, it may get moved / unmounted before its\r\n          // inner component is loaded, so we need to give it a placeholder\r\n          // vnode that matches its adopted DOM.\r\n          if (isAsyncWrapper(vnode)) {\r\n            let subTree\r\n            if (isFragmentStart) {\r\n              subTree = createVNode(Fragment)\r\n              subTree.anchor = nextNode\r\n                ? nextNode.previousSibling\r\n                : container.lastChild\r\n            } else {\r\n              subTree =\r\n                node.nodeType === 3 ? createTextVNode('') : createVNode('div')\r\n            }\r\n            subTree.el = node\r\n            vnode.component!.subTree = subTree\r\n          }\r\n        } else if (shapeFlag & ShapeFlags.TELEPORT) {\r\n          if (domType !== DOMNodeTypes.COMMENT) {\r\n            nextNode = onMismatch()\r\n          } else {\r\n            nextNode = (vnode.type as typeof TeleportImpl).hydrate(\r\n              node,\r\n              vnode as TeleportVNode,\r\n              parentComponent,\r\n              parentSuspense,\r\n              slotScopeIds,\r\n              optimized,\r\n              rendererInternals,\r\n              hydrateChildren\r\n            )\r\n          }\r\n        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n          nextNode = (vnode.type as typeof SuspenseImpl).hydrate(\r\n            node,\r\n            vnode,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVGContainer(parentNode(node)!),\r\n            slotScopeIds,\r\n            optimized,\r\n            rendererInternals,\r\n            hydrateNode\r\n          )\r\n        } else if (__DEV__) {\r\n          warn('Invalid HostVNode type:', type, `(${typeof type})`)\r\n        }\r\n    }\r\n\r\n    if (ref != null) {\r\n      setRef(ref, null, parentSuspense, vnode)\r\n    }\r\n\r\n    return nextNode\r\n  }\r\n\r\n  const hydrateElement = (\r\n    el: Element,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    optimized = optimized || !!vnode.dynamicChildren\r\n    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode\r\n    // #4006 for form elements with non-string v-model value bindings\r\n    // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\r\n    // #7476 <input indeterminate>\r\n    const forcePatch = type === 'input' || type === 'option'\r\n    // skip props & children if this is hoisted static nodes\r\n    // #5405 in dev, always hydrate children for HMR\r\n    if (__DEV__ || forcePatch || patchFlag !== PatchFlags.HOISTED) {\r\n      if (dirs) {\r\n        invokeDirectiveHook(vnode, null, parentComponent, 'created')\r\n      }\r\n\r\n      // handle appear transition\r\n      let needCallTransitionHooks = false\r\n      if (isTemplateNode(el)) {\r\n        needCallTransitionHooks =\r\n          needTransition(parentSuspense, transition) &&\r\n          parentComponent &&\r\n          parentComponent.vnode.props &&\r\n          parentComponent.vnode.props.appear\r\n\r\n        const content = (el as HTMLTemplateElement).content\r\n          .firstChild as Element\r\n\r\n        if (needCallTransitionHooks) {\r\n          transition!.beforeEnter(content)\r\n        }\r\n\r\n        // replace <template> node with inner children\r\n        replaceNode(content, el, parentComponent)\r\n        vnode.el = el = content\r\n      }\r\n\r\n      // props\r\n      if (props) {\r\n        if (\r\n          forcePatch ||\r\n          !optimized ||\r\n          patchFlag & (PatchFlags.FULL_PROPS | PatchFlags.NEED_HYDRATION)\r\n        ) {\r\n          for (const key in props) {\r\n            if (\r\n              (forcePatch &&\r\n                (key.endsWith('value') || key === 'indeterminate')) ||\r\n              (isOn(key) && !isReservedProp(key)) ||\r\n              // force hydrate v-bind with .prop modifiers\r\n              key[0] === '.'\r\n            ) {\r\n              patchProp(\r\n                el,\r\n                key,\r\n                null,\r\n                props[key],\r\n                false,\r\n                undefined,\r\n                parentComponent\r\n              )\r\n            }\r\n          }\r\n        } else if (props.onClick) {\r\n          // Fast path for click listeners (which is most often) to avoid\r\n          // iterating through props.\r\n          patchProp(\r\n            el,\r\n            'onClick',\r\n            null,\r\n            props.onClick,\r\n            false,\r\n            undefined,\r\n            parentComponent\r\n          )\r\n        }\r\n      }\r\n      // vnode / directive hooks\r\n      let vnodeHooks: VNodeHook | null | undefined\r\n      if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode)\r\n      }\r\n\r\n      if (dirs) {\r\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')\r\n      }\r\n\r\n      if (\r\n        (vnodeHooks = props && props.onVnodeMounted) ||\r\n        dirs ||\r\n        needCallTransitionHooks\r\n      ) {\r\n        queueEffectWithSuspense(() => {\r\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode)\r\n          needCallTransitionHooks && transition!.enter(el)\r\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted')\r\n        }, parentSuspense)\r\n      }\r\n      // children\r\n      if (\r\n        shapeFlag & ShapeFlags.ARRAY_CHILDREN &&\r\n        // skip if element has innerHTML / textContent\r\n        !(props && (props.innerHTML || props.textContent))\r\n      ) {\r\n        let next = hydrateChildren(\r\n          el.firstChild,\r\n          vnode,\r\n          el,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        let hasWarned = false\r\n        while (next) {\r\n          hasMismatch = true\r\n          if (__DEV__ && !hasWarned) {\r\n            warn(\r\n              `Hydration children mismatch in <${vnode.type as string}>: ` +\r\n                `server rendered element contains more child nodes than client vdom.`\r\n            )\r\n            hasWarned = true\r\n          }\r\n          // The SSRed DOM contains more nodes than it should. Remove them.\r\n          const cur = next\r\n          next = next.nextSibling\r\n          remove(cur)\r\n        }\r\n      } else if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n        if (el.textContent !== vnode.children) {\r\n          hasMismatch = true\r\n          __DEV__ &&\r\n            warn(\r\n              `Hydration text content mismatch in <${\r\n                vnode.type as string\r\n              }>:\\n` +\r\n                `- Server rendered: ${el.textContent}\\n` +\r\n                `- Client rendered: ${vnode.children as string}`\r\n            )\r\n          el.textContent = vnode.children as string\r\n        }\r\n      }\r\n    }\r\n    return el.nextSibling\r\n  }\r\n\r\n  const hydrateChildren = (\r\n    node: Node | null,\r\n    parentVNode: VNode,\r\n    container: Element,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ): Node | null => {\r\n    optimized = optimized || !!parentVNode.dynamicChildren\r\n    const children = parentVNode.children as VNode[]\r\n    const l = children.length\r\n    let hasWarned = false\r\n    for (let i = 0; i < l; i++) {\r\n      const vnode = optimized\r\n        ? children[i]\r\n        : (children[i] = normalizeVNode(children[i]))\r\n      if (node) {\r\n        node = hydrateNode(\r\n          node,\r\n          vnode,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n      } else if (vnode.type === Text && !vnode.children) {\r\n        continue\r\n      } else {\r\n        hasMismatch = true\r\n        if (__DEV__ && !hasWarned) {\r\n          warn(\r\n            `Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\r\n              `server rendered element contains fewer child nodes than client vdom.`\r\n          )\r\n          hasWarned = true\r\n        }\r\n        // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n        patch(\r\n          null,\r\n          vnode,\r\n          container,\r\n          null,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVGContainer(container),\r\n          slotScopeIds\r\n        )\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  const hydrateFragment = (\r\n    node: Comment,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode\r\n    if (fragmentSlotScopeIds) {\r\n      slotScopeIds = slotScopeIds\r\n        ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n        : fragmentSlotScopeIds\r\n    }\r\n\r\n    const container = parentNode(node)!\r\n    const next = hydrateChildren(\r\n      nextSibling(node)!,\r\n      vnode,\r\n      container,\r\n      parentComponent,\r\n      parentSuspense,\r\n      slotScopeIds,\r\n      optimized\r\n    )\r\n    if (next && isComment(next) && next.data === ']') {\r\n      return nextSibling((vnode.anchor = next))\r\n    } else {\r\n      // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n      // back. This should have led to node/children mismatch warnings.\r\n      hasMismatch = true\r\n      // since the anchor is missing, we need to create one and insert it\r\n      insert((vnode.anchor = createComment(`]`)), container, next)\r\n      return next\r\n    }\r\n  }\r\n\r\n  const handleMismatch = (\r\n    node: Node,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    isFragment: boolean\r\n  ): Node | null => {\r\n    hasMismatch = true\r\n    __DEV__ &&\r\n      warn(\r\n        `Hydration node mismatch:\\n- Client vnode:`,\r\n        vnode.type,\r\n        `\\n- Server rendered DOM:`,\r\n        node,\r\n        node.nodeType === DOMNodeTypes.TEXT\r\n          ? `(text)`\r\n          : isComment(node) && node.data === '['\r\n            ? `(start of fragment)`\r\n            : ``\r\n      )\r\n    vnode.el = null\r\n\r\n    if (isFragment) {\r\n      // remove excessive fragment nodes\r\n      const end = locateClosingAnchor(node)\r\n      while (true) {\r\n        const next = nextSibling(node)\r\n        if (next && next !== end) {\r\n          remove(next)\r\n        } else {\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    const next = nextSibling(node)\r\n    const container = parentNode(node)!\r\n    remove(node)\r\n\r\n    patch(\r\n      null,\r\n      vnode,\r\n      container,\r\n      next,\r\n      parentComponent,\r\n      parentSuspense,\r\n      isSVGContainer(container),\r\n      slotScopeIds\r\n    )\r\n    return next\r\n  }\r\n\r\n  // looks ahead for a start and closing comment node\r\n  const locateClosingAnchor = (\r\n    node: Node | null,\r\n    open = '[',\r\n    close = ']'\r\n  ): Node | null => {\r\n    let match = 0\r\n    while (node) {\r\n      node = nextSibling(node)\r\n      if (node && isComment(node)) {\r\n        if (node.data === open) match++\r\n        if (node.data === close) {\r\n          if (match === 0) {\r\n            return nextSibling(node)\r\n          } else {\r\n            match--\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  const replaceNode = (\r\n    newNode: Node,\r\n    oldNode: Node,\r\n    parentComponent: ComponentInternalInstance | null\r\n  ): void => {\r\n    // replace node\r\n    const parentNode = oldNode.parentNode\r\n    if (parentNode) {\r\n      parentNode.replaceChild(newNode, oldNode)\r\n    }\r\n\r\n    // update vnode\r\n    let parent = parentComponent\r\n    while (parent) {\r\n      if (parent.vnode.el === oldNode) {\r\n        parent.vnode.el = parent.subTree.el = newNode\r\n      }\r\n      parent = parent.parent\r\n    }\r\n  }\r\n\r\n  const isTemplateNode = (node: Node): node is HTMLTemplateElement => {\r\n    return (\r\n      node.nodeType === DOMNodeTypes.ELEMENT &&\r\n      (node as Element).tagName.toLowerCase() === 'template'\r\n    )\r\n  }\r\n\r\n  return [hydrate, hydrateNode] as const\r\n}\r\n", "/* eslint-disable no-restricted-globals */\r\nimport { ComponentInternalInstance, formatComponentName } from './component'\r\nimport { devtoolsPerfEnd, devtoolsPerfStart } from './devtools'\r\n\r\nlet supported: boolean\r\nlet perf: Performance\r\n\r\nexport function startMeasure(\r\n  instance: ComponentInternalInstance,\r\n  type: string\r\n) {\r\n  if (instance.appContext.config.performance && isSupported()) {\r\n    perf.mark(`vue-${type}-${instance.uid}`)\r\n  }\r\n\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now())\r\n  }\r\n}\r\n\r\nexport function endMeasure(instance: ComponentInternalInstance, type: string) {\r\n  if (instance.appContext.config.performance && isSupported()) {\r\n    const startTag = `vue-${type}-${instance.uid}`\r\n    const endTag = startTag + `:end`\r\n    perf.mark(endTag)\r\n    perf.measure(\r\n      `<${formatComponentName(instance, instance.type)}> ${type}`,\r\n      startTag,\r\n      endTag\r\n    )\r\n    perf.clearMarks(startTag)\r\n    perf.clearMarks(endTag)\r\n  }\r\n\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now())\r\n  }\r\n}\r\n\r\nfunction isSupported() {\r\n  if (supported !== undefined) {\r\n    return supported\r\n  }\r\n  if (typeof window !== 'undefined' && window.performance) {\r\n    supported = true\r\n    perf = window.performance\r\n  } else {\r\n    supported = false\r\n  }\r\n  return supported\r\n}\r\n", "import {\r\n  Text,\r\n  Fragment,\r\n  Comment,\r\n  cloneIfMounted,\r\n  normalizeVNode,\r\n  VNode,\r\n  VNodeArrayChildren,\r\n  createVNode,\r\n  isSameVNodeType,\r\n  Static,\r\n  VNodeHook,\r\n  VNodeProps,\r\n  invokeVNodeHook\r\n} from './vnode'\r\nimport {\r\n  ComponentInternalInstance,\r\n  ComponentOptions,\r\n  createComponentInstance,\r\n  Data,\r\n  setupComponent\r\n} from './component'\r\nimport {\r\n  filterSingleRoot,\r\n  renderComponentRoot,\r\n  shouldUpdateComponent,\r\n  updateHOCHostEl\r\n} from './componentRenderUtils'\r\nimport {\r\n  EMPTY_OBJ,\r\n  EMPTY_ARR,\r\n  isReservedProp,\r\n  PatchFlags,\r\n  ShapeFlags,\r\n  NOOP,\r\n  invokeArrayFns,\r\n  isArray,\r\n  getGlobalThis\r\n} from '@vue/shared'\r\nimport {\r\n  queueJob,\r\n  queuePostFlushCb,\r\n  flushPostFlushCbs,\r\n  invalidateJob,\r\n  flushPreFlushCbs,\r\n  SchedulerJob\r\n} from './scheduler'\r\nimport { pauseTracking, resetTracking, ReactiveEffect } from '@vue/reactivity'\r\nimport { updateProps } from './componentProps'\r\nimport { updateSlots } from './componentSlots'\r\nimport { pushWarningContext, popWarningContext, warn } from './warning'\r\nimport { createAppAPI, CreateAppFunction } from './apiCreateApp'\r\nimport { setRef } from './rendererTemplateRef'\r\nimport {\r\n  SuspenseBoundary,\r\n  queueEffectWithSuspense,\r\n  SuspenseImpl\r\n} from './components/Suspense'\r\nimport { TeleportImpl, TeleportVNode } from './components/Teleport'\r\nimport { isKeepAlive, KeepAliveContext } from './components/KeepAlive'\r\nimport { registerHMR, unregisterHMR, isHmrUpdating } from './hmr'\r\nimport { createHydrationFunctions, RootHydrateFunction } from './hydration'\r\nimport { invokeDirectiveHook } from './directives'\r\nimport { startMeasure, endMeasure } from './profiling'\r\nimport {\r\n  devtoolsComponentAdded,\r\n  devtoolsComponentRemoved,\r\n  devtoolsComponentUpdated,\r\n  setDevtoolsHook\r\n} from './devtools'\r\nimport { initFeatureFlags } from './featureFlags'\r\nimport { isAsyncWrapper } from './apiAsyncComponent'\r\nimport { isCompatEnabled } from './compat/compatConfig'\r\nimport { DeprecationTypes } from './compat/compatConfig'\r\nimport { TransitionHooks } from './components/BaseTransition'\r\n\r\nexport interface Renderer<HostElement = RendererElement> {\r\n  render: RootRenderFunction<HostElement>\r\n  createApp: CreateAppFunction<HostElement>\r\n}\r\n\r\nexport interface HydrationRenderer extends Renderer<Element | ShadowRoot> {\r\n  hydrate: RootHydrateFunction\r\n}\r\n\r\nexport type RootRenderFunction<HostElement = RendererElement> = (\r\n  vnode: VNode | null,\r\n  container: HostElement,\r\n  isSVG?: boolean\r\n) => void\r\n\r\nexport interface RendererOptions<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement\r\n> {\r\n  patchProp(\r\n    el: HostElement,\r\n    key: string,\r\n    prevValue: any,\r\n    nextValue: any,\r\n    isSVG?: boolean,\r\n    prevChildren?: VNode<HostNode, HostElement>[],\r\n    parentComponent?: ComponentInternalInstance | null,\r\n    parentSuspense?: SuspenseBoundary | null,\r\n    unmountChildren?: UnmountChildrenFn\r\n  ): void\r\n  insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\r\n  remove(el: HostNode): void\r\n  createElement(\r\n    type: string,\r\n    isSVG?: boolean,\r\n    isCustomizedBuiltIn?: string,\r\n    vnodeProps?: (VNodeProps & { [key: string]: any }) | null\r\n  ): HostElement\r\n  createText(text: string): HostNode\r\n  createComment(text: string): HostNode\r\n  setText(node: HostNode, text: string): void\r\n  setElementText(node: HostElement, text: string): void\r\n  parentNode(node: HostNode): HostElement | null\r\n  nextSibling(node: HostNode): HostNode | null\r\n  querySelector?(selector: string): HostElement | null\r\n  setScopeId?(el: HostElement, id: string): void\r\n  cloneNode?(node: HostNode): HostNode\r\n  insertStaticContent?(\r\n    content: string,\r\n    parent: HostElement,\r\n    anchor: HostNode | null,\r\n    isSVG: boolean,\r\n    start?: HostNode | null,\r\n    end?: HostNode | null\r\n  ): [HostNode, HostNode]\r\n}\r\n\r\n// Renderer Node can technically be any object in the context of core renderer\r\n// logic - they are never directly operated on and always passed to the node op\r\n// functions provided via options, so the internal constraint is really just\r\n// a generic object.\r\nexport interface RendererNode {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface RendererElement extends RendererNode {}\r\n\r\n// An object exposing the internals of a renderer, passed to tree-shakeable\r\n// features so that they can be decoupled from this file. Keys are shortened\r\n// to optimize bundle size.\r\nexport interface RendererInternals<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement\r\n> {\r\n  p: PatchFn\r\n  um: UnmountFn\r\n  r: RemoveFn\r\n  m: MoveFn\r\n  mt: MountComponentFn\r\n  mc: MountChildrenFn\r\n  pc: PatchChildrenFn\r\n  pbc: PatchBlockChildrenFn\r\n  n: NextFn\r\n  o: RendererOptions<HostNode, HostElement>\r\n}\r\n\r\n// These functions are created inside a closure and therefore their types cannot\r\n// be directly exported. In order to avoid maintaining function signatures in\r\n// two places, we declare them once here and use them inside the closure.\r\ntype PatchFn = (\r\n  n1: VNode | null, // null means this is a mount\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor?: RendererNode | null,\r\n  parentComponent?: ComponentInternalInstance | null,\r\n  parentSuspense?: SuspenseBoundary | null,\r\n  isSVG?: boolean,\r\n  slotScopeIds?: string[] | null,\r\n  optimized?: boolean\r\n) => void\r\n\r\ntype MountChildrenFn = (\r\n  children: VNodeArrayChildren,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  start?: number\r\n) => void\r\n\r\ntype PatchChildrenFn = (\r\n  n1: VNode | null,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean\r\n) => void\r\n\r\ntype PatchBlockChildrenFn = (\r\n  oldChildren: VNode[],\r\n  newChildren: VNode[],\r\n  fallbackContainer: RendererElement,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null\r\n) => void\r\n\r\ntype MoveFn = (\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  type: MoveType,\r\n  parentSuspense?: SuspenseBoundary | null\r\n) => void\r\n\r\ntype NextFn = (vnode: VNode) => RendererNode | null\r\n\r\ntype UnmountFn = (\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  doRemove?: boolean,\r\n  optimized?: boolean\r\n) => void\r\n\r\ntype RemoveFn = (vnode: VNode) => void\r\n\r\ntype UnmountChildrenFn = (\r\n  children: VNode[],\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  doRemove?: boolean,\r\n  optimized?: boolean,\r\n  start?: number\r\n) => void\r\n\r\nexport type MountComponentFn = (\r\n  initialVNode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  optimized: boolean\r\n) => void\r\n\r\ntype ProcessTextOrCommentFn = (\r\n  n1: VNode | null,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null\r\n) => void\r\n\r\nexport type SetupRenderEffectFn = (\r\n  instance: ComponentInternalInstance,\r\n  initialVNode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  optimized: boolean\r\n) => void\r\n\r\nexport const enum MoveType {\r\n  ENTER,\r\n  LEAVE,\r\n  REORDER\r\n}\r\n\r\nexport const queuePostRenderEffect = __FEATURE_SUSPENSE__\r\n  ? __TEST__\r\n    ? // vitest can't seem to handle eager circular dependency\r\n      (fn: Function | Function[], suspense: SuspenseBoundary | null) =>\r\n        queueEffectWithSuspense(fn, suspense)\r\n    : queueEffectWithSuspense\r\n  : queuePostFlushCb\r\n\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nexport function createRenderer<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement\r\n>(options: RendererOptions<HostNode, HostElement>) {\r\n  return baseCreateRenderer<HostNode, HostElement>(options)\r\n}\r\n\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nexport function createHydrationRenderer(\r\n  options: RendererOptions<Node, Element>\r\n) {\r\n  return baseCreateRenderer(options, createHydrationFunctions)\r\n}\r\n\r\n// overload 1: no hydration\r\nfunction baseCreateRenderer<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement\r\n>(options: RendererOptions<HostNode, HostElement>): Renderer<HostElement>\r\n\r\n// overload 2: with hydration\r\nfunction baseCreateRenderer(\r\n  options: RendererOptions<Node, Element>,\r\n  createHydrationFns: typeof createHydrationFunctions\r\n): HydrationRenderer\r\n\r\n// implementation\r\nfunction baseCreateRenderer(\r\n  options: RendererOptions,\r\n  createHydrationFns?: typeof createHydrationFunctions\r\n): any {\r\n  // compile-time feature flags check\r\n  if (__ESM_BUNDLER__ && !__TEST__) {\r\n    initFeatureFlags()\r\n  }\r\n\r\n  const target = getGlobalThis()\r\n  target.__VUE__ = true\r\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target)\r\n  }\r\n\r\n  const {\r\n    insert: hostInsert,\r\n    remove: hostRemove,\r\n    patchProp: hostPatchProp,\r\n    createElement: hostCreateElement,\r\n    createText: hostCreateText,\r\n    createComment: hostCreateComment,\r\n    setText: hostSetText,\r\n    setElementText: hostSetElementText,\r\n    parentNode: hostParentNode,\r\n    nextSibling: hostNextSibling,\r\n    setScopeId: hostSetScopeId = NOOP,\r\n    insertStaticContent: hostInsertStaticContent\r\n  } = options\r\n\r\n  // Note: functions inside this closure should use `const xxx = () => {}`\r\n  // style in order to prevent being inlined by minifiers.\r\n  const patch: PatchFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor = null,\r\n    parentComponent = null,\r\n    parentSuspense = null,\r\n    isSVG = false,\r\n    slotScopeIds = null,\r\n    optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren\r\n  ) => {\r\n    if (n1 === n2) {\r\n      return\r\n    }\r\n\r\n    // patching & not same type, unmount old tree\r\n    if (n1 && !isSameVNodeType(n1, n2)) {\r\n      anchor = getNextHostNode(n1)\r\n      unmount(n1, parentComponent, parentSuspense, true)\r\n      n1 = null\r\n    }\r\n\r\n    if (n2.patchFlag === PatchFlags.BAIL) {\r\n      optimized = false\r\n      n2.dynamicChildren = null\r\n    }\r\n\r\n    const { type, ref, shapeFlag } = n2\r\n    switch (type) {\r\n      case Text:\r\n        processText(n1, n2, container, anchor)\r\n        break\r\n      case Comment:\r\n        processCommentNode(n1, n2, container, anchor)\r\n        break\r\n      case Static:\r\n        if (n1 == null) {\r\n          mountStaticNode(n2, container, anchor, isSVG)\r\n        } else if (__DEV__) {\r\n          patchStaticNode(n1, n2, container, isSVG)\r\n        }\r\n        break\r\n      case Fragment:\r\n        processFragment(\r\n          n1,\r\n          n2,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        break\r\n      default:\r\n        if (shapeFlag & ShapeFlags.ELEMENT) {\r\n          processElement(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        } else if (shapeFlag & ShapeFlags.COMPONENT) {\r\n          processComponent(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        } else if (shapeFlag & ShapeFlags.TELEPORT) {\r\n          ;(type as typeof TeleportImpl).process(\r\n            n1 as TeleportVNode,\r\n            n2 as TeleportVNode,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized,\r\n            internals\r\n          )\r\n        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n          ;(type as typeof SuspenseImpl).process(\r\n            n1,\r\n            n2,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized,\r\n            internals\r\n          )\r\n        } else if (__DEV__) {\r\n          warn('Invalid VNode type:', type, `(${typeof type})`)\r\n        }\r\n    }\r\n\r\n    // set ref\r\n    if (ref != null && parentComponent) {\r\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2)\r\n    }\r\n  }\r\n\r\n  const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {\r\n    if (n1 == null) {\r\n      hostInsert(\r\n        (n2.el = hostCreateText(n2.children as string)),\r\n        container,\r\n        anchor\r\n      )\r\n    } else {\r\n      const el = (n2.el = n1.el!)\r\n      if (n2.children !== n1.children) {\r\n        hostSetText(el, n2.children as string)\r\n      }\r\n    }\r\n  }\r\n\r\n  const processCommentNode: ProcessTextOrCommentFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor\r\n  ) => {\r\n    if (n1 == null) {\r\n      hostInsert(\r\n        (n2.el = hostCreateComment((n2.children as string) || '')),\r\n        container,\r\n        anchor\r\n      )\r\n    } else {\r\n      // there's no support for dynamic comments\r\n      n2.el = n1.el\r\n    }\r\n  }\r\n\r\n  const mountStaticNode = (\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    isSVG: boolean\r\n  ) => {\r\n    // static nodes are only present when used with compiler-dom/runtime-dom\r\n    // which guarantees presence of hostInsertStaticContent.\r\n    ;[n2.el, n2.anchor] = hostInsertStaticContent!(\r\n      n2.children as string,\r\n      container,\r\n      anchor,\r\n      isSVG,\r\n      n2.el,\r\n      n2.anchor\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Dev / HMR only\r\n   */\r\n  const patchStaticNode = (\r\n    n1: VNode,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    isSVG: boolean\r\n  ) => {\r\n    // static nodes are only patched during dev for HMR\r\n    if (n2.children !== n1.children) {\r\n      const anchor = hostNextSibling(n1.anchor!)\r\n      // remove existing\r\n      removeStaticNode(n1)\r\n      // insert new\r\n      ;[n2.el, n2.anchor] = hostInsertStaticContent!(\r\n        n2.children as string,\r\n        container,\r\n        anchor,\r\n        isSVG\r\n      )\r\n    } else {\r\n      n2.el = n1.el\r\n      n2.anchor = n1.anchor\r\n    }\r\n  }\r\n\r\n  const moveStaticNode = (\r\n    { el, anchor }: VNode,\r\n    container: RendererElement,\r\n    nextSibling: RendererNode | null\r\n  ) => {\r\n    let next\r\n    while (el && el !== anchor) {\r\n      next = hostNextSibling(el)\r\n      hostInsert(el, container, nextSibling)\r\n      el = next\r\n    }\r\n    hostInsert(anchor!, container, nextSibling)\r\n  }\r\n\r\n  const removeStaticNode = ({ el, anchor }: VNode) => {\r\n    let next\r\n    while (el && el !== anchor) {\r\n      next = hostNextSibling(el)\r\n      hostRemove(el)\r\n      el = next\r\n    }\r\n    hostRemove(anchor!)\r\n  }\r\n\r\n  const processElement = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    isSVG = isSVG || n2.type === 'svg'\r\n    if (n1 == null) {\r\n      mountElement(\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    } else {\r\n      patchElement(\r\n        n1,\r\n        n2,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    }\r\n  }\r\n\r\n  const mountElement = (\r\n    vnode: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    let el: RendererElement\r\n    let vnodeHook: VNodeHook | undefined | null\r\n    const { type, props, shapeFlag, transition, dirs } = vnode\r\n\r\n    el = vnode.el = hostCreateElement(\r\n      vnode.type as string,\r\n      isSVG,\r\n      props && props.is,\r\n      props\r\n    )\r\n\r\n    // mount children first, since some props may rely on child content\r\n    // being already rendered, e.g. `<select value>`\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      hostSetElementText(el, vnode.children as string)\r\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      mountChildren(\r\n        vnode.children as VNodeArrayChildren,\r\n        el,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG && type !== 'foreignObject',\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    }\r\n\r\n    if (dirs) {\r\n      invokeDirectiveHook(vnode, null, parentComponent, 'created')\r\n    }\r\n    // scopeId\r\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent)\r\n    // props\r\n    if (props) {\r\n      for (const key in props) {\r\n        if (key !== 'value' && !isReservedProp(key)) {\r\n          hostPatchProp(\r\n            el,\r\n            key,\r\n            null,\r\n            props[key],\r\n            isSVG,\r\n            vnode.children as VNode[],\r\n            parentComponent,\r\n            parentSuspense,\r\n            unmountChildren\r\n          )\r\n        }\r\n      }\r\n      /**\r\n       * Special case for setting value on DOM elements:\r\n       * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\r\n       * - it needs to be forced (#1471)\r\n       * #2353 proposes adding another renderer option to configure this, but\r\n       * the properties affects are so finite it is worth special casing it\r\n       * here to reduce the complexity. (Special casing it also should not\r\n       * affect non-DOM renderers)\r\n       */\r\n      if ('value' in props) {\r\n        hostPatchProp(el, 'value', null, props.value)\r\n      }\r\n      if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n        invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      Object.defineProperty(el, '__vnode', {\r\n        value: vnode,\r\n        enumerable: false\r\n      })\r\n      Object.defineProperty(el, '__vueParentComponent', {\r\n        value: parentComponent,\r\n        enumerable: false\r\n      })\r\n    }\r\n    if (dirs) {\r\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')\r\n    }\r\n    // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n    // #1689 For inside suspense + suspense resolved case, just call it\r\n    const needCallTransitionHooks = needTransition(parentSuspense, transition)\r\n    if (needCallTransitionHooks) {\r\n      transition!.beforeEnter(el)\r\n    }\r\n    hostInsert(el, container, anchor)\r\n    if (\r\n      (vnodeHook = props && props.onVnodeMounted) ||\r\n      needCallTransitionHooks ||\r\n      dirs\r\n    ) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n        needCallTransitionHooks && transition!.enter(el)\r\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  const setScopeId = (\r\n    el: RendererElement,\r\n    vnode: VNode,\r\n    scopeId: string | null,\r\n    slotScopeIds: string[] | null,\r\n    parentComponent: ComponentInternalInstance | null\r\n  ) => {\r\n    if (scopeId) {\r\n      hostSetScopeId(el, scopeId)\r\n    }\r\n    if (slotScopeIds) {\r\n      for (let i = 0; i < slotScopeIds.length; i++) {\r\n        hostSetScopeId(el, slotScopeIds[i])\r\n      }\r\n    }\r\n    if (parentComponent) {\r\n      let subTree = parentComponent.subTree\r\n      if (\r\n        __DEV__ &&\r\n        subTree.patchFlag > 0 &&\r\n        subTree.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\r\n      ) {\r\n        subTree =\r\n          filterSingleRoot(subTree.children as VNodeArrayChildren) || subTree\r\n      }\r\n      if (vnode === subTree) {\r\n        const parentVNode = parentComponent.vnode\r\n        setScopeId(\r\n          el,\r\n          parentVNode,\r\n          parentVNode.scopeId,\r\n          parentVNode.slotScopeIds,\r\n          parentComponent.parent\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const mountChildren: MountChildrenFn = (\r\n    children,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    isSVG,\r\n    slotScopeIds,\r\n    optimized,\r\n    start = 0\r\n  ) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      const child = (children[i] = optimized\r\n        ? cloneIfMounted(children[i] as VNode)\r\n        : normalizeVNode(children[i]))\r\n      patch(\r\n        null,\r\n        child,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    }\r\n  }\r\n\r\n  const patchElement = (\r\n    n1: VNode,\r\n    n2: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    const el = (n2.el = n1.el!)\r\n    let { patchFlag, dynamicChildren, dirs } = n2\r\n    // #1426 take the old vnode's patch flag into account since user may clone a\r\n    // compiler-generated vnode, which de-opts to FULL_PROPS\r\n    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS\r\n    const oldProps = n1.props || EMPTY_OBJ\r\n    const newProps = n2.props || EMPTY_OBJ\r\n    let vnodeHook: VNodeHook | undefined | null\r\n\r\n    // disable recurse in beforeUpdate hooks\r\n    parentComponent && toggleRecurse(parentComponent, false)\r\n    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\r\n    }\r\n    if (dirs) {\r\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')\r\n    }\r\n    parentComponent && toggleRecurse(parentComponent, true)\r\n\r\n    if (__DEV__ && isHmrUpdating) {\r\n      // HMR updated, force full diff\r\n      patchFlag = 0\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    const areChildrenSVG = isSVG && n2.type !== 'foreignObject'\r\n    if (dynamicChildren) {\r\n      patchBlockChildren(\r\n        n1.dynamicChildren!,\r\n        dynamicChildren,\r\n        el,\r\n        parentComponent,\r\n        parentSuspense,\r\n        areChildrenSVG,\r\n        slotScopeIds\r\n      )\r\n      if (__DEV__) {\r\n        // necessary for HMR\r\n        traverseStaticChildren(n1, n2)\r\n      }\r\n    } else if (!optimized) {\r\n      // full diff\r\n      patchChildren(\r\n        n1,\r\n        n2,\r\n        el,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        areChildrenSVG,\r\n        slotScopeIds,\r\n        false\r\n      )\r\n    }\r\n\r\n    if (patchFlag > 0) {\r\n      // the presence of a patchFlag means this element's render code was\r\n      // generated by the compiler and can take the fast path.\r\n      // in this path old node and new node are guaranteed to have the same shape\r\n      // (i.e. at the exact same position in the source template)\r\n      if (patchFlag & PatchFlags.FULL_PROPS) {\r\n        // element props contain dynamic keys, full diff needed\r\n        patchProps(\r\n          el,\r\n          n2,\r\n          oldProps,\r\n          newProps,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG\r\n        )\r\n      } else {\r\n        // class\r\n        // this flag is matched when the element has dynamic class bindings.\r\n        if (patchFlag & PatchFlags.CLASS) {\r\n          if (oldProps.class !== newProps.class) {\r\n            hostPatchProp(el, 'class', null, newProps.class, isSVG)\r\n          }\r\n        }\r\n\r\n        // style\r\n        // this flag is matched when the element has dynamic style bindings\r\n        if (patchFlag & PatchFlags.STYLE) {\r\n          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG)\r\n        }\r\n\r\n        // props\r\n        // This flag is matched when the element has dynamic prop/attr bindings\r\n        // other than class and style. The keys of dynamic prop/attrs are saved for\r\n        // faster iteration.\r\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n        // bail out and go through a full diff because we need to unset the old key\r\n        if (patchFlag & PatchFlags.PROPS) {\r\n          // if the flag is present then dynamicProps must be non-null\r\n          const propsToUpdate = n2.dynamicProps!\r\n          for (let i = 0; i < propsToUpdate.length; i++) {\r\n            const key = propsToUpdate[i]\r\n            const prev = oldProps[key]\r\n            const next = newProps[key]\r\n            // #1471 force patch value\r\n            if (next !== prev || key === 'value') {\r\n              hostPatchProp(\r\n                el,\r\n                key,\r\n                prev,\r\n                next,\r\n                isSVG,\r\n                n1.children as VNode[],\r\n                parentComponent,\r\n                parentSuspense,\r\n                unmountChildren\r\n              )\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // text\r\n      // This flag is matched when the element has only dynamic text children.\r\n      if (patchFlag & PatchFlags.TEXT) {\r\n        if (n1.children !== n2.children) {\r\n          hostSetElementText(el, n2.children as string)\r\n        }\r\n      }\r\n    } else if (!optimized && dynamicChildren == null) {\r\n      // unoptimized, full diff\r\n      patchProps(\r\n        el,\r\n        n2,\r\n        oldProps,\r\n        newProps,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG\r\n      )\r\n    }\r\n\r\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\r\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  // The fast path for blocks.\r\n  const patchBlockChildren: PatchBlockChildrenFn = (\r\n    oldChildren,\r\n    newChildren,\r\n    fallbackContainer,\r\n    parentComponent,\r\n    parentSuspense,\r\n    isSVG,\r\n    slotScopeIds\r\n  ) => {\r\n    for (let i = 0; i < newChildren.length; i++) {\r\n      const oldVNode = oldChildren[i]\r\n      const newVNode = newChildren[i]\r\n      // Determine the container (parent element) for the patch.\r\n      const container =\r\n        // oldVNode may be an errored async setup() component inside Suspense\r\n        // which will not have a mounted element\r\n        oldVNode.el &&\r\n        // - In the case of a Fragment, we need to provide the actual parent\r\n        // of the Fragment itself so it can move its children.\r\n        (oldVNode.type === Fragment ||\r\n          // - In the case of different nodes, there is going to be a replacement\r\n          // which also requires the correct parent container\r\n          !isSameVNodeType(oldVNode, newVNode) ||\r\n          // - In the case of a component, it could contain anything.\r\n          oldVNode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.TELEPORT))\r\n          ? hostParentNode(oldVNode.el)!\r\n          : // In other cases, the parent container is not actually used so we\r\n            // just pass the block element here to avoid a DOM parentNode call.\r\n            fallbackContainer\r\n      patch(\r\n        oldVNode,\r\n        newVNode,\r\n        container,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        true\r\n      )\r\n    }\r\n  }\r\n\r\n  const patchProps = (\r\n    el: RendererElement,\r\n    vnode: VNode,\r\n    oldProps: Data,\r\n    newProps: Data,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean\r\n  ) => {\r\n    if (oldProps !== newProps) {\r\n      if (oldProps !== EMPTY_OBJ) {\r\n        for (const key in oldProps) {\r\n          if (!isReservedProp(key) && !(key in newProps)) {\r\n            hostPatchProp(\r\n              el,\r\n              key,\r\n              oldProps[key],\r\n              null,\r\n              isSVG,\r\n              vnode.children as VNode[],\r\n              parentComponent,\r\n              parentSuspense,\r\n              unmountChildren\r\n            )\r\n          }\r\n        }\r\n      }\r\n      for (const key in newProps) {\r\n        // empty string is not valid prop\r\n        if (isReservedProp(key)) continue\r\n        const next = newProps[key]\r\n        const prev = oldProps[key]\r\n        // defer patching value\r\n        if (next !== prev && key !== 'value') {\r\n          hostPatchProp(\r\n            el,\r\n            key,\r\n            prev,\r\n            next,\r\n            isSVG,\r\n            vnode.children as VNode[],\r\n            parentComponent,\r\n            parentSuspense,\r\n            unmountChildren\r\n          )\r\n        }\r\n      }\r\n      if ('value' in newProps) {\r\n        hostPatchProp(el, 'value', oldProps.value, newProps.value)\r\n      }\r\n    }\r\n  }\r\n\r\n  const processFragment = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!\r\n    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!\r\n\r\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2\r\n\r\n    if (\r\n      __DEV__ &&\r\n      // #5523 dev root fragment may inherit directives\r\n      (isHmrUpdating || patchFlag & PatchFlags.DEV_ROOT_FRAGMENT)\r\n    ) {\r\n      // HMR updated / Dev root fragment (w/ comments), force full diff\r\n      patchFlag = 0\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    // check if this is a slot fragment with :slotted scope ids\r\n    if (fragmentSlotScopeIds) {\r\n      slotScopeIds = slotScopeIds\r\n        ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n        : fragmentSlotScopeIds\r\n    }\r\n\r\n    if (n1 == null) {\r\n      hostInsert(fragmentStartAnchor, container, anchor)\r\n      hostInsert(fragmentEndAnchor, container, anchor)\r\n      // a fragment can only have array children\r\n      // since they are either generated by the compiler, or implicitly created\r\n      // from arrays.\r\n      mountChildren(\r\n        n2.children as VNodeArrayChildren,\r\n        container,\r\n        fragmentEndAnchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    } else {\r\n      if (\r\n        patchFlag > 0 &&\r\n        patchFlag & PatchFlags.STABLE_FRAGMENT &&\r\n        dynamicChildren &&\r\n        // #2715 the previous fragment could've been a BAILed one as a result\r\n        // of renderSlot() with no valid children\r\n        n1.dynamicChildren\r\n      ) {\r\n        // a stable fragment (template root or <template v-for>) doesn't need to\r\n        // patch children order, but it may contain dynamicChildren.\r\n        patchBlockChildren(\r\n          n1.dynamicChildren,\r\n          dynamicChildren,\r\n          container,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds\r\n        )\r\n        if (__DEV__) {\r\n          // necessary for HMR\r\n          traverseStaticChildren(n1, n2)\r\n        } else if (\r\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n          //  get moved around. Make sure all root level vnodes inherit el.\r\n          // #2134 or if it's a component root, it may also get moved around\r\n          // as the component is being moved.\r\n          n2.key != null ||\r\n          (parentComponent && n2 === parentComponent.subTree)\r\n        ) {\r\n          traverseStaticChildren(n1, n2, true /* shallow */)\r\n        }\r\n      } else {\r\n        // keyed / unkeyed, or manual fragments.\r\n        // for keyed & unkeyed, since they are compiler generated from v-for,\r\n        // each child is guaranteed to be a block so the fragment will never\r\n        // have dynamicChildren.\r\n        patchChildren(\r\n          n1,\r\n          n2,\r\n          container,\r\n          fragmentEndAnchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const processComponent = (\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    n2.slotScopeIds = slotScopeIds\r\n    if (n1 == null) {\r\n      if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\r\n        ;(parentComponent!.ctx as KeepAliveContext).activate(\r\n          n2,\r\n          container,\r\n          anchor,\r\n          isSVG,\r\n          optimized\r\n        )\r\n      } else {\r\n        mountComponent(\r\n          n2,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          optimized\r\n        )\r\n      }\r\n    } else {\r\n      updateComponent(n1, n2, optimized)\r\n    }\r\n  }\r\n\r\n  const mountComponent: MountComponentFn = (\r\n    initialVNode,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    isSVG,\r\n    optimized\r\n  ) => {\r\n    // 2.x compat may pre-create the component instance before actually\r\n    // mounting\r\n    const compatMountInstance =\r\n      __COMPAT__ && initialVNode.isCompatRoot && initialVNode.component\r\n    const instance: ComponentInternalInstance =\r\n      compatMountInstance ||\r\n      (initialVNode.component = createComponentInstance(\r\n        initialVNode,\r\n        parentComponent,\r\n        parentSuspense\r\n      ))\r\n\r\n    if (__DEV__ && instance.type.__hmrId) {\r\n      registerHMR(instance)\r\n    }\r\n\r\n    if (__DEV__) {\r\n      pushWarningContext(initialVNode)\r\n      startMeasure(instance, `mount`)\r\n    }\r\n\r\n    // inject renderer internals for keepAlive\r\n    if (isKeepAlive(initialVNode)) {\r\n      ;(instance.ctx as KeepAliveContext).renderer = internals\r\n    }\r\n\r\n    // resolve props and slots for setup context\r\n    if (!(__COMPAT__ && compatMountInstance)) {\r\n      if (__DEV__) {\r\n        startMeasure(instance, `init`)\r\n      }\r\n      setupComponent(instance)\r\n      if (__DEV__) {\r\n        endMeasure(instance, `init`)\r\n      }\r\n    }\r\n\r\n    // setup() is async. This component relies on async logic to be resolved\r\n    // before proceeding\r\n    if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\r\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect)\r\n\r\n      // Give it a placeholder if this is not hydration\r\n      // TODO handle self-defined fallback\r\n      if (!initialVNode.el) {\r\n        const placeholder = (instance.subTree = createVNode(Comment))\r\n        processCommentNode(null, placeholder, container!, anchor)\r\n      }\r\n      return\r\n    }\r\n\r\n    setupRenderEffect(\r\n      instance,\r\n      initialVNode,\r\n      container,\r\n      anchor,\r\n      parentSuspense,\r\n      isSVG,\r\n      optimized\r\n    )\r\n\r\n    if (__DEV__) {\r\n      popWarningContext()\r\n      endMeasure(instance, `mount`)\r\n    }\r\n  }\r\n\r\n  const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {\r\n    const instance = (n2.component = n1.component)!\r\n    if (shouldUpdateComponent(n1, n2, optimized)) {\r\n      if (\r\n        __FEATURE_SUSPENSE__ &&\r\n        instance.asyncDep &&\r\n        !instance.asyncResolved\r\n      ) {\r\n        // async & still pending - just update props and slots\r\n        // since the component's reactive effect for render isn't set-up yet\r\n        if (__DEV__) {\r\n          pushWarningContext(n2)\r\n        }\r\n        updateComponentPreRender(instance, n2, optimized)\r\n        if (__DEV__) {\r\n          popWarningContext()\r\n        }\r\n        return\r\n      } else {\r\n        // normal update\r\n        instance.next = n2\r\n        // in case the child component is also queued, remove it to avoid\r\n        // double updating the same child component in the same flush.\r\n        invalidateJob(instance.update)\r\n        // instance.update is the reactive effect.\r\n        instance.update()\r\n      }\r\n    } else {\r\n      // no update needed. just copy over properties\r\n      n2.el = n1.el\r\n      instance.vnode = n2\r\n    }\r\n  }\r\n\r\n  const setupRenderEffect: SetupRenderEffectFn = (\r\n    instance,\r\n    initialVNode,\r\n    container,\r\n    anchor,\r\n    parentSuspense,\r\n    isSVG,\r\n    optimized\r\n  ) => {\r\n    const componentUpdateFn = () => {\r\n      if (!instance.isMounted) {\r\n        let vnodeHook: VNodeHook | null | undefined\r\n        const { el, props } = initialVNode\r\n        const { bm, m, parent } = instance\r\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode)\r\n\r\n        toggleRecurse(instance, false)\r\n        // beforeMount hook\r\n        if (bm) {\r\n          invokeArrayFns(bm)\r\n        }\r\n        // onVnodeBeforeMount\r\n        if (\r\n          !isAsyncWrapperVNode &&\r\n          (vnodeHook = props && props.onVnodeBeforeMount)\r\n        ) {\r\n          invokeVNodeHook(vnodeHook, parent, initialVNode)\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          instance.emit('hook:beforeMount')\r\n        }\r\n        toggleRecurse(instance, true)\r\n\r\n        if (el && hydrateNode) {\r\n          // vnode has adopted host node - perform hydration instead of mount.\r\n          const hydrateSubTree = () => {\r\n            if (__DEV__) {\r\n              startMeasure(instance, `render`)\r\n            }\r\n            instance.subTree = renderComponentRoot(instance)\r\n            if (__DEV__) {\r\n              endMeasure(instance, `render`)\r\n            }\r\n            if (__DEV__) {\r\n              startMeasure(instance, `hydrate`)\r\n            }\r\n            hydrateNode!(\r\n              el as Node,\r\n              instance.subTree,\r\n              instance,\r\n              parentSuspense,\r\n              null\r\n            )\r\n            if (__DEV__) {\r\n              endMeasure(instance, `hydrate`)\r\n            }\r\n          }\r\n\r\n          if (isAsyncWrapperVNode) {\r\n            ;(initialVNode.type as ComponentOptions).__asyncLoader!().then(\r\n              // note: we are moving the render call into an async callback,\r\n              // which means it won't track dependencies - but it's ok because\r\n              // a server-rendered async wrapper is already in resolved state\r\n              // and it will never need to change.\r\n              () => !instance.isUnmounted && hydrateSubTree()\r\n            )\r\n          } else {\r\n            hydrateSubTree()\r\n          }\r\n        } else {\r\n          if (__DEV__) {\r\n            startMeasure(instance, `render`)\r\n          }\r\n          const subTree = (instance.subTree = renderComponentRoot(instance))\r\n          if (__DEV__) {\r\n            endMeasure(instance, `render`)\r\n          }\r\n          if (__DEV__) {\r\n            startMeasure(instance, `patch`)\r\n          }\r\n          patch(\r\n            null,\r\n            subTree,\r\n            container,\r\n            anchor,\r\n            instance,\r\n            parentSuspense,\r\n            isSVG\r\n          )\r\n          if (__DEV__) {\r\n            endMeasure(instance, `patch`)\r\n          }\r\n          initialVNode.el = subTree.el\r\n        }\r\n        // mounted hook\r\n        if (m) {\r\n          queuePostRenderEffect(m, parentSuspense)\r\n        }\r\n        // onVnodeMounted\r\n        if (\r\n          !isAsyncWrapperVNode &&\r\n          (vnodeHook = props && props.onVnodeMounted)\r\n        ) {\r\n          const scopedInitialVNode = initialVNode\r\n          queuePostRenderEffect(\r\n            () => invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode),\r\n            parentSuspense\r\n          )\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          queuePostRenderEffect(\r\n            () => instance.emit('hook:mounted'),\r\n            parentSuspense\r\n          )\r\n        }\r\n\r\n        // activated hook for keep-alive roots.\r\n        // #1742 activated hook must be accessed after first render\r\n        // since the hook may be injected by a child keep-alive\r\n        if (\r\n          initialVNode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE ||\r\n          (parent &&\r\n            isAsyncWrapper(parent.vnode) &&\r\n            parent.vnode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE)\r\n        ) {\r\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense)\r\n          if (\r\n            __COMPAT__ &&\r\n            isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n          ) {\r\n            queuePostRenderEffect(\r\n              () => instance.emit('hook:activated'),\r\n              parentSuspense\r\n            )\r\n          }\r\n        }\r\n        instance.isMounted = true\r\n\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n          devtoolsComponentAdded(instance)\r\n        }\r\n\r\n        // #2458: deference mount-only object parameters to prevent memleaks\r\n        initialVNode = container = anchor = null as any\r\n      } else {\r\n        // updateComponent\r\n        // This is triggered by mutation of component's own state (next: null)\r\n        // OR parent calling processComponent (next: VNode)\r\n        let { next, bu, u, parent, vnode } = instance\r\n        let originNext = next\r\n        let vnodeHook: VNodeHook | null | undefined\r\n        if (__DEV__) {\r\n          pushWarningContext(next || instance.vnode)\r\n        }\r\n\r\n        // Disallow component effect recursion during pre-lifecycle hooks.\r\n        toggleRecurse(instance, false)\r\n        if (next) {\r\n          next.el = vnode.el\r\n          updateComponentPreRender(instance, next, optimized)\r\n        } else {\r\n          next = vnode\r\n        }\r\n\r\n        // beforeUpdate hook\r\n        if (bu) {\r\n          invokeArrayFns(bu)\r\n        }\r\n        // onVnodeBeforeUpdate\r\n        if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n          invokeVNodeHook(vnodeHook, parent, next, vnode)\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          instance.emit('hook:beforeUpdate')\r\n        }\r\n        toggleRecurse(instance, true)\r\n\r\n        // render\r\n        if (__DEV__) {\r\n          startMeasure(instance, `render`)\r\n        }\r\n        const nextTree = renderComponentRoot(instance)\r\n        if (__DEV__) {\r\n          endMeasure(instance, `render`)\r\n        }\r\n        const prevTree = instance.subTree\r\n        instance.subTree = nextTree\r\n\r\n        if (__DEV__) {\r\n          startMeasure(instance, `patch`)\r\n        }\r\n        patch(\r\n          prevTree,\r\n          nextTree,\r\n          // parent may have changed if it's in a teleport\r\n          hostParentNode(prevTree.el!)!,\r\n          // anchor may have changed if it's in a fragment\r\n          getNextHostNode(prevTree),\r\n          instance,\r\n          parentSuspense,\r\n          isSVG\r\n        )\r\n        if (__DEV__) {\r\n          endMeasure(instance, `patch`)\r\n        }\r\n        next.el = nextTree.el\r\n        if (originNext === null) {\r\n          // self-triggered update. In case of HOC, update parent component\r\n          // vnode el. HOC is indicated by parent instance's subTree pointing\r\n          // to child component's vnode\r\n          updateHOCHostEl(instance, nextTree.el)\r\n        }\r\n        // updated hook\r\n        if (u) {\r\n          queuePostRenderEffect(u, parentSuspense)\r\n        }\r\n        // onVnodeUpdated\r\n        if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n          queuePostRenderEffect(\r\n            () => invokeVNodeHook(vnodeHook!, parent, next!, vnode),\r\n            parentSuspense\r\n          )\r\n        }\r\n        if (\r\n          __COMPAT__ &&\r\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n        ) {\r\n          queuePostRenderEffect(\r\n            () => instance.emit('hook:updated'),\r\n            parentSuspense\r\n          )\r\n        }\r\n\r\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n          devtoolsComponentUpdated(instance)\r\n        }\r\n\r\n        if (__DEV__) {\r\n          popWarningContext()\r\n        }\r\n      }\r\n    }\r\n\r\n    // create reactive effect for rendering\r\n    const effect = (instance.effect = new ReactiveEffect(\r\n      componentUpdateFn,\r\n      () => queueJob(update),\r\n      instance.scope // track it in component's effect scope\r\n    ))\r\n\r\n    const update: SchedulerJob = (instance.update = () => effect.run())\r\n    update.id = instance.uid\r\n    // allowRecurse\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    toggleRecurse(instance, true)\r\n\r\n    if (__DEV__) {\r\n      effect.onTrack = instance.rtc\r\n        ? e => invokeArrayFns(instance.rtc!, e)\r\n        : void 0\r\n      effect.onTrigger = instance.rtg\r\n        ? e => invokeArrayFns(instance.rtg!, e)\r\n        : void 0\r\n      update.ownerInstance = instance\r\n    }\r\n\r\n    update()\r\n  }\r\n\r\n  const updateComponentPreRender = (\r\n    instance: ComponentInternalInstance,\r\n    nextVNode: VNode,\r\n    optimized: boolean\r\n  ) => {\r\n    nextVNode.component = instance\r\n    const prevProps = instance.vnode.props\r\n    instance.vnode = nextVNode\r\n    instance.next = null\r\n    updateProps(instance, nextVNode.props, prevProps, optimized)\r\n    updateSlots(instance, nextVNode.children, optimized)\r\n\r\n    pauseTracking()\r\n    // props update may have triggered pre-flush watchers.\r\n    // flush them before the render update.\r\n    flushPreFlushCbs(instance)\r\n    resetTracking()\r\n  }\r\n\r\n  const patchChildren: PatchChildrenFn = (\r\n    n1,\r\n    n2,\r\n    container,\r\n    anchor,\r\n    parentComponent,\r\n    parentSuspense,\r\n    isSVG,\r\n    slotScopeIds,\r\n    optimized = false\r\n  ) => {\r\n    const c1 = n1 && n1.children\r\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\r\n    const c2 = n2.children\r\n\r\n    const { patchFlag, shapeFlag } = n2\r\n    // fast path\r\n    if (patchFlag > 0) {\r\n      if (patchFlag & PatchFlags.KEYED_FRAGMENT) { // \u63D0\u4F9Bkey\u5C5E\u6027\r\n      // this could be either fully-keyed or mixed (some keyed some not)\r\n        // presence of patchFlag means children are guaranteed to be arrays\r\n        patchKeyedChildren(\r\n          c1 as VNode[],\r\n          c2 as VNodeArrayChildren,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        return\r\n      } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) { // \u4E0D\u5B58\u5728key\u5C5E\u6027\r\n        // unkeyed\r\n        patchUnkeyedChildren(\r\n          c1 as VNode[],\r\n          c2 as VNodeArrayChildren,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        return\r\n      }\r\n    }\r\n\r\n    // children has 3 possibilities: text, array or no children.\r\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n      // text children fast path\r\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\r\n      }\r\n      if (c2 !== c1) {\r\n        hostSetElementText(container, c2 as string)\r\n      }\r\n    } else {\r\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n        // prev children was array\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          // two arrays, cannot assume anything, do full diff\r\n          patchKeyedChildren(\r\n            c1 as VNode[],\r\n            c2 as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        } else {\r\n          // no new children, just unmount old\r\n          unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\r\n        }\r\n      } else {\r\n        // prev children was text OR null\r\n        // new children is array OR null\r\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n          hostSetElementText(container, '')\r\n        }\r\n        // mount new if array\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          mountChildren(\r\n            c2 as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const patchUnkeyedChildren = (\r\n    c1: VNode[],\r\n    c2: VNodeArrayChildren,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    c1 = c1 || EMPTY_ARR\r\n    c2 = c2 || EMPTY_ARR\r\n    const oldLength = c1.length\r\n    const newLength = c2.length\r\n    const commonLength = Math.min(oldLength, newLength)\r\n    let i\r\n    for (i = 0; i < commonLength; i++) {\r\n      const nextChild = (c2[i] = optimized\r\n        ? cloneIfMounted(c2[i] as VNode)\r\n        : normalizeVNode(c2[i]))\r\n      patch(\r\n        c1[i],\r\n        nextChild,\r\n        container,\r\n        null,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n    }\r\n    if (oldLength > newLength) {\r\n      // remove old\r\n      unmountChildren(\r\n        c1,\r\n        parentComponent,\r\n        parentSuspense,\r\n        true,\r\n        false,\r\n        commonLength\r\n      )\r\n    } else {\r\n      // mount new\r\n      mountChildren(\r\n        c2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized,\r\n        commonLength\r\n      )\r\n    }\r\n  }\r\n\r\n  // can be all-keyed or mixed\r\n  const patchKeyedChildren = (\r\n    c1: VNode[],\r\n    c2: VNodeArrayChildren,\r\n    container: RendererElement,\r\n    parentAnchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => {\r\n    let i = 0\r\n    const l2 = c2.length\r\n    let e1 = c1.length - 1 // prev ending index\r\n    let e2 = l2 - 1 // next ending index\r\n\r\n    // 1. sync from start\r\n    // (a b) c\r\n    // (a b) d e\r\n    while (i <= e1 && i <= e2) {\r\n      const n1 = c1[i]\r\n      const n2 = (c2[i] = optimized\r\n        ? cloneIfMounted(c2[i] as VNode)\r\n        : normalizeVNode(c2[i]))\r\n      if (isSameVNodeType(n1, n2)) {\r\n        patch(\r\n          n1,\r\n          n2,\r\n          container,\r\n          null,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n      } else {\r\n        break\r\n      }\r\n      i++\r\n    }\r\n\r\n    // 2. sync from end\r\n    // a (b c)\r\n    // d e (b c)\r\n    while (i <= e1 && i <= e2) {\r\n      const n1 = c1[e1]\r\n      const n2 = (c2[e2] = optimized\r\n        ? cloneIfMounted(c2[e2] as VNode)\r\n        : normalizeVNode(c2[e2]))\r\n      if (isSameVNodeType(n1, n2)) {\r\n        patch(\r\n          n1,\r\n          n2,\r\n          container,\r\n          null,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n      } else {\r\n        break\r\n      }\r\n      e1--\r\n      e2--\r\n    }\r\n\r\n    // 3. common sequence + mount\r\n    // (a b)\r\n    // (a b) c\r\n    // i = 2, e1 = 1, e2 = 2\r\n    // (a b)\r\n    // c (a b)\r\n    // i = 0, e1 = -1, e2 = 0\r\n    if (i > e1) {\r\n      if (i <= e2) {\r\n        const nextPos = e2 + 1\r\n        const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor\r\n        while (i <= e2) {\r\n          patch(\r\n            null,\r\n            (c2[i] = optimized\r\n              ? cloneIfMounted(c2[i] as VNode)\r\n              : normalizeVNode(c2[i])),\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n          i++\r\n        }\r\n      }\r\n    }\r\n\r\n    // 4. common sequence + unmount\r\n    // (a b) c\r\n    // (a b)\r\n    // i = 2, e1 = 2, e2 = 1\r\n    // a (b c)\r\n    // (b c)\r\n    // i = 0, e1 = 0, e2 = -1\r\n    else if (i > e2) {\r\n      while (i <= e1) {\r\n        unmount(c1[i], parentComponent, parentSuspense, true)\r\n        i++\r\n      }\r\n    }\r\n\r\n    // 5. unknown sequence\r\n    // [i ... e1 + 1]: a b [c d e] f g\r\n    // [i ... e2 + 1]: a b [e d c h] f g\r\n    // i = 2, e1 = 4, e2 = 5\r\n    else {\r\n      const s1 = i // prev starting index\r\n      const s2 = i // next starting index\r\n\r\n      // 5.1 build key:index map for newChildren\r\n      const keyToNewIndexMap: Map<string | number | symbol, number> = new Map()\r\n      for (i = s2; i <= e2; i++) {\r\n        const nextChild = (c2[i] = optimized\r\n          ? cloneIfMounted(c2[i] as VNode)\r\n          : normalizeVNode(c2[i]))\r\n        if (nextChild.key != null) {\r\n          if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\r\n            warn(\r\n              `Duplicate keys found during update:`,\r\n              JSON.stringify(nextChild.key),\r\n              `Make sure keys are unique.`\r\n            )\r\n          }\r\n          keyToNewIndexMap.set(nextChild.key, i)\r\n        }\r\n      }\r\n\r\n      // 5.2 loop through old children left to be patched and try to patch\r\n      // matching nodes & remove nodes that are no longer present\r\n      let j\r\n      let patched = 0\r\n      const toBePatched = e2 - s2 + 1\r\n      let moved = false\r\n      // used to track whether any node has moved\r\n      let maxNewIndexSoFar = 0\r\n      // works as Map<newIndex, oldIndex>\r\n      // Note that oldIndex is offset by +1\r\n      // and oldIndex = 0 is a special value indicating the new node has\r\n      // no corresponding old node.\r\n      // used for determining longest stable subsequence\r\n      const newIndexToOldIndexMap = new Array(toBePatched)\r\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\r\n\r\n      for (i = s1; i <= e1; i++) {\r\n        const prevChild = c1[i]\r\n        if (patched >= toBePatched) {\r\n          // all new children have been patched so this can only be a removal\r\n          unmount(prevChild, parentComponent, parentSuspense, true)\r\n          continue\r\n        }\r\n        let newIndex\r\n        if (prevChild.key != null) {\r\n          newIndex = keyToNewIndexMap.get(prevChild.key)\r\n        } else {\r\n          // key-less node, try to locate a key-less node of the same type\r\n          for (j = s2; j <= e2; j++) {\r\n            if (\r\n              newIndexToOldIndexMap[j - s2] === 0 &&\r\n              isSameVNodeType(prevChild, c2[j] as VNode)\r\n            ) {\r\n              newIndex = j\r\n              break\r\n            }\r\n          }\r\n        }\r\n        if (newIndex === undefined) {\r\n          unmount(prevChild, parentComponent, parentSuspense, true)\r\n        } else {\r\n          newIndexToOldIndexMap[newIndex - s2] = i + 1\r\n          if (newIndex >= maxNewIndexSoFar) {\r\n            maxNewIndexSoFar = newIndex\r\n          } else {\r\n            moved = true\r\n          }\r\n          patch(\r\n            prevChild,\r\n            c2[newIndex] as VNode,\r\n            container,\r\n            null,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n          patched++\r\n        }\r\n      }\r\n\r\n      // 5.3 move and mount\r\n      // generate longest stable subsequence only when nodes have moved\r\n      const increasingNewIndexSequence = moved\r\n        ? getSequence(newIndexToOldIndexMap)\r\n        : EMPTY_ARR\r\n      j = increasingNewIndexSequence.length - 1\r\n      // looping backwards so that we can use last patched node as anchor\r\n      for (i = toBePatched - 1; i >= 0; i--) {\r\n        const nextIndex = s2 + i\r\n        const nextChild = c2[nextIndex] as VNode\r\n        const anchor =\r\n          nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\r\n        if (newIndexToOldIndexMap[i] === 0) {\r\n          // mount new\r\n          patch(\r\n            null,\r\n            nextChild,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        } else if (moved) {\r\n          // move if:\r\n          // There is no stable subsequence (e.g. a reverse)\r\n          // OR current node is not among the stable sequence\r\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n            move(nextChild, container, anchor, MoveType.REORDER)\r\n          } else {\r\n            j--\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const move: MoveFn = (\r\n    vnode,\r\n    container,\r\n    anchor,\r\n    moveType,\r\n    parentSuspense = null\r\n  ) => {\r\n    const { el, type, transition, children, shapeFlag } = vnode\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n      move(vnode.component!.subTree, container, anchor, moveType)\r\n      return\r\n    }\r\n\r\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n      vnode.suspense!.move(container, anchor, moveType)\r\n      return\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.TELEPORT) {\r\n      ;(type as typeof TeleportImpl).move(vnode, container, anchor, internals)\r\n      return\r\n    }\r\n\r\n    if (type === Fragment) {\r\n      hostInsert(el!, container, anchor)\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        move((children as VNode[])[i], container, anchor, moveType)\r\n      }\r\n      hostInsert(vnode.anchor!, container, anchor)\r\n      return\r\n    }\r\n\r\n    if (type === Static) {\r\n      moveStaticNode(vnode, container, anchor)\r\n      return\r\n    }\r\n\r\n    // single nodes\r\n    const needTransition =\r\n      moveType !== MoveType.REORDER &&\r\n      shapeFlag & ShapeFlags.ELEMENT &&\r\n      transition\r\n    if (needTransition) {\r\n      if (moveType === MoveType.ENTER) {\r\n        transition!.beforeEnter(el!)\r\n        hostInsert(el!, container, anchor)\r\n        queuePostRenderEffect(() => transition!.enter(el!), parentSuspense)\r\n      } else {\r\n        const { leave, delayLeave, afterLeave } = transition!\r\n        const remove = () => hostInsert(el!, container, anchor)\r\n        const performLeave = () => {\r\n          leave(el!, () => {\r\n            remove()\r\n            afterLeave && afterLeave()\r\n          })\r\n        }\r\n        if (delayLeave) {\r\n          delayLeave(el!, remove, performLeave)\r\n        } else {\r\n          performLeave()\r\n        }\r\n      }\r\n    } else {\r\n      hostInsert(el!, container, anchor)\r\n    }\r\n  }\r\n\r\n  const unmount: UnmountFn = (\r\n    vnode,\r\n    parentComponent,\r\n    parentSuspense,\r\n    doRemove = false,\r\n    optimized = false\r\n  ) => {\r\n    const {\r\n      type,\r\n      props,\r\n      ref,\r\n      children,\r\n      dynamicChildren,\r\n      shapeFlag,\r\n      patchFlag,\r\n      dirs\r\n    } = vnode\r\n    // unset ref\r\n    if (ref != null) {\r\n      setRef(ref, null, parentSuspense, vnode, true)\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\r\n      ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)\r\n      return\r\n    }\r\n\r\n    const shouldInvokeDirs = shapeFlag & ShapeFlags.ELEMENT && dirs\r\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode)\r\n\r\n    let vnodeHook: VNodeHook | undefined | null\r\n    if (\r\n      shouldInvokeVnodeHook &&\r\n      (vnodeHook = props && props.onVnodeBeforeUnmount)\r\n    ) {\r\n      invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n    }\r\n\r\n    if (shapeFlag & ShapeFlags.COMPONENT) {\r\n      unmountComponent(vnode.component!, parentSuspense, doRemove)\r\n    } else {\r\n      if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n        vnode.suspense!.unmount(parentSuspense, doRemove)\r\n        return\r\n      }\r\n\r\n      if (shouldInvokeDirs) {\r\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount')\r\n      }\r\n\r\n      if (shapeFlag & ShapeFlags.TELEPORT) {\r\n        ;(vnode.type as typeof TeleportImpl).remove(\r\n          vnode,\r\n          parentComponent,\r\n          parentSuspense,\r\n          optimized,\r\n          internals,\r\n          doRemove\r\n        )\r\n      } else if (\r\n        dynamicChildren &&\r\n        // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n        (type !== Fragment ||\r\n          (patchFlag > 0 && patchFlag & PatchFlags.STABLE_FRAGMENT))\r\n      ) {\r\n        // fast path for block nodes: only need to unmount dynamic children.\r\n        unmountChildren(\r\n          dynamicChildren,\r\n          parentComponent,\r\n          parentSuspense,\r\n          false,\r\n          true\r\n        )\r\n      } else if (\r\n        (type === Fragment &&\r\n          patchFlag &\r\n            (PatchFlags.KEYED_FRAGMENT | PatchFlags.UNKEYED_FRAGMENT)) ||\r\n        (!optimized && shapeFlag & ShapeFlags.ARRAY_CHILDREN)\r\n      ) {\r\n        unmountChildren(children as VNode[], parentComponent, parentSuspense)\r\n      }\r\n\r\n      if (doRemove) {\r\n        remove(vnode)\r\n      }\r\n    }\r\n\r\n    if (\r\n      (shouldInvokeVnodeHook &&\r\n        (vnodeHook = props && props.onVnodeUnmounted)) ||\r\n      shouldInvokeDirs\r\n    ) {\r\n      queuePostRenderEffect(() => {\r\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\r\n        shouldInvokeDirs &&\r\n          invokeDirectiveHook(vnode, null, parentComponent, 'unmounted')\r\n      }, parentSuspense)\r\n    }\r\n  }\r\n\r\n  const remove: RemoveFn = vnode => {\r\n    const { type, el, anchor, transition } = vnode\r\n    if (type === Fragment) {\r\n      if (\r\n        __DEV__ &&\r\n        vnode.patchFlag > 0 &&\r\n        vnode.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT &&\r\n        transition &&\r\n        !transition.persisted\r\n      ) {\r\n        ;(vnode.children as VNode[]).forEach(child => {\r\n          if (child.type === Comment) {\r\n            hostRemove(child.el!)\r\n          } else {\r\n            remove(child)\r\n          }\r\n        })\r\n      } else {\r\n        removeFragment(el!, anchor!)\r\n      }\r\n      return\r\n    }\r\n\r\n    if (type === Static) {\r\n      removeStaticNode(vnode)\r\n      return\r\n    }\r\n\r\n    const performRemove = () => {\r\n      hostRemove(el!)\r\n      if (transition && !transition.persisted && transition.afterLeave) {\r\n        transition.afterLeave()\r\n      }\r\n    }\r\n\r\n    if (\r\n      vnode.shapeFlag & ShapeFlags.ELEMENT &&\r\n      transition &&\r\n      !transition.persisted\r\n    ) {\r\n      const { leave, delayLeave } = transition\r\n      const performLeave = () => leave(el!, performRemove)\r\n      if (delayLeave) {\r\n        delayLeave(vnode.el!, performRemove, performLeave)\r\n      } else {\r\n        performLeave()\r\n      }\r\n    } else {\r\n      performRemove()\r\n    }\r\n  }\r\n\r\n  const removeFragment = (cur: RendererNode, end: RendererNode) => {\r\n    // For fragments, directly remove all contained DOM nodes.\r\n    // (fragment child nodes cannot have transition)\r\n    let next\r\n    while (cur !== end) {\r\n      next = hostNextSibling(cur)!\r\n      hostRemove(cur)\r\n      cur = next\r\n    }\r\n    hostRemove(end)\r\n  }\r\n\r\n  const unmountComponent = (\r\n    instance: ComponentInternalInstance,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    doRemove?: boolean\r\n  ) => {\r\n    if (__DEV__ && instance.type.__hmrId) {\r\n      unregisterHMR(instance)\r\n    }\r\n\r\n    const { bum, scope, update, subTree, um } = instance\r\n\r\n    // beforeUnmount hook\r\n    if (bum) {\r\n      invokeArrayFns(bum)\r\n    }\r\n\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n    ) {\r\n      instance.emit('hook:beforeDestroy')\r\n    }\r\n\r\n    // stop effects in component scope\r\n    scope.stop()\r\n\r\n    // update may be null if a component is unmounted before its async\r\n    // setup has resolved.\r\n    if (update) {\r\n      // so that scheduler will no longer invoke it\r\n      update.active = false\r\n      unmount(subTree, instance, parentSuspense, doRemove)\r\n    }\r\n    // unmounted hook\r\n    if (um) {\r\n      queuePostRenderEffect(um, parentSuspense)\r\n    }\r\n    if (\r\n      __COMPAT__ &&\r\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\r\n    ) {\r\n      queuePostRenderEffect(\r\n        () => instance.emit('hook:destroyed'),\r\n        parentSuspense\r\n      )\r\n    }\r\n    queuePostRenderEffect(() => {\r\n      instance.isUnmounted = true\r\n    }, parentSuspense)\r\n\r\n    // A component with async dep inside a pending suspense is unmounted before\r\n    // its async dep resolves. This should remove the dep from the suspense, and\r\n    // cause the suspense to resolve immediately if that was the last dep.\r\n    if (\r\n      __FEATURE_SUSPENSE__ &&\r\n      parentSuspense &&\r\n      parentSuspense.pendingBranch &&\r\n      !parentSuspense.isUnmounted &&\r\n      instance.asyncDep &&\r\n      !instance.asyncResolved &&\r\n      instance.suspenseId === parentSuspense.pendingId\r\n    ) {\r\n      parentSuspense.deps--\r\n      if (parentSuspense.deps === 0) {\r\n        parentSuspense.resolve()\r\n      }\r\n    }\r\n\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      devtoolsComponentRemoved(instance)\r\n    }\r\n  }\r\n\r\n  const unmountChildren: UnmountChildrenFn = (\r\n    children,\r\n    parentComponent,\r\n    parentSuspense,\r\n    doRemove = false,\r\n    optimized = false,\r\n    start = 0\r\n  ) => {\r\n    for (let i = start; i < children.length; i++) {\r\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized)\r\n    }\r\n  }\r\n\r\n  const getNextHostNode: NextFn = vnode => {\r\n    if (vnode.shapeFlag & ShapeFlags.COMPONENT) {\r\n      return getNextHostNode(vnode.component!.subTree)\r\n    }\r\n    if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n      return vnode.suspense!.next()\r\n    }\r\n    return hostNextSibling((vnode.anchor || vnode.el)!)\r\n  }\r\n\r\n  const render: RootRenderFunction = (vnode, container, isSVG) => {\r\n    if (vnode == null) {\r\n      if (container._vnode) {\r\n        unmount(container._vnode, null, null, true)\r\n      }\r\n    } else {\r\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG)\r\n    }\r\n    flushPreFlushCbs()\r\n    flushPostFlushCbs()\r\n    container._vnode = vnode\r\n  }\r\n\r\n  const internals: RendererInternals = {\r\n    p: patch,\r\n    um: unmount,\r\n    m: move,\r\n    r: remove,\r\n    mt: mountComponent,\r\n    mc: mountChildren,\r\n    pc: patchChildren,\r\n    pbc: patchBlockChildren,\r\n    n: getNextHostNode,\r\n    o: options\r\n  }\r\n\r\n  let hydrate: ReturnType<typeof createHydrationFunctions>[0] | undefined\r\n  let hydrateNode: ReturnType<typeof createHydrationFunctions>[1] | undefined\r\n  if (createHydrationFns) {\r\n    ;[hydrate, hydrateNode] = createHydrationFns(\r\n      internals as RendererInternals<Node, Element>\r\n    )\r\n  }\r\n\r\n  return {\r\n    render,\r\n    hydrate,\r\n    createApp: createAppAPI(render, hydrate)\r\n  }\r\n}\r\n\r\nfunction toggleRecurse(\r\n  { effect, update }: ComponentInternalInstance,\r\n  allowed: boolean\r\n) {\r\n  effect.allowRecurse = update.allowRecurse = allowed\r\n}\r\n\r\nexport function needTransition(\r\n  parentSuspense: SuspenseBoundary | null,\r\n  transition: TransitionHooks | null\r\n) {\r\n  return (\r\n    (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n    transition &&\r\n    !transition.persisted\r\n  )\r\n}\r\n\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always be moved. Therefore, in order to ensure correct move\r\n * position, el should be inherited from previous nodes.\r\n */\r\nexport function traverseStaticChildren(n1: VNode, n2: VNode, shallow = false) {\r\n  const ch1 = n1.children\r\n  const ch2 = n2.children\r\n  if (isArray(ch1) && isArray(ch2)) {\r\n    for (let i = 0; i < ch1.length; i++) {\r\n      // this is only called in the optimized path so array children are\r\n      // guaranteed to be vnodes\r\n      const c1 = ch1[i] as VNode\r\n      let c2 = ch2[i] as VNode\r\n      if (c2.shapeFlag & ShapeFlags.ELEMENT && !c2.dynamicChildren) {\r\n        if (c2.patchFlag <= 0 || c2.patchFlag === PatchFlags.NEED_HYDRATION) {\r\n          c2 = ch2[i] = cloneIfMounted(ch2[i] as VNode)\r\n          c2.el = c1.el\r\n        }\r\n        if (!shallow) traverseStaticChildren(c1, c2)\r\n      }\r\n      // #6852 also inherit for text nodes\r\n      if (c2.type === Text) {\r\n        c2.el = c1.el\r\n      }\r\n      // also inherit for comment nodes, but not placeholders (e.g. v-if which\r\n      // would have received .el during block patch)\r\n      if (__DEV__ && c2.type === Comment && !c2.el) {\r\n        c2.el = c1.el\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr: number[]): number[] {\r\n  const p = arr.slice()\r\n  const result = [0]\r\n  let i, j, u, v, c\r\n  const len = arr.length\r\n  for (i = 0; i < len; i++) {\r\n    const arrI = arr[i]\r\n    if (arrI !== 0) {\r\n      j = result[result.length - 1]\r\n      if (arr[j] < arrI) {\r\n        p[i] = j\r\n        result.push(i)\r\n        continue\r\n      }\r\n      u = 0\r\n      v = result.length - 1\r\n      while (u < v) {\r\n        c = (u + v) >> 1\r\n        if (arr[result[c]] < arrI) {\r\n          u = c + 1\r\n        } else {\r\n          v = c\r\n        }\r\n      }\r\n      if (arrI < arr[result[u]]) {\r\n        if (u > 0) {\r\n          p[i] = result[u - 1]\r\n        }\r\n        result[u] = i\r\n      }\r\n    }\r\n  }\r\n  u = result.length\r\n  v = result[u - 1]\r\n  while (u-- > 0) {\r\n    result[u] = v\r\n    v = p[v]\r\n  }\r\n  return result\r\n}\r\n", "import {\r\n  VNode,\r\n  normalizeVNode,\r\n  VNodeProps,\r\n  isSameVNodeType,\r\n  openBlock,\r\n  closeBlock,\r\n  currentBlock,\r\n  Comment,\r\n  createVNode,\r\n  isBlockTreeEnabled\r\n} from '../vnode'\r\nimport { isFunction, isArray, ShapeFlags, toNumber } from '@vue/shared'\r\nimport { ComponentInternalInstance, handleSetupResult } from '../component'\r\nimport { Slots } from '../componentSlots'\r\nimport {\r\n  RendererInternals,\r\n  MoveType,\r\n  SetupRenderEffectFn,\r\n  RendererNode,\r\n  RendererElement\r\n} from '../renderer'\r\nimport { queuePostFlushCb } from '../scheduler'\r\nimport { filterSingleRoot, updateHOCHostEl } from '../componentRenderUtils'\r\nimport {\r\n  pushWarningContext,\r\n  popWarningContext,\r\n  warn,\r\n  assertNumber\r\n} from '../warning'\r\nimport { handleError, ErrorCodes } from '../errorHandling'\r\nimport { NULL_DYNAMIC_COMPONENT } from '../helpers/resolveAssets'\r\n\r\nexport interface SuspenseProps {\r\n  onResolve?: () => void\r\n  onPending?: () => void\r\n  onFallback?: () => void\r\n  timeout?: string | number\r\n  /**\r\n   * Allow suspense to be captured by parent suspense\r\n   *\r\n   * @default false\r\n   */\r\n  suspensible?: boolean\r\n}\r\n\r\nexport const isSuspense = (type: any): boolean => type.__isSuspense\r\n\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nexport const SuspenseImpl = {\r\n  name: 'Suspense',\r\n  // In order to make Suspense tree-shakable, we need to avoid importing it\r\n  // directly in the renderer. The renderer checks for the __isSuspense flag\r\n  // on a vnode's type and calls the `process` method, passing in renderer\r\n  // internals.\r\n  __isSuspense: true,\r\n  process(\r\n    n1: VNode | null,\r\n    n2: VNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n    // platform-specific impl passed from renderer\r\n    rendererInternals: RendererInternals\r\n  ) {\r\n    if (n1 == null) {\r\n      mountSuspense(\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        parentSuspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized,\r\n        rendererInternals\r\n      )\r\n    } else {\r\n      patchSuspense(\r\n        n1,\r\n        n2,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized,\r\n        rendererInternals\r\n      )\r\n    }\r\n  },\r\n  hydrate: hydrateSuspense,\r\n  create: createSuspenseBoundary,\r\n  normalize: normalizeSuspenseChildren\r\n}\r\n\r\n// Force-casted public typing for h and TSX props inference\r\nexport const Suspense = (__FEATURE_SUSPENSE__\r\n  ? SuspenseImpl\r\n  : null) as unknown as {\r\n  __isSuspense: true\r\n  new (): {\r\n    $props: VNodeProps & SuspenseProps\r\n    $slots: {\r\n      default(): VNode[]\r\n      fallback(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction triggerEvent(\r\n  vnode: VNode,\r\n  name: 'onResolve' | 'onPending' | 'onFallback'\r\n) {\r\n  const eventListener = vnode.props && vnode.props[name]\r\n  if (isFunction(eventListener)) {\r\n    eventListener()\r\n  }\r\n}\r\n\r\nfunction mountSuspense(\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals\r\n) {\r\n  const {\r\n    p: patch,\r\n    o: { createElement }\r\n  } = rendererInternals\r\n  const hiddenContainer = createElement('div')\r\n  const suspense = (vnode.suspense = createSuspenseBoundary(\r\n    vnode,\r\n    parentSuspense,\r\n    parentComponent,\r\n    container,\r\n    hiddenContainer,\r\n    anchor,\r\n    isSVG,\r\n    slotScopeIds,\r\n    optimized,\r\n    rendererInternals\r\n  ))\r\n\r\n  // start mounting the content subtree in an off-dom container\r\n  patch(\r\n    null,\r\n    (suspense.pendingBranch = vnode.ssContent!),\r\n    hiddenContainer,\r\n    null,\r\n    parentComponent,\r\n    suspense,\r\n    isSVG,\r\n    slotScopeIds\r\n  )\r\n  // now check if we have encountered any async deps\r\n  if (suspense.deps > 0) {\r\n    // has async\r\n    // invoke @fallback event\r\n    triggerEvent(vnode, 'onPending')\r\n    triggerEvent(vnode, 'onFallback')\r\n\r\n    // mount the fallback tree\r\n    patch(\r\n      null,\r\n      vnode.ssFallback!,\r\n      container,\r\n      anchor,\r\n      parentComponent,\r\n      null, // fallback tree will not have suspense context\r\n      isSVG,\r\n      slotScopeIds\r\n    )\r\n    setActiveBranch(suspense, vnode.ssFallback!)\r\n  } else {\r\n    // Suspense has no async deps. Just resolve.\r\n    suspense.resolve(false, true)\r\n  }\r\n}\r\n\r\nfunction patchSuspense(\r\n  n1: VNode,\r\n  n2: VNode,\r\n  container: RendererElement,\r\n  anchor: RendererNode | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  { p: patch, um: unmount, o: { createElement } }: RendererInternals\r\n) {\r\n  const suspense = (n2.suspense = n1.suspense)!\r\n  suspense.vnode = n2\r\n  n2.el = n1.el\r\n  const newBranch = n2.ssContent!\r\n  const newFallback = n2.ssFallback!\r\n\r\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense\r\n  if (pendingBranch) {\r\n    suspense.pendingBranch = newBranch\r\n    if (isSameVNodeType(newBranch, pendingBranch)) {\r\n      // same root type but content may have changed.\r\n      patch(\r\n        pendingBranch,\r\n        newBranch,\r\n        suspense.hiddenContainer,\r\n        null,\r\n        parentComponent,\r\n        suspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n      if (suspense.deps <= 0) {\r\n        suspense.resolve()\r\n      } else if (isInFallback) {\r\n        patch(\r\n          activeBranch,\r\n          newFallback,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          null, // fallback tree will not have suspense context\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        setActiveBranch(suspense, newFallback)\r\n      }\r\n    } else {\r\n      // toggled before pending tree is resolved\r\n      suspense.pendingId++\r\n      if (isHydrating) {\r\n        // if toggled before hydration is finished, the current DOM tree is\r\n        // no longer valid. set it as the active branch so it will be unmounted\r\n        // when resolved\r\n        suspense.isHydrating = false\r\n        suspense.activeBranch = pendingBranch\r\n      } else {\r\n        unmount(pendingBranch, parentComponent, suspense)\r\n      }\r\n      // increment pending ID. this is used to invalidate async callbacks\r\n      // reset suspense state\r\n      suspense.deps = 0\r\n      // discard effects from pending branch\r\n      suspense.effects.length = 0\r\n      // discard previous container\r\n      suspense.hiddenContainer = createElement('div')\r\n\r\n      if (isInFallback) {\r\n        // already in fallback state\r\n        patch(\r\n          null,\r\n          newBranch,\r\n          suspense.hiddenContainer,\r\n          null,\r\n          parentComponent,\r\n          suspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        if (suspense.deps <= 0) {\r\n          suspense.resolve()\r\n        } else {\r\n          patch(\r\n            activeBranch,\r\n            newFallback,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            null, // fallback tree will not have suspense context\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n          setActiveBranch(suspense, newFallback)\r\n        }\r\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n        // toggled \"back\" to current active branch\r\n        patch(\r\n          activeBranch,\r\n          newBranch,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          suspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        // force resolve\r\n        suspense.resolve(true)\r\n      } else {\r\n        // switched to a 3rd branch\r\n        patch(\r\n          null,\r\n          newBranch,\r\n          suspense.hiddenContainer,\r\n          null,\r\n          parentComponent,\r\n          suspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        if (suspense.deps <= 0) {\r\n          suspense.resolve()\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n      // root did not change, just normal patch\r\n      patch(\r\n        activeBranch,\r\n        newBranch,\r\n        container,\r\n        anchor,\r\n        parentComponent,\r\n        suspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n      setActiveBranch(suspense, newBranch)\r\n    } else {\r\n      // root node toggled\r\n      // invoke @pending event\r\n      triggerEvent(n2, 'onPending')\r\n      // mount pending branch in off-dom container\r\n      suspense.pendingBranch = newBranch\r\n      suspense.pendingId++\r\n      patch(\r\n        null,\r\n        newBranch,\r\n        suspense.hiddenContainer,\r\n        null,\r\n        parentComponent,\r\n        suspense,\r\n        isSVG,\r\n        slotScopeIds,\r\n        optimized\r\n      )\r\n      if (suspense.deps <= 0) {\r\n        // incoming branch has no async deps, resolve now.\r\n        suspense.resolve()\r\n      } else {\r\n        const { timeout, pendingId } = suspense\r\n        if (timeout > 0) {\r\n          setTimeout(() => {\r\n            if (suspense.pendingId === pendingId) {\r\n              suspense.fallback(newFallback)\r\n            }\r\n          }, timeout)\r\n        } else if (timeout === 0) {\r\n          suspense.fallback(newFallback)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport interface SuspenseBoundary {\r\n  vnode: VNode<RendererNode, RendererElement, SuspenseProps>\r\n  parent: SuspenseBoundary | null\r\n  parentComponent: ComponentInternalInstance | null\r\n  isSVG: boolean\r\n  container: RendererElement\r\n  hiddenContainer: RendererElement\r\n  anchor: RendererNode | null\r\n  activeBranch: VNode | null\r\n  pendingBranch: VNode | null\r\n  deps: number\r\n  pendingId: number\r\n  timeout: number\r\n  isInFallback: boolean\r\n  isHydrating: boolean\r\n  isUnmounted: boolean\r\n  effects: Function[]\r\n  resolve(force?: boolean, sync?: boolean): void\r\n  fallback(fallbackVNode: VNode): void\r\n  move(\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    type: MoveType\r\n  ): void\r\n  next(): RendererNode | null\r\n  registerDep(\r\n    instance: ComponentInternalInstance,\r\n    setupRenderEffect: SetupRenderEffectFn\r\n  ): void\r\n  unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void\r\n}\r\n\r\nlet hasWarned = false\r\n\r\nfunction createSuspenseBoundary(\r\n  vnode: VNode,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  container: RendererElement,\r\n  hiddenContainer: RendererElement,\r\n  anchor: RendererNode | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals,\r\n  isHydrating = false\r\n): SuspenseBoundary {\r\n  /* istanbul ignore if */\r\n  if (__DEV__ && !__TEST__ && !hasWarned) {\r\n    hasWarned = true\r\n    // @ts-ignore `console.info` cannot be null error\r\n    console[console.info ? 'info' : 'log'](\r\n      `<Suspense> is an experimental feature and its API will likely change.`\r\n    )\r\n  }\r\n\r\n  const {\r\n    p: patch,\r\n    m: move,\r\n    um: unmount,\r\n    n: next,\r\n    o: { parentNode, remove }\r\n  } = rendererInternals\r\n\r\n  // if set `suspensible: true`, set the current suspense as a dep of parent suspense\r\n  let parentSuspenseId: number | undefined\r\n  const isSuspensible = isVNodeSuspensible(vnode)\r\n  if (isSuspensible) {\r\n    if (parentSuspense?.pendingBranch) {\r\n      parentSuspenseId = parentSuspense.pendingId\r\n      parentSuspense.deps++\r\n    }\r\n  }\r\n\r\n  const timeout = vnode.props ? toNumber(vnode.props.timeout) : undefined\r\n  if (__DEV__) {\r\n    assertNumber(timeout, `Suspense timeout`)\r\n  }\r\n\r\n  const suspense: SuspenseBoundary = {\r\n    vnode,\r\n    parent: parentSuspense,\r\n    parentComponent,\r\n    isSVG,\r\n    container,\r\n    hiddenContainer,\r\n    anchor,\r\n    deps: 0,\r\n    pendingId: 0,\r\n    timeout: typeof timeout === 'number' ? timeout : -1,\r\n    activeBranch: null,\r\n    pendingBranch: null,\r\n    isInFallback: !isHydrating,\r\n    isHydrating,\r\n    isUnmounted: false,\r\n    effects: [],\r\n\r\n    resolve(resume = false, sync = false) {\r\n      if (__DEV__) {\r\n        if (!resume && !suspense.pendingBranch) {\r\n          throw new Error(\r\n            `suspense.resolve() is called without a pending branch.`\r\n          )\r\n        }\r\n        if (suspense.isUnmounted) {\r\n          throw new Error(\r\n            `suspense.resolve() is called on an already unmounted suspense boundary.`\r\n          )\r\n        }\r\n      }\r\n      const {\r\n        vnode,\r\n        activeBranch,\r\n        pendingBranch,\r\n        pendingId,\r\n        effects,\r\n        parentComponent,\r\n        container\r\n      } = suspense\r\n\r\n      // if there's a transition happening we need to wait it to finish.\r\n      let delayEnter: boolean | null = false\r\n      if (suspense.isHydrating) {\r\n        suspense.isHydrating = false\r\n      } else if (!resume) {\r\n        delayEnter =\r\n          activeBranch &&\r\n          pendingBranch!.transition &&\r\n          pendingBranch!.transition.mode === 'out-in'\r\n        if (delayEnter) {\r\n          activeBranch!.transition!.afterLeave = () => {\r\n            if (pendingId === suspense.pendingId) {\r\n              move(\r\n                pendingBranch!,\r\n                container,\r\n                next(activeBranch!),\r\n                MoveType.ENTER\r\n              )\r\n              queuePostFlushCb(effects)\r\n            }\r\n          }\r\n        }\r\n        // this is initial anchor on mount\r\n        let { anchor } = suspense\r\n        // unmount current active tree\r\n        if (activeBranch) {\r\n          // if the fallback tree was mounted, it may have been moved\r\n          // as part of a parent suspense. get the latest anchor for insertion\r\n          anchor = next(activeBranch)\r\n          unmount(activeBranch, parentComponent, suspense, true)\r\n        }\r\n        if (!delayEnter) {\r\n          // move content from off-dom container to actual container\r\n          move(pendingBranch!, container, anchor, MoveType.ENTER)\r\n        }\r\n      }\r\n\r\n      setActiveBranch(suspense, pendingBranch!)\r\n      suspense.pendingBranch = null\r\n      suspense.isInFallback = false\r\n\r\n      // flush buffered effects\r\n      // check if there is a pending parent suspense\r\n      let parent = suspense.parent\r\n      let hasUnresolvedAncestor = false\r\n      while (parent) {\r\n        if (parent.pendingBranch) {\r\n          // found a pending parent suspense, merge buffered post jobs\r\n          // into that parent\r\n          parent.effects.push(...effects)\r\n          hasUnresolvedAncestor = true\r\n          break\r\n        }\r\n        parent = parent.parent\r\n      }\r\n      // no pending parent suspense nor transition, flush all jobs\r\n      if (!hasUnresolvedAncestor && !delayEnter) {\r\n        queuePostFlushCb(effects)\r\n      }\r\n      suspense.effects = []\r\n\r\n      // resolve parent suspense if all async deps are resolved\r\n      if (isSuspensible) {\r\n        if (\r\n          parentSuspense &&\r\n          parentSuspense.pendingBranch &&\r\n          parentSuspenseId === parentSuspense.pendingId\r\n        ) {\r\n          parentSuspense.deps--\r\n          if (parentSuspense.deps === 0 && !sync) {\r\n            parentSuspense.resolve()\r\n          }\r\n        }\r\n      }\r\n\r\n      // invoke @resolve event\r\n      triggerEvent(vnode, 'onResolve')\r\n    },\r\n\r\n    fallback(fallbackVNode) {\r\n      if (!suspense.pendingBranch) {\r\n        return\r\n      }\r\n\r\n      const { vnode, activeBranch, parentComponent, container, isSVG } =\r\n        suspense\r\n\r\n      // invoke @fallback event\r\n      triggerEvent(vnode, 'onFallback')\r\n\r\n      const anchor = next(activeBranch!)\r\n      const mountFallback = () => {\r\n        if (!suspense.isInFallback) {\r\n          return\r\n        }\r\n        // mount the fallback tree\r\n        patch(\r\n          null,\r\n          fallbackVNode,\r\n          container,\r\n          anchor,\r\n          parentComponent,\r\n          null, // fallback tree will not have suspense context\r\n          isSVG,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        setActiveBranch(suspense, fallbackVNode)\r\n      }\r\n\r\n      const delayEnter =\r\n        fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in'\r\n      if (delayEnter) {\r\n        activeBranch!.transition!.afterLeave = mountFallback\r\n      }\r\n      suspense.isInFallback = true\r\n\r\n      // unmount current active branch\r\n      unmount(\r\n        activeBranch!,\r\n        parentComponent,\r\n        null, // no suspense so unmount hooks fire now\r\n        true // shouldRemove\r\n      )\r\n\r\n      if (!delayEnter) {\r\n        mountFallback()\r\n      }\r\n    },\r\n\r\n    move(container, anchor, type) {\r\n      suspense.activeBranch &&\r\n        move(suspense.activeBranch, container, anchor, type)\r\n      suspense.container = container\r\n    },\r\n\r\n    next() {\r\n      return suspense.activeBranch && next(suspense.activeBranch)\r\n    },\r\n\r\n    registerDep(instance, setupRenderEffect) {\r\n      const isInPendingSuspense = !!suspense.pendingBranch\r\n      if (isInPendingSuspense) {\r\n        suspense.deps++\r\n      }\r\n      const hydratedEl = instance.vnode.el\r\n      instance\r\n        .asyncDep!.catch(err => {\r\n          handleError(err, instance, ErrorCodes.SETUP_FUNCTION)\r\n        })\r\n        .then(asyncSetupResult => {\r\n          // retry when the setup() promise resolves.\r\n          // component may have been unmounted before resolve.\r\n          if (\r\n            instance.isUnmounted ||\r\n            suspense.isUnmounted ||\r\n            suspense.pendingId !== instance.suspenseId\r\n          ) {\r\n            return\r\n          }\r\n          // retry from this component\r\n          instance.asyncResolved = true\r\n          const { vnode } = instance\r\n          if (__DEV__) {\r\n            pushWarningContext(vnode)\r\n          }\r\n          handleSetupResult(instance, asyncSetupResult, false)\r\n          if (hydratedEl) {\r\n            // vnode may have been replaced if an update happened before the\r\n            // async dep is resolved.\r\n            vnode.el = hydratedEl\r\n          }\r\n          const placeholder = !hydratedEl && instance.subTree.el\r\n          setupRenderEffect(\r\n            instance,\r\n            vnode,\r\n            // component may have been moved before resolve.\r\n            // if this is not a hydration, instance.subTree will be the comment\r\n            // placeholder.\r\n            parentNode(hydratedEl || instance.subTree.el!)!,\r\n            // anchor will not be used if this is hydration, so only need to\r\n            // consider the comment placeholder case.\r\n            hydratedEl ? null : next(instance.subTree),\r\n            suspense,\r\n            isSVG,\r\n            optimized\r\n          )\r\n          if (placeholder) {\r\n            remove(placeholder)\r\n          }\r\n          updateHOCHostEl(instance, vnode.el)\r\n          if (__DEV__) {\r\n            popWarningContext()\r\n          }\r\n          // only decrease deps count if suspense is not already resolved\r\n          if (isInPendingSuspense && --suspense.deps === 0) {\r\n            suspense.resolve()\r\n          }\r\n        })\r\n    },\r\n\r\n    unmount(parentSuspense, doRemove) {\r\n      suspense.isUnmounted = true\r\n      if (suspense.activeBranch) {\r\n        unmount(\r\n          suspense.activeBranch,\r\n          parentComponent,\r\n          parentSuspense,\r\n          doRemove\r\n        )\r\n      }\r\n      if (suspense.pendingBranch) {\r\n        unmount(\r\n          suspense.pendingBranch,\r\n          parentComponent,\r\n          parentSuspense,\r\n          doRemove\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  return suspense\r\n}\r\n\r\nfunction hydrateSuspense(\r\n  node: Node,\r\n  vnode: VNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  isSVG: boolean,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  rendererInternals: RendererInternals,\r\n  hydrateNode: (\r\n    node: Node,\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => Node | null\r\n): Node | null {\r\n  /* eslint-disable no-restricted-globals */\r\n  const suspense = (vnode.suspense = createSuspenseBoundary(\r\n    vnode,\r\n    parentSuspense,\r\n    parentComponent,\r\n    node.parentNode!,\r\n    document.createElement('div'),\r\n    null,\r\n    isSVG,\r\n    slotScopeIds,\r\n    optimized,\r\n    rendererInternals,\r\n    true /* hydrating */\r\n  ))\r\n  // there are two possible scenarios for server-rendered suspense:\r\n  // - success: ssr content should be fully resolved\r\n  // - failure: ssr content should be the fallback branch.\r\n  // however, on the client we don't really know if it has failed or not\r\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n  // need to construct a suspense boundary first\r\n  const result = hydrateNode(\r\n    node,\r\n    (suspense.pendingBranch = vnode.ssContent!),\r\n    parentComponent,\r\n    suspense,\r\n    slotScopeIds,\r\n    optimized\r\n  )\r\n  if (suspense.deps === 0) {\r\n    suspense.resolve(false, true)\r\n  }\r\n  return result\r\n  /* eslint-enable no-restricted-globals */\r\n}\r\n\r\nfunction normalizeSuspenseChildren(vnode: VNode) {\r\n  const { shapeFlag, children } = vnode\r\n  const isSlotChildren = shapeFlag & ShapeFlags.SLOTS_CHILDREN\r\n  vnode.ssContent = normalizeSuspenseSlot(\r\n    isSlotChildren ? (children as Slots).default : children\r\n  )\r\n  vnode.ssFallback = isSlotChildren\r\n    ? normalizeSuspenseSlot((children as Slots).fallback)\r\n    : createVNode(Comment)\r\n}\r\n\r\nfunction normalizeSuspenseSlot(s: any) {\r\n  let block: VNode[] | null | undefined\r\n  if (isFunction(s)) {\r\n    const trackBlock = isBlockTreeEnabled && s._c\r\n    if (trackBlock) {\r\n      // disableTracking: false\r\n      // allow block tracking for compiled slots\r\n      // (see ./componentRenderContext.ts)\r\n      s._d = false\r\n      openBlock()\r\n    }\r\n    s = s()\r\n    if (trackBlock) {\r\n      s._d = true\r\n      block = currentBlock\r\n      closeBlock()\r\n    }\r\n  }\r\n  if (isArray(s)) {\r\n    const singleChild = filterSingleRoot(s)\r\n    if (\r\n      __DEV__ &&\r\n      !singleChild &&\r\n      s.filter(child => child !== NULL_DYNAMIC_COMPONENT).length > 0\r\n    ) {\r\n      warn(`<Suspense> slots expect a single root node.`)\r\n    }\r\n    s = singleChild\r\n  }\r\n  s = normalizeVNode(s)\r\n  if (block && !s.dynamicChildren) {\r\n    s.dynamicChildren = block.filter(c => c !== s)\r\n  }\r\n  return s\r\n}\r\n\r\nexport function queueEffectWithSuspense(\r\n  fn: Function | Function[],\r\n  suspense: SuspenseBoundary | null\r\n): void {\r\n  if (suspense && suspense.pendingBranch) {\r\n    if (isArray(fn)) {\r\n      suspense.effects.push(...fn)\r\n    } else {\r\n      suspense.effects.push(fn)\r\n    }\r\n  } else {\r\n    queuePostFlushCb(fn)\r\n  }\r\n}\r\n\r\nfunction setActiveBranch(suspense: SuspenseBoundary, branch: VNode) {\r\n  suspense.activeBranch = branch\r\n  const { vnode, parentComponent } = suspense\r\n  const el = (vnode.el = branch.el)\r\n  // in case suspense is the root node of a component,\r\n  // recursively update the HOC el\r\n  if (parentComponent && parentComponent.subTree === vnode) {\r\n    parentComponent.vnode.el = el\r\n    updateHOCHostEl(parentComponent, el)\r\n  }\r\n}\r\n\r\nfunction isVNodeSuspensible(vnode: VNode) {\r\n  return vnode.props?.suspensible != null && vnode.props.suspensible !== false\r\n}\r\n", "import { ComponentInternalInstance } from '../component'\r\nimport { SuspenseBoundary } from './Suspense'\r\nimport {\r\n  RendererInternals,\r\n  MoveType,\r\n  RendererElement,\r\n  RendererNode,\r\n  RendererOptions,\r\n  traverseStaticChildren\r\n} from '../renderer'\r\nimport { VNode, VNodeArrayChildren, VNodeProps } from '../vnode'\r\nimport { isString, ShapeFlags } from '@vue/shared'\r\nimport { warn } from '../warning'\r\nimport { isHmrUpdating } from '../hmr'\r\n\r\nexport type TeleportVNode = VNode<RendererNode, RendererElement, TeleportProps>\r\n\r\nexport interface TeleportProps {\r\n  to: string | RendererElement | null | undefined\r\n  disabled?: boolean\r\n}\r\n\r\nexport const isTeleport = (type: any): boolean => type.__isTeleport\r\n\r\nconst isTeleportDisabled = (props: VNode['props']): boolean =>\r\n  props && (props.disabled || props.disabled === '')\r\n\r\nconst isTargetSVG = (target: RendererElement): boolean =>\r\n  typeof SVGElement !== 'undefined' && target instanceof SVGElement\r\n\r\nconst resolveTarget = <T = RendererElement>(\r\n  props: TeleportProps | null,\r\n  select: RendererOptions['querySelector']\r\n): T | null => {\r\n  const targetSelector = props && props.to\r\n  if (isString(targetSelector)) {\r\n    if (!select) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Current renderer does not support string target for Teleports. ` +\r\n            `(missing querySelector renderer option)`\r\n        )\r\n      return null\r\n    } else {\r\n      const target = select(targetSelector)\r\n      if (!target) {\r\n        __DEV__ &&\r\n          warn(\r\n            `Failed to locate Teleport target with selector \"${targetSelector}\". ` +\r\n              `Note the target element must exist before the component is mounted - ` +\r\n              `i.e. the target cannot be rendered by the component itself, and ` +\r\n              `ideally should be outside of the entire Vue component tree.`\r\n          )\r\n      }\r\n      return target as T\r\n    }\r\n  } else {\r\n    if (__DEV__ && !targetSelector && !isTeleportDisabled(props)) {\r\n      warn(`Invalid Teleport target: ${targetSelector}`)\r\n    }\r\n    return targetSelector as T\r\n  }\r\n}\r\n\r\nexport const TeleportImpl = {\r\n  name: 'Teleport',\r\n  __isTeleport: true,\r\n  process(\r\n    n1: TeleportVNode | null,\r\n    n2: TeleportVNode,\r\n    container: RendererElement,\r\n    anchor: RendererNode | null,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    isSVG: boolean,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean,\r\n    internals: RendererInternals\r\n  ) {\r\n    const {\r\n      mc: mountChildren,\r\n      pc: patchChildren,\r\n      pbc: patchBlockChildren,\r\n      o: { insert, querySelector, createText, createComment }\r\n    } = internals\r\n\r\n    const disabled = isTeleportDisabled(n2.props)\r\n    let { shapeFlag, children, dynamicChildren } = n2\r\n\r\n    // #3302\r\n    // HMR updated, force full diff\r\n    if (__DEV__ && isHmrUpdating) {\r\n      optimized = false\r\n      dynamicChildren = null\r\n    }\r\n\r\n    if (n1 == null) {\r\n      // insert anchors in the main view\r\n      const placeholder = (n2.el = __DEV__\r\n        ? createComment('teleport start')\r\n        : createText(''))\r\n      const mainAnchor = (n2.anchor = __DEV__\r\n        ? createComment('teleport end')\r\n        : createText(''))\r\n      insert(placeholder, container, anchor)\r\n      insert(mainAnchor, container, anchor)\r\n      const target = (n2.target = resolveTarget(n2.props, querySelector))\r\n      const targetAnchor = (n2.targetAnchor = createText(''))\r\n      if (target) {\r\n        insert(targetAnchor, target)\r\n        // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n        isSVG = isSVG || isTargetSVG(target)\r\n      } else if (__DEV__ && !disabled) {\r\n        warn('Invalid Teleport target on mount:', target, `(${typeof target})`)\r\n      }\r\n\r\n      const mount = (container: RendererElement, anchor: RendererNode) => {\r\n        // Teleport *always* has Array children. This is enforced in both the\r\n        // compiler and vnode children normalization.\r\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n          mountChildren(\r\n            children as VNodeArrayChildren,\r\n            container,\r\n            anchor,\r\n            parentComponent,\r\n            parentSuspense,\r\n            isSVG,\r\n            slotScopeIds,\r\n            optimized\r\n          )\r\n        }\r\n      }\r\n\r\n      if (disabled) {\r\n        mount(container, mainAnchor)\r\n      } else if (target) {\r\n        mount(target, targetAnchor)\r\n      }\r\n    } else {\r\n      // update content\r\n      n2.el = n1.el\r\n      const mainAnchor = (n2.anchor = n1.anchor)!\r\n      const target = (n2.target = n1.target)!\r\n      const targetAnchor = (n2.targetAnchor = n1.targetAnchor)!\r\n      const wasDisabled = isTeleportDisabled(n1.props)\r\n      const currentContainer = wasDisabled ? container : target\r\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor\r\n      isSVG = isSVG || isTargetSVG(target)\r\n\r\n      if (dynamicChildren) {\r\n        // fast path when the teleport happens to be a block root\r\n        patchBlockChildren(\r\n          n1.dynamicChildren!,\r\n          dynamicChildren,\r\n          currentContainer,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds\r\n        )\r\n        // even in block tree mode we need to make sure all root-level nodes\r\n        // in the teleport inherit previous DOM references so that they can\r\n        // be moved in future patches.\r\n        traverseStaticChildren(n1, n2, true)\r\n      } else if (!optimized) {\r\n        patchChildren(\r\n          n1,\r\n          n2,\r\n          currentContainer,\r\n          currentAnchor,\r\n          parentComponent,\r\n          parentSuspense,\r\n          isSVG,\r\n          slotScopeIds,\r\n          false\r\n        )\r\n      }\r\n\r\n      if (disabled) {\r\n        if (!wasDisabled) {\r\n          // enabled -> disabled\r\n          // move into main container\r\n          moveTeleport(\r\n            n2,\r\n            container,\r\n            mainAnchor,\r\n            internals,\r\n            TeleportMoveTypes.TOGGLE\r\n          )\r\n        } else {\r\n          // #7835\r\n          // When `teleport` is disabled, `to` may change, making it always old,\r\n          // to ensure the correct `to` when enabled\r\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\r\n            n2.props.to = n1.props.to\r\n          }\r\n        }\r\n      } else {\r\n        // target changed\r\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n          const nextTarget = (n2.target = resolveTarget(\r\n            n2.props,\r\n            querySelector\r\n          ))\r\n          if (nextTarget) {\r\n            moveTeleport(\r\n              n2,\r\n              nextTarget,\r\n              null,\r\n              internals,\r\n              TeleportMoveTypes.TARGET_CHANGE\r\n            )\r\n          } else if (__DEV__) {\r\n            warn(\r\n              'Invalid Teleport target on update:',\r\n              target,\r\n              `(${typeof target})`\r\n            )\r\n          }\r\n        } else if (wasDisabled) {\r\n          // disabled -> enabled\r\n          // move into teleport target\r\n          moveTeleport(\r\n            n2,\r\n            target,\r\n            targetAnchor,\r\n            internals,\r\n            TeleportMoveTypes.TOGGLE\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    updateCssVars(n2)\r\n  },\r\n\r\n  remove(\r\n    vnode: VNode,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    optimized: boolean,\r\n    { um: unmount, o: { remove: hostRemove } }: RendererInternals,\r\n    doRemove: boolean\r\n  ) {\r\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode\r\n\r\n    if (target) {\r\n      hostRemove(targetAnchor!)\r\n    }\r\n\r\n    // an unmounted teleport should always unmount its children whether it's disabled or not\r\n    doRemove && hostRemove(anchor!)\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      const shouldRemove = doRemove || !isTeleportDisabled(props)\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        const child = (children as VNode[])[i]\r\n        unmount(\r\n          child,\r\n          parentComponent,\r\n          parentSuspense,\r\n          shouldRemove,\r\n          !!child.dynamicChildren\r\n        )\r\n      }\r\n    }\r\n  },\r\n\r\n  move: moveTeleport,\r\n  hydrate: hydrateTeleport\r\n}\r\n\r\nexport const enum TeleportMoveTypes {\r\n  TARGET_CHANGE,\r\n  TOGGLE, // enable / disable\r\n  REORDER // moved in the main view\r\n}\r\n\r\nfunction moveTeleport(\r\n  vnode: VNode,\r\n  container: RendererElement,\r\n  parentAnchor: RendererNode | null,\r\n  { o: { insert }, m: move }: RendererInternals,\r\n  moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER\r\n) {\r\n  // move target anchor if this is a target change.\r\n  if (moveType === TeleportMoveTypes.TARGET_CHANGE) {\r\n    insert(vnode.targetAnchor!, container, parentAnchor)\r\n  }\r\n  const { el, anchor, shapeFlag, children, props } = vnode\r\n  const isReorder = moveType === TeleportMoveTypes.REORDER\r\n  // move main view anchor if this is a re-order.\r\n  if (isReorder) {\r\n    insert(el!, container, parentAnchor)\r\n  }\r\n  // if this is a re-order and teleport is enabled (content is in target)\r\n  // do not move children. So the opposite is: only move children if this\r\n  // is not a reorder, or the teleport is disabled\r\n  if (!isReorder || isTeleportDisabled(props)) {\r\n    // Teleport has either Array children or no children.\r\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      for (let i = 0; i < (children as VNode[]).length; i++) {\r\n        move(\r\n          (children as VNode[])[i],\r\n          container,\r\n          parentAnchor,\r\n          MoveType.REORDER\r\n        )\r\n      }\r\n    }\r\n  }\r\n  // move main view anchor if this is a re-order.\r\n  if (isReorder) {\r\n    insert(anchor!, container, parentAnchor)\r\n  }\r\n}\r\n\r\ninterface TeleportTargetElement extends Element {\r\n  // last teleport target\r\n  _lpa?: Node | null\r\n}\r\n\r\nfunction hydrateTeleport(\r\n  node: Node,\r\n  vnode: TeleportVNode,\r\n  parentComponent: ComponentInternalInstance | null,\r\n  parentSuspense: SuspenseBoundary | null,\r\n  slotScopeIds: string[] | null,\r\n  optimized: boolean,\r\n  {\r\n    o: { nextSibling, parentNode, querySelector }\r\n  }: RendererInternals<Node, Element>,\r\n  hydrateChildren: (\r\n    node: Node | null,\r\n    vnode: VNode,\r\n    container: Element,\r\n    parentComponent: ComponentInternalInstance | null,\r\n    parentSuspense: SuspenseBoundary | null,\r\n    slotScopeIds: string[] | null,\r\n    optimized: boolean\r\n  ) => Node | null\r\n): Node | null {\r\n  const target = (vnode.target = resolveTarget<Element>(\r\n    vnode.props,\r\n    querySelector\r\n  ))\r\n  if (target) {\r\n    // if multiple teleports rendered to the same target element, we need to\r\n    // pick up from where the last teleport finished instead of the first node\r\n    const targetNode =\r\n      (target as TeleportTargetElement)._lpa || target.firstChild\r\n    if (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n      if (isTeleportDisabled(vnode.props)) {\r\n        vnode.anchor = hydrateChildren(\r\n          nextSibling(node),\r\n          vnode,\r\n          parentNode(node)!,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n        vnode.targetAnchor = targetNode\r\n      } else {\r\n        vnode.anchor = nextSibling(node)\r\n\r\n        // lookahead until we find the target anchor\r\n        // we cannot rely on return value of hydrateChildren() because there\r\n        // could be nested teleports\r\n        let targetAnchor = targetNode\r\n        while (targetAnchor) {\r\n          targetAnchor = nextSibling(targetAnchor)\r\n          if (\r\n            targetAnchor &&\r\n            targetAnchor.nodeType === 8 &&\r\n            (targetAnchor as Comment).data === 'teleport anchor'\r\n          ) {\r\n            vnode.targetAnchor = targetAnchor\r\n            ;(target as TeleportTargetElement)._lpa =\r\n              vnode.targetAnchor && nextSibling(vnode.targetAnchor as Node)\r\n            break\r\n          }\r\n        }\r\n\r\n        hydrateChildren(\r\n          targetNode,\r\n          vnode,\r\n          target,\r\n          parentComponent,\r\n          parentSuspense,\r\n          slotScopeIds,\r\n          optimized\r\n        )\r\n      }\r\n    }\r\n    updateCssVars(vnode)\r\n  }\r\n  return vnode.anchor && nextSibling(vnode.anchor as Node)\r\n}\r\n\r\n// Force-casted public typing for h and TSX props inference\r\nexport const Teleport = TeleportImpl as unknown as {\r\n  __isTeleport: true\r\n  new (): {\r\n    $props: VNodeProps & TeleportProps\r\n    $slots: {\r\n      default(): VNode[]\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateCssVars(vnode: VNode) {\r\n  // presence of .ut method indicates owner component uses css vars.\r\n  // code path here can assume browser environment.\r\n  const ctx = vnode.ctx\r\n  if (ctx && ctx.ut) {\r\n    let node = (vnode.children as VNode[])[0].el!\r\n    while (node && node !== vnode.targetAnchor) {\r\n      if (node.nodeType === 1) node.setAttribute('data-v-owner', ctx.uid)\r\n      node = node.nextSibling\r\n    }\r\n    ctx.ut()\r\n  }\r\n}\r\n", "import {\r\n  isArray,\r\n  isFunction,\r\n  isString,\r\n  isObject,\r\n  EMPTY_ARR,\r\n  extend,\r\n  normalizeClass,\r\n  normalizeStyle,\r\n  PatchFlags,\r\n  ShapeFlags,\r\n  SlotFlags,\r\n  isOn\r\n} from '@vue/shared'\r\nimport {\r\n  ComponentInternalInstance,\r\n  Data,\r\n  ConcreteComponent,\r\n  ClassComponent,\r\n  Component,\r\n  isClassComponent\r\n} from './component'\r\nimport { RawSlots } from './componentSlots'\r\nimport { isProxy, Ref, toRaw, ReactiveFlags, isRef } from '@vue/reactivity'\r\nimport { AppContext } from './apiCreateApp'\r\nimport {\r\n  Suspense,\r\n  SuspenseImpl,\r\n  isSuspense,\r\n  SuspenseBoundary\r\n} from './components/Suspense'\r\nimport { DirectiveBinding } from './directives'\r\nimport { TransitionHooks } from './components/BaseTransition'\r\nimport { warn } from './warning'\r\nimport { Teleport, TeleportImpl, isTeleport } from './components/Teleport'\r\nimport {\r\n  currentRenderingInstance,\r\n  currentScopeId\r\n} from './componentRenderContext'\r\nimport { RendererNode, RendererElement } from './renderer'\r\nimport { NULL_DYNAMIC_COMPONENT } from './helpers/resolveAssets'\r\nimport { hmrDirtyComponents } from './hmr'\r\nimport { convertLegacyComponent } from './compat/component'\r\nimport { convertLegacyVModelProps } from './compat/componentVModel'\r\nimport { defineLegacyVNodeProperties } from './compat/renderFn'\r\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\r\nimport { ComponentPublicInstance } from './componentPublicInstance'\r\n\r\nexport const Fragment = Symbol.for('v-fgt') as any as {\r\n  __isFragment: true\r\n  new (): {\r\n    $props: VNodeProps\r\n  }\r\n}\r\nexport const Text = Symbol.for('v-txt')\r\nexport const Comment = Symbol.for('v-cmt')\r\nexport const Static = Symbol.for('v-stc')\r\n\r\nexport type VNodeTypes =\r\n  | string\r\n  | VNode\r\n  | Component\r\n  | typeof Text\r\n  | typeof Static\r\n  | typeof Comment\r\n  | typeof Fragment\r\n  | typeof Teleport\r\n  | typeof TeleportImpl\r\n  | typeof Suspense\r\n  | typeof SuspenseImpl\r\n\r\nexport type VNodeRef =\r\n  | string\r\n  | Ref\r\n  | ((\r\n      ref: Element | ComponentPublicInstance | null,\r\n      refs: Record<string, any>\r\n    ) => void)\r\n\r\nexport type VNodeNormalizedRefAtom = {\r\n  i: ComponentInternalInstance\r\n  r: VNodeRef\r\n  k?: string // setup ref key\r\n  f?: boolean // refInFor marker\r\n}\r\n\r\nexport type VNodeNormalizedRef =\r\n  | VNodeNormalizedRefAtom\r\n  | VNodeNormalizedRefAtom[]\r\n\r\ntype VNodeMountHook = (vnode: VNode) => void\r\ntype VNodeUpdateHook = (vnode: VNode, oldVNode: VNode) => void\r\nexport type VNodeHook =\r\n  | VNodeMountHook\r\n  | VNodeUpdateHook\r\n  | VNodeMountHook[]\r\n  | VNodeUpdateHook[]\r\n\r\n// https://github.com/microsoft/TypeScript/issues/33099\r\nexport type VNodeProps = {\r\n  key?: string | number | symbol\r\n  ref?: VNodeRef\r\n  ref_for?: boolean\r\n  ref_key?: string\r\n\r\n  // vnode hooks\r\n  onVnodeBeforeMount?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeMounted?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeBeforeUpdate?: VNodeUpdateHook | VNodeUpdateHook[]\r\n  onVnodeUpdated?: VNodeUpdateHook | VNodeUpdateHook[]\r\n  onVnodeBeforeUnmount?: VNodeMountHook | VNodeMountHook[]\r\n  onVnodeUnmounted?: VNodeMountHook | VNodeMountHook[]\r\n}\r\n\r\ntype VNodeChildAtom =\r\n  | VNode\r\n  | string\r\n  | number\r\n  | boolean\r\n  | null\r\n  | undefined\r\n  | void\r\n\r\nexport type VNodeArrayChildren = Array<VNodeArrayChildren | VNodeChildAtom>\r\n\r\nexport type VNodeChild = VNodeChildAtom | VNodeArrayChildren\r\n\r\nexport type VNodeNormalizedChildren =\r\n  | string\r\n  | VNodeArrayChildren\r\n  | RawSlots\r\n  | null\r\n\r\nexport interface VNode<\r\n  HostNode = RendererNode,\r\n  HostElement = RendererElement,\r\n  ExtraProps = { [key: string]: any }\r\n> {\r\n  /**\r\n   * @internal\r\n   */\r\n  __v_isVNode: true\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  [ReactiveFlags.SKIP]: true\r\n\r\n  type: VNodeTypes\r\n  props: (VNodeProps & ExtraProps) | null\r\n  key: string | number | symbol | null\r\n  ref: VNodeNormalizedRef | null\r\n  /**\r\n   * SFC only. This is assigned on vnode creation using currentScopeId\r\n   * which is set alongside currentRenderingInstance.\r\n   */\r\n  scopeId: string | null\r\n  /**\r\n   * SFC only. This is assigned to:\r\n   * - Slot fragment vnodes with :slotted SFC styles.\r\n   * - Component vnodes (during patch/hydration) so that its root node can\r\n   *   inherit the component's slotScopeIds\r\n   * @internal\r\n   */\r\n  slotScopeIds: string[] | null\r\n  children: VNodeNormalizedChildren\r\n  component: ComponentInternalInstance | null\r\n  dirs: DirectiveBinding[] | null\r\n  transition: TransitionHooks<HostElement> | null\r\n\r\n  // DOM\r\n  el: HostNode | null\r\n  anchor: HostNode | null // fragment anchor\r\n  target: HostElement | null // teleport target\r\n  targetAnchor: HostNode | null // teleport target anchor\r\n  /**\r\n   * number of elements contained in a static vnode\r\n   * @internal\r\n   */\r\n  staticCount: number\r\n\r\n  // suspense\r\n  suspense: SuspenseBoundary | null\r\n  /**\r\n   * @internal\r\n   */\r\n  ssContent: VNode | null\r\n  /**\r\n   * @internal\r\n   */\r\n  ssFallback: VNode | null\r\n\r\n  // optimization only\r\n  shapeFlag: number\r\n  patchFlag: number\r\n  /**\r\n   * @internal\r\n   */\r\n  dynamicProps: string[] | null\r\n  /**\r\n   * @internal\r\n   */\r\n  dynamicChildren: VNode[] | null\r\n\r\n  // application root node only\r\n  appContext: AppContext | null\r\n\r\n  /**\r\n   * @internal lexical scope owner instance\r\n   */\r\n  ctx: ComponentInternalInstance | null\r\n\r\n  /**\r\n   * @internal attached by v-memo\r\n   */\r\n  memo?: any[]\r\n  /**\r\n   * @internal __COMPAT__ only\r\n   */\r\n  isCompatRoot?: true\r\n  /**\r\n   * @internal custom element interception hook\r\n   */\r\n  ce?: (instance: ComponentInternalInstance) => void\r\n}\r\n\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nexport const blockStack: (VNode[] | null)[] = []\r\nexport let currentBlock: VNode[] | null = null\r\n\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nexport function openBlock(disableTracking = false) {\r\n  blockStack.push((currentBlock = disableTracking ? null : []))\r\n}\r\n\r\nexport function closeBlock() {\r\n  blockStack.pop()\r\n  currentBlock = blockStack[blockStack.length - 1] || null\r\n}\r\n\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nexport let isBlockTreeEnabled = 1\r\n\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nexport function setBlockTracking(value: number) {\r\n  isBlockTreeEnabled += value\r\n}\r\n\r\nfunction setupBlock(vnode: VNode) {\r\n  // save current block children on the block vnode\r\n  vnode.dynamicChildren =\r\n    isBlockTreeEnabled > 0 ? currentBlock || (EMPTY_ARR as any) : null\r\n  // close block\r\n  closeBlock()\r\n  // a block is always going to be patched, so track it as a child of its\r\n  // parent block\r\n  if (isBlockTreeEnabled > 0 && currentBlock) {\r\n    currentBlock.push(vnode)\r\n  }\r\n  return vnode\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createElementBlock(\r\n  type: string | typeof Fragment,\r\n  props?: Record<string, any> | null,\r\n  children?: any,\r\n  patchFlag?: number,\r\n  dynamicProps?: string[],\r\n  shapeFlag?: number\r\n) {\r\n  return setupBlock(\r\n    createBaseVNode(\r\n      type,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      shapeFlag,\r\n      true /* isBlock */\r\n    )\r\n  )\r\n}\r\n\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nexport function createBlock(\r\n  type: VNodeTypes | ClassComponent,\r\n  props?: Record<string, any> | null,\r\n  children?: any,\r\n  patchFlag?: number,\r\n  dynamicProps?: string[]\r\n): VNode {\r\n  return setupBlock(\r\n    createVNode(\r\n      type,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      true /* isBlock: prevent a block from tracking itself */\r\n    )\r\n  )\r\n}\r\n\r\nexport function isVNode(value: any): value is VNode {\r\n  return value ? value.__v_isVNode === true : false\r\n}\r\n\r\nexport function isSameVNodeType(n1: VNode, n2: VNode): boolean {\r\n  if (\r\n    __DEV__ &&\r\n    n2.shapeFlag & ShapeFlags.COMPONENT &&\r\n    hmrDirtyComponents.has(n2.type as ConcreteComponent)\r\n  ) {\r\n    // #7042, ensure the vnode being unmounted during HMR\r\n    // bitwise operations to remove keep alive flags\r\n    n1.shapeFlag &= ~ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\r\n    n2.shapeFlag &= ~ShapeFlags.COMPONENT_KEPT_ALIVE\r\n    // HMR only: if the component has been hot-updated, force a reload.\r\n    return false\r\n  }\r\n  return n1.type === n2.type && n1.key === n2.key\r\n}\r\n\r\nlet vnodeArgsTransformer:\r\n  | ((\r\n      args: Parameters<typeof _createVNode>,\r\n      instance: ComponentInternalInstance | null\r\n    ) => Parameters<typeof _createVNode>)\r\n  | undefined\r\n\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nexport function transformVNodeArgs(transformer?: typeof vnodeArgsTransformer) {\r\n  vnodeArgsTransformer = transformer\r\n}\r\n\r\nconst createVNodeWithArgsTransform = (\r\n  ...args: Parameters<typeof _createVNode>\r\n): VNode => {\r\n  return _createVNode(\r\n    ...(vnodeArgsTransformer\r\n      ? vnodeArgsTransformer(args, currentRenderingInstance)\r\n      : args)\r\n  )\r\n}\r\n\r\nexport const InternalObjectKey = `__vInternal`\r\n\r\nconst normalizeKey = ({ key }: VNodeProps): VNode['key'] =>\r\n  key != null ? key : null\r\n\r\nconst normalizeRef = ({\r\n  ref,\r\n  ref_key,\r\n  ref_for\r\n}: VNodeProps): VNodeNormalizedRefAtom | null => {\r\n  if (typeof ref === 'number') {\r\n    ref = '' + ref\r\n  }\r\n  return (\r\n    ref != null\r\n      ? isString(ref) || isRef(ref) || isFunction(ref)\r\n        ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\r\n        : ref\r\n      : null\r\n  ) as any\r\n}\r\n\r\nfunction createBaseVNode(\r\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\r\n  props: (Data & VNodeProps) | null = null,\r\n  children: unknown = null,\r\n  patchFlag = 0,\r\n  dynamicProps: string[] | null = null,\r\n  shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT,\r\n  isBlockNode = false,\r\n  needFullChildrenNormalization = false\r\n) {\r\n  const vnode = {\r\n    __v_isVNode: true,\r\n    __v_skip: true,\r\n    type,\r\n    props,\r\n    key: props && normalizeKey(props),\r\n    ref: props && normalizeRef(props),\r\n    scopeId: currentScopeId,\r\n    slotScopeIds: null,\r\n    children,\r\n    component: null,\r\n    suspense: null,\r\n    ssContent: null,\r\n    ssFallback: null,\r\n    dirs: null,\r\n    transition: null,\r\n    el: null,\r\n    anchor: null,\r\n    target: null,\r\n    targetAnchor: null,\r\n    staticCount: 0,\r\n    shapeFlag,\r\n    patchFlag,\r\n    dynamicProps,\r\n    dynamicChildren: null,\r\n    appContext: null,\r\n    ctx: currentRenderingInstance\r\n  } as VNode\r\n\r\n  if (needFullChildrenNormalization) {\r\n    normalizeChildren(vnode, children)\r\n    // normalize suspense children\r\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\r\n      ;(type as typeof SuspenseImpl).normalize(vnode)\r\n    }\r\n  } else if (children) {\r\n    // compiled element vnode - if children is passed, only possible types are\r\n    // string or Array.\r\n    vnode.shapeFlag |= isString(children)\r\n      ? ShapeFlags.TEXT_CHILDREN\r\n      : ShapeFlags.ARRAY_CHILDREN\r\n  }\r\n\r\n  // validate key\r\n  if (__DEV__ && vnode.key !== vnode.key) {\r\n    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type)\r\n  }\r\n\r\n  // track vnode for block tree\r\n  if (\r\n    isBlockTreeEnabled > 0 &&\r\n    // avoid a block node from tracking itself\r\n    !isBlockNode &&\r\n    // has current parent block\r\n    currentBlock &&\r\n    // presence of a patch flag indicates this node needs patching on updates.\r\n    // component nodes also should always be patched, because even if the\r\n    // component doesn't need to update, it needs to persist the instance on to\r\n    // the next vnode so that it can be properly unmounted later.\r\n    (vnode.patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&\r\n    // the EVENTS flag is only for hydration and if it is the only flag, the\r\n    // vnode should not be considered dynamic due to handler caching.\r\n    vnode.patchFlag !== PatchFlags.NEED_HYDRATION\r\n  ) {\r\n    currentBlock.push(vnode)\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    convertLegacyVModelProps(vnode)\r\n    defineLegacyVNodeProperties(vnode)\r\n  }\r\n\r\n  return vnode\r\n}\r\n\r\nexport { createBaseVNode as createElementVNode }\r\n\r\nexport const createVNode = (\r\n  __DEV__ ? createVNodeWithArgsTransform : _createVNode\r\n) as typeof _createVNode\r\n\r\nfunction _createVNode(\r\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\r\n  props: (Data & VNodeProps) | null = null,\r\n  children: unknown = null,\r\n  patchFlag: number = 0,\r\n  dynamicProps: string[] | null = null,\r\n  isBlockNode = false\r\n): VNode {\r\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n    if (__DEV__ && !type) {\r\n      warn(`Invalid vnode type when creating vnode: ${type}.`)\r\n    }\r\n    type = Comment\r\n  }\r\n\r\n  if (isVNode(type)) {\r\n    // createVNode receiving an existing vnode. This happens in cases like\r\n    // <component :is=\"vnode\"/>\r\n    // #2078 make sure to merge refs during the clone instead of overwriting it\r\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\r\n    if (children) {\r\n      normalizeChildren(cloned, children)\r\n    }\r\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\r\n      if (cloned.shapeFlag & ShapeFlags.COMPONENT) {\r\n        currentBlock[currentBlock.indexOf(type)] = cloned\r\n      } else {\r\n        currentBlock.push(cloned)\r\n      }\r\n    }\r\n    cloned.patchFlag |= PatchFlags.BAIL\r\n    return cloned\r\n  }\r\n\r\n  // class component normalization.\r\n  if (isClassComponent(type)) {\r\n    type = type.__vccOpts\r\n  }\r\n\r\n  // 2.x async/functional component compat\r\n  if (__COMPAT__) {\r\n    type = convertLegacyComponent(type, currentRenderingInstance)\r\n  }\r\n\r\n  // class & style normalization.\r\n  if (props) {\r\n    // for reactive or proxy objects, we need to clone it to enable mutation.\r\n    props = guardReactiveProps(props)!\r\n    let { class: klass, style } = props\r\n    if (klass && !isString(klass)) {\r\n      props.class = normalizeClass(klass)\r\n    }\r\n    if (isObject(style)) {\r\n      // reactive state objects need to be cloned since they are likely to be\r\n      // mutated\r\n      if (isProxy(style) && !isArray(style)) {\r\n        style = extend({}, style)\r\n      }\r\n      props.style = normalizeStyle(style)\r\n    }\r\n  }\r\n\r\n  // encode the vnode type information into a bitmap\r\n  const shapeFlag = isString(type)\r\n    ? ShapeFlags.ELEMENT\r\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\r\n      ? ShapeFlags.SUSPENSE\r\n      : isTeleport(type)\r\n        ? ShapeFlags.TELEPORT\r\n        : isObject(type)\r\n          ? ShapeFlags.STATEFUL_COMPONENT\r\n          : isFunction(type)\r\n            ? ShapeFlags.FUNCTIONAL_COMPONENT\r\n            : 0\r\n\r\n  if (__DEV__ && shapeFlag & ShapeFlags.STATEFUL_COMPONENT && isProxy(type)) {\r\n    type = toRaw(type)\r\n    warn(\r\n      `Vue received a Component that was made a reactive object. This can ` +\r\n        `lead to unnecessary performance overhead and should be avoided by ` +\r\n        `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\r\n        `instead of \\`ref\\`.`,\r\n      `\\nComponent that was made reactive: `,\r\n      type\r\n    )\r\n  }\r\n\r\n  return createBaseVNode(\r\n    type,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    shapeFlag,\r\n    isBlockNode,\r\n    true\r\n  )\r\n}\r\n\r\nexport function guardReactiveProps(props: (Data & VNodeProps) | null) {\r\n  if (!props) return null\r\n  return isProxy(props) || InternalObjectKey in props\r\n    ? extend({}, props)\r\n    : props\r\n}\r\n\r\nexport function cloneVNode<T, U>(\r\n  vnode: VNode<T, U>,\r\n  extraProps?: (Data & VNodeProps) | null,\r\n  mergeRef = false\r\n): VNode<T, U> {\r\n  // This is intentionally NOT using spread or extend to avoid the runtime\r\n  // key enumeration cost.\r\n  const { props, ref, patchFlag, children } = vnode\r\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props\r\n  const cloned: VNode<T, U> = {\r\n    __v_isVNode: true,\r\n    __v_skip: true,\r\n    type: vnode.type,\r\n    props: mergedProps,\r\n    key: mergedProps && normalizeKey(mergedProps),\r\n    ref:\r\n      extraProps && extraProps.ref\r\n        ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n          // if the vnode itself already has a ref, cloneVNode will need to merge\r\n          // the refs so the single vnode can be set on multiple refs\r\n          mergeRef && ref\r\n          ? isArray(ref)\r\n            ? ref.concat(normalizeRef(extraProps)!)\r\n            : [ref, normalizeRef(extraProps)!]\r\n          : normalizeRef(extraProps)\r\n        : ref,\r\n    scopeId: vnode.scopeId,\r\n    slotScopeIds: vnode.slotScopeIds,\r\n    children:\r\n      __DEV__ && patchFlag === PatchFlags.HOISTED && isArray(children)\r\n        ? (children as VNode[]).map(deepCloneVNode)\r\n        : children,\r\n    target: vnode.target,\r\n    targetAnchor: vnode.targetAnchor,\r\n    staticCount: vnode.staticCount,\r\n    shapeFlag: vnode.shapeFlag,\r\n    // if the vnode is cloned with extra props, we can no longer assume its\r\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n    // note: preserve flag for fragments since they use the flag for children\r\n    // fast paths only.\r\n    patchFlag:\r\n      extraProps && vnode.type !== Fragment\r\n        ? patchFlag === -1 // hoisted node\r\n          ? PatchFlags.FULL_PROPS\r\n          : patchFlag | PatchFlags.FULL_PROPS\r\n        : patchFlag,\r\n    dynamicProps: vnode.dynamicProps,\r\n    dynamicChildren: vnode.dynamicChildren,\r\n    appContext: vnode.appContext,\r\n    dirs: vnode.dirs,\r\n    transition: vnode.transition,\r\n\r\n    // These should technically only be non-null on mounted VNodes. However,\r\n    // they *should* be copied for kept-alive vnodes. So we just always copy\r\n    // them since them being non-null during a mount doesn't affect the logic as\r\n    // they will simply be overwritten.\r\n    component: vnode.component,\r\n    suspense: vnode.suspense,\r\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n    el: vnode.el,\r\n    anchor: vnode.anchor,\r\n    ctx: vnode.ctx,\r\n    ce: vnode.ce\r\n  }\r\n  if (__COMPAT__) {\r\n    defineLegacyVNodeProperties(cloned as VNode)\r\n  }\r\n  return cloned\r\n}\r\n\r\n/**\r\n * Dev only, for HMR of hoisted vnodes reused in v-for\r\n * https://github.com/vitejs/vite/issues/2022\r\n */\r\nfunction deepCloneVNode(vnode: VNode): VNode {\r\n  const cloned = cloneVNode(vnode)\r\n  if (isArray(vnode.children)) {\r\n    cloned.children = (vnode.children as VNode[]).map(deepCloneVNode)\r\n  }\r\n  return cloned\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createTextVNode(text: string = ' ', flag: number = 0): VNode {\r\n  return createVNode(Text, null, text, flag)\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createStaticVNode(\r\n  content: string,\r\n  numberOfNodes: number\r\n): VNode {\r\n  // A static vnode can contain multiple stringified elements, and the number\r\n  // of elements is necessary for hydration.\r\n  const vnode = createVNode(Static, null, content)\r\n  vnode.staticCount = numberOfNodes\r\n  return vnode\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport function createCommentVNode(\r\n  text: string = '',\r\n  // when used as the v-else branch, the comment node must be created as a\r\n  // block to ensure correct updates.\r\n  asBlock: boolean = false\r\n): VNode {\r\n  return asBlock\r\n    ? (openBlock(), createBlock(Comment, null, text))\r\n    : createVNode(Comment, null, text)\r\n}\r\n\r\nexport function normalizeVNode(child: VNodeChild): VNode {\r\n  if (child == null || typeof child === 'boolean') {\r\n    // empty placeholder\r\n    return createVNode(Comment)\r\n  } else if (isArray(child)) {\r\n    // fragment\r\n    return createVNode(\r\n      Fragment,\r\n      null,\r\n      // #3666, avoid reference pollution when reusing vnode\r\n      child.slice()\r\n    )\r\n  } else if (typeof child === 'object') {\r\n    // already vnode, this should be the most common since compiled templates\r\n    // always produce all-vnode children arrays\r\n    return cloneIfMounted(child)\r\n  } else {\r\n    // strings and numbers\r\n    return createVNode(Text, null, String(child))\r\n  }\r\n}\r\n\r\n// optimized normalization for template-compiled render fns\r\nexport function cloneIfMounted(child: VNode): VNode {\r\n  return (child.el === null && child.patchFlag !== PatchFlags.HOISTED) ||\r\n    child.memo\r\n    ? child\r\n    : cloneVNode(child)\r\n}\r\n\r\nexport function normalizeChildren(vnode: VNode, children: unknown) {\r\n  let type = 0\r\n  const { shapeFlag } = vnode\r\n  if (children == null) {\r\n    children = null\r\n  } else if (isArray(children)) {\r\n    type = ShapeFlags.ARRAY_CHILDREN\r\n  } else if (typeof children === 'object') {\r\n    if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {\r\n      // Normalize slot to plain children for plain element and Teleport\r\n      const slot = (children as any).default\r\n      if (slot) {\r\n        // _c marker is added by withCtx() indicating this is a compiled slot\r\n        slot._c && (slot._d = false)\r\n        normalizeChildren(vnode, slot())\r\n        slot._c && (slot._d = true)\r\n      }\r\n      return\r\n    } else {\r\n      type = ShapeFlags.SLOTS_CHILDREN\r\n      const slotFlag = (children as RawSlots)._\r\n      if (!slotFlag && !(InternalObjectKey in children!)) {\r\n        // if slots are not normalized, attach context instance\r\n        // (compiled / normalized slots already have context)\r\n        ;(children as RawSlots)._ctx = currentRenderingInstance\r\n      } else if (slotFlag === SlotFlags.FORWARDED && currentRenderingInstance) {\r\n        // a child component receives forwarded slots from the parent.\r\n        // its slot type is determined by its parent's slot type.\r\n        if (\r\n          (currentRenderingInstance.slots as RawSlots)._ === SlotFlags.STABLE\r\n        ) {\r\n          ;(children as RawSlots)._ = SlotFlags.STABLE\r\n        } else {\r\n          ;(children as RawSlots)._ = SlotFlags.DYNAMIC\r\n          vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        }\r\n      }\r\n    }\r\n  } else if (isFunction(children)) {\r\n    children = { default: children, _ctx: currentRenderingInstance }\r\n    type = ShapeFlags.SLOTS_CHILDREN\r\n  } else {\r\n    children = String(children)\r\n    // force teleport children to array so it can be moved around\r\n    if (shapeFlag & ShapeFlags.TELEPORT) {\r\n      type = ShapeFlags.ARRAY_CHILDREN\r\n      children = [createTextVNode(children as string)]\r\n    } else {\r\n      type = ShapeFlags.TEXT_CHILDREN\r\n    }\r\n  }\r\n  vnode.children = children as VNodeNormalizedChildren\r\n  vnode.shapeFlag |= type\r\n}\r\n\r\nexport function mergeProps(...args: (Data & VNodeProps)[]) {\r\n  const ret: Data = {}\r\n  for (let i = 0; i < args.length; i++) {\r\n    const toMerge = args[i]\r\n    for (const key in toMerge) {\r\n      if (key === 'class') {\r\n        if (ret.class !== toMerge.class) {\r\n          ret.class = normalizeClass([ret.class, toMerge.class])\r\n        }\r\n      } else if (key === 'style') {\r\n        ret.style = normalizeStyle([ret.style, toMerge.style])\r\n      } else if (isOn(key)) {\r\n        const existing = ret[key]\r\n        const incoming = toMerge[key]\r\n        if (\r\n          incoming &&\r\n          existing !== incoming &&\r\n          !(isArray(existing) && existing.includes(incoming))\r\n        ) {\r\n          ret[key] = existing\r\n            ? [].concat(existing as any, incoming as any)\r\n            : incoming\r\n        }\r\n      } else if (key !== '') {\r\n        ret[key] = toMerge[key]\r\n      }\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\nexport function invokeVNodeHook(\r\n  hook: VNodeHook,\r\n  instance: ComponentInternalInstance | null,\r\n  vnode: VNode,\r\n  prevVNode: VNode | null = null\r\n) {\r\n  callWithAsyncErrorHandling(hook, instance, ErrorCodes.VNODE_HOOK, [\r\n    vnode,\r\n    prevVNode\r\n  ])\r\n}\r\n", "import { VNode, VNodeChild, isVNode } from './vnode'\r\nimport {\r\n  isRef,\r\n  pauseTracking,\r\n  resetTracking,\r\n  shallowReadonly,\r\n  proxyRefs,\r\n  EffectScope,\r\n  markRaw,\r\n  track,\r\n  TrackOpTypes,\r\n  ReactiveEffect\r\n} from '@vue/reactivity'\r\nimport {\r\n  ComponentPublicInstance,\r\n  PublicInstanceProxyHandlers,\r\n  createDevRenderContext,\r\n  exposePropsOnRenderContext,\r\n  exposeSetupStateOnRenderContext,\r\n  ComponentPublicInstanceConstructor,\r\n  publicPropertiesMap,\r\n  RuntimeCompiledPublicInstanceProxyHandlers\r\n} from './componentPublicInstance'\r\nimport {\r\n  ComponentPropsOptions,\r\n  NormalizedPropsOptions,\r\n  initProps,\r\n  normalizePropsOptions\r\n} from './componentProps'\r\nimport {\r\n  initSlots,\r\n  InternalSlots,\r\n  Slots,\r\n  SlotsType,\r\n  UnwrapSlotsType\r\n} from './componentSlots'\r\nimport { warn } from './warning'\r\nimport { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\r\nimport { AppContext, createAppContext, AppConfig } from './apiCreateApp'\r\nimport { Directive, validateDirectiveName } from './directives'\r\nimport {\r\n  applyOptions,\r\n  ComponentOptions,\r\n  ComputedOptions,\r\n  MethodOptions,\r\n  resolveMergedOptions\r\n} from './componentOptions'\r\nimport {\r\n  EmitsOptions,\r\n  ObjectEmitsOptions,\r\n  EmitFn,\r\n  emit,\r\n  normalizeEmitsOptions,\r\n  EmitsToProps\r\n} from './componentEmits'\r\nimport {\r\n  EMPTY_OBJ,\r\n  isArray,\r\n  isFunction,\r\n  NOOP,\r\n  isObject,\r\n  NO,\r\n  makeMap,\r\n  isPromise,\r\n  ShapeFlags,\r\n  extend,\r\n  getGlobalThis,\r\n  IfAny\r\n} from '@vue/shared'\r\nimport { SuspenseBoundary } from './components/Suspense'\r\nimport { CompilerOptions } from '@vue/compiler-core'\r\nimport { markAttrsAccessed } from './componentRenderUtils'\r\nimport { currentRenderingInstance } from './componentRenderContext'\r\nimport { startMeasure, endMeasure } from './profiling'\r\nimport { convertLegacyRenderFn } from './compat/renderFn'\r\nimport {\r\n  CompatConfig,\r\n  globalCompatConfig,\r\n  validateCompatConfig\r\n} from './compat/compatConfig'\r\nimport { SchedulerJob } from './scheduler'\r\nimport { LifecycleHooks } from './enums'\r\n\r\nexport type Data = Record<string, unknown>\r\n\r\n/**\r\n * For extending allowed non-declared props on components in TSX\r\n */\r\nexport interface ComponentCustomProps {}\r\n\r\n/**\r\n * Default allowed non-declared props on component in TSX\r\n */\r\nexport interface AllowedComponentProps {\r\n  class?: unknown\r\n  style?: unknown\r\n}\r\n\r\n// Note: can't mark this whole interface internal because some public interfaces\r\n// extend it.\r\nexport interface ComponentInternalOptions {\r\n  /**\r\n   * @internal\r\n   */\r\n  __scopeId?: string\r\n  /**\r\n   * @internal\r\n   */\r\n  __cssModules?: Data\r\n  /**\r\n   * @internal\r\n   */\r\n  __hmrId?: string\r\n  /**\r\n   * Compat build only, for bailing out of certain compatibility behavior\r\n   */\r\n  __isBuiltIn?: boolean\r\n  /**\r\n   * This one should be exposed so that devtools can make use of it\r\n   */\r\n  __file?: string\r\n  /**\r\n   * name inferred from filename\r\n   */\r\n  __name?: string\r\n}\r\n\r\nexport interface FunctionalComponent<\r\n  P = {},\r\n  E extends EmitsOptions = {},\r\n  S extends Record<string, any> = any\r\n> extends ComponentInternalOptions {\r\n  // use of any here is intentional so it can be a valid JSX Element constructor\r\n  (\r\n    props: P & EmitsToProps<E>,\r\n    ctx: Omit<SetupContext<E, IfAny<S, {}, SlotsType<S>>>, 'expose'>\r\n  ): any\r\n  props?: ComponentPropsOptions<P>\r\n  emits?: E | (keyof E)[]\r\n  slots?: IfAny<S, Slots, SlotsType<S>>\r\n  inheritAttrs?: boolean\r\n  displayName?: string\r\n  compatConfig?: CompatConfig\r\n}\r\n\r\nexport interface ClassComponent {\r\n  new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>\r\n  __vccOpts: ComponentOptions\r\n}\r\n\r\n/**\r\n * Concrete component type matches its actual value: it's either an options\r\n * object, or a function. Use this where the code expects to work with actual\r\n * values, e.g. checking if its a function or not. This is mostly for internal\r\n * implementation code.\r\n */\r\nexport type ConcreteComponent<\r\n  Props = {},\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions\r\n> =\r\n  | ComponentOptions<Props, RawBindings, D, C, M>\r\n  | FunctionalComponent<Props, any>\r\n\r\n/**\r\n * A type used in public APIs where a component type is expected.\r\n * The constructor type is an artificial type returned by defineComponent().\r\n */\r\nexport type Component<\r\n  Props = any,\r\n  RawBindings = any,\r\n  D = any,\r\n  C extends ComputedOptions = ComputedOptions,\r\n  M extends MethodOptions = MethodOptions\r\n> =\r\n  | ConcreteComponent<Props, RawBindings, D, C, M>\r\n  | ComponentPublicInstanceConstructor<Props>\r\n\r\nexport type { ComponentOptions }\r\n\r\ntype LifecycleHook<TFn = Function> = TFn[] | null\r\n\r\n// use `E extends any` to force evaluating type to fix #2362\r\nexport type SetupContext<\r\n  E = EmitsOptions,\r\n  S extends SlotsType = {}\r\n> = E extends any\r\n  ? {\r\n      attrs: Data\r\n      slots: UnwrapSlotsType<S>\r\n      emit: EmitFn<E>\r\n      expose: (exposed?: Record<string, any>) => void\r\n    }\r\n  : never\r\n\r\n/**\r\n * @internal\r\n */\r\nexport type InternalRenderFunction = {\r\n  (\r\n    ctx: ComponentPublicInstance,\r\n    cache: ComponentInternalInstance['renderCache'],\r\n    // for compiler-optimized bindings\r\n    $props: ComponentInternalInstance['props'],\r\n    $setup: ComponentInternalInstance['setupState'],\r\n    $data: ComponentInternalInstance['data'],\r\n    $options: ComponentInternalInstance['ctx']\r\n  ): VNodeChild\r\n  _rc?: boolean // isRuntimeCompiled\r\n\r\n  // __COMPAT__ only\r\n  _compatChecked?: boolean // v3 and already checked for v2 compat\r\n  _compatWrapped?: boolean // is wrapped for v2 compat\r\n}\r\n\r\n/**\r\n * We expose a subset of properties on the internal instance as they are\r\n * useful for advanced external libraries and tools.\r\n */\r\nexport interface ComponentInternalInstance {\r\n  uid: number\r\n  type: ConcreteComponent\r\n  parent: ComponentInternalInstance | null\r\n  root: ComponentInternalInstance\r\n  appContext: AppContext\r\n  /**\r\n   * Vnode representing this component in its parent's vdom tree\r\n   */\r\n  vnode: VNode\r\n  /**\r\n   * The pending new vnode from parent updates\r\n   * @internal\r\n   */\r\n  next: VNode | null\r\n  /**\r\n   * Root vnode of this component's own vdom tree\r\n   */\r\n  subTree: VNode\r\n  /**\r\n   * Render effect instance\r\n   */\r\n  effect: ReactiveEffect\r\n  /**\r\n   * Bound effect runner to be passed to schedulers\r\n   */\r\n  update: SchedulerJob\r\n  /**\r\n   * The render function that returns vdom tree.\r\n   * @internal\r\n   */\r\n  render: InternalRenderFunction | null\r\n  /**\r\n   * SSR render function\r\n   * @internal\r\n   */\r\n  ssrRender?: Function | null\r\n  /**\r\n   * Object containing values this component provides for its descendants\r\n   * @internal\r\n   */\r\n  provides: Data\r\n  /**\r\n   * Tracking reactive effects (e.g. watchers) associated with this component\r\n   * so that they can be automatically stopped on component unmount\r\n   * @internal\r\n   */\r\n  scope: EffectScope\r\n  /**\r\n   * cache for proxy access type to avoid hasOwnProperty calls\r\n   * @internal\r\n   */\r\n  accessCache: Data | null\r\n  /**\r\n   * cache for render function values that rely on _ctx but won't need updates\r\n   * after initialized (e.g. inline handlers)\r\n   * @internal\r\n   */\r\n  renderCache: (Function | VNode)[]\r\n\r\n  /**\r\n   * Resolved component registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  components: Record<string, ConcreteComponent> | null\r\n  /**\r\n   * Resolved directive registry, only for components with mixins or extends\r\n   * @internal\r\n   */\r\n  directives: Record<string, Directive> | null\r\n  /**\r\n   * Resolved filters registry, v2 compat only\r\n   * @internal\r\n   */\r\n  filters?: Record<string, Function>\r\n  /**\r\n   * resolved props options\r\n   * @internal\r\n   */\r\n  propsOptions: NormalizedPropsOptions\r\n  /**\r\n   * resolved emits options\r\n   * @internal\r\n   */\r\n  emitsOptions: ObjectEmitsOptions | null\r\n  /**\r\n   * resolved inheritAttrs options\r\n   * @internal\r\n   */\r\n  inheritAttrs?: boolean\r\n  /**\r\n   * is custom element?\r\n   * @internal\r\n   */\r\n  isCE?: boolean\r\n  /**\r\n   * custom element specific HMR method\r\n   * @internal\r\n   */\r\n  ceReload?: (newStyles?: string[]) => void\r\n\r\n  // the rest are only for stateful components ---------------------------------\r\n\r\n  // main proxy that serves as the public instance (`this`)\r\n  proxy: ComponentPublicInstance | null\r\n\r\n  // exposed properties via expose()\r\n  exposed: Record<string, any> | null\r\n  exposeProxy: Record<string, any> | null\r\n\r\n  /**\r\n   * alternative proxy used only for runtime-compiled render functions using\r\n   * `with` block\r\n   * @internal\r\n   */\r\n  withProxy: ComponentPublicInstance | null\r\n  /**\r\n   * This is the target for the public instance proxy. It also holds properties\r\n   * injected by user options (computed, methods etc.) and user-attached\r\n   * custom properties (via `this.x = ...`)\r\n   * @internal\r\n   */\r\n  ctx: Data\r\n\r\n  // state\r\n  data: Data\r\n  props: Data\r\n  attrs: Data\r\n  slots: InternalSlots\r\n  refs: Data\r\n  emit: EmitFn\r\n\r\n  attrsProxy: Data | null\r\n  slotsProxy: Slots | null\r\n\r\n  /**\r\n   * used for keeping track of .once event handlers on components\r\n   * @internal\r\n   */\r\n  emitted: Record<string, boolean> | null\r\n  /**\r\n   * used for caching the value returned from props default factory functions to\r\n   * avoid unnecessary watcher trigger\r\n   * @internal\r\n   */\r\n  propsDefaults: Data\r\n  /**\r\n   * setup related\r\n   * @internal\r\n   */\r\n  setupState: Data\r\n  /**\r\n   * devtools access to additional info\r\n   * @internal\r\n   */\r\n  devtoolsRawSetupState?: any\r\n  /**\r\n   * @internal\r\n   */\r\n  setupContext: SetupContext | null\r\n\r\n  /**\r\n   * suspense related\r\n   * @internal\r\n   */\r\n  suspense: SuspenseBoundary | null\r\n  /**\r\n   * suspense pending batch id\r\n   * @internal\r\n   */\r\n  suspenseId: number\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncDep: Promise<any> | null\r\n  /**\r\n   * @internal\r\n   */\r\n  asyncResolved: boolean\r\n\r\n  // lifecycle\r\n  isMounted: boolean\r\n  isUnmounted: boolean\r\n  isDeactivated: boolean\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_CREATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.CREATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.MOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UPDATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.UNMOUNTED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRACKED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.DEACTIVATED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook\r\n  /**\r\n   * @internal\r\n   */\r\n  [LifecycleHooks.SERVER_PREFETCH]: LifecycleHook<() => Promise<unknown>>\r\n\r\n  /**\r\n   * For caching bound $forceUpdate on public proxy access\r\n   * @internal\r\n   */\r\n  f?: () => void\r\n  /**\r\n   * For caching bound $nextTick on public proxy access\r\n   * @internal\r\n   */\r\n  n?: () => Promise<void>\r\n  /**\r\n   * `updateTeleportCssVars`\r\n   * For updating css vars on contained teleports\r\n   * @internal\r\n   */\r\n  ut?: (vars?: Record<string, string>) => void\r\n}\r\n\r\nconst emptyAppContext = createAppContext()\r\n\r\nlet uid = 0\r\n\r\nexport function createComponentInstance(\r\n  vnode: VNode,\r\n  parent: ComponentInternalInstance | null,\r\n  suspense: SuspenseBoundary | null\r\n) {\r\n  const type = vnode.type as ConcreteComponent\r\n  // inherit parent app context - or - if root, adopt from root vnode\r\n  const appContext =\r\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\r\n\r\n  const instance: ComponentInternalInstance = {\r\n    uid: uid++,\r\n    vnode,\r\n    type,\r\n    parent,\r\n    appContext,\r\n    root: null!, // to be immediately set\r\n    next: null,\r\n    subTree: null!, // will be set synchronously right after creation\r\n    effect: null!,\r\n    update: null!, // will be set synchronously right after creation\r\n    scope: new EffectScope(true /* detached */),\r\n    render: null,\r\n    proxy: null,\r\n    exposed: null,\r\n    exposeProxy: null,\r\n    withProxy: null,\r\n    provides: parent ? parent.provides : Object.create(appContext.provides),\r\n    accessCache: null!,\r\n    renderCache: [],\r\n\r\n    // local resolved assets\r\n    components: null,\r\n    directives: null,\r\n\r\n    // resolved props and emits options\r\n    propsOptions: normalizePropsOptions(type, appContext),\r\n    emitsOptions: normalizeEmitsOptions(type, appContext),\r\n\r\n    // emit\r\n    emit: null!, // to be set immediately\r\n    emitted: null,\r\n\r\n    // props default value\r\n    propsDefaults: EMPTY_OBJ,\r\n\r\n    // inheritAttrs\r\n    inheritAttrs: type.inheritAttrs,\r\n\r\n    // state\r\n    ctx: EMPTY_OBJ,\r\n    data: EMPTY_OBJ,\r\n    props: EMPTY_OBJ,\r\n    attrs: EMPTY_OBJ,\r\n    slots: EMPTY_OBJ,\r\n    refs: EMPTY_OBJ,\r\n    setupState: EMPTY_OBJ,\r\n    setupContext: null,\r\n\r\n    attrsProxy: null,\r\n    slotsProxy: null,\r\n\r\n    // suspense related\r\n    suspense,\r\n    suspenseId: suspense ? suspense.pendingId : 0,\r\n    asyncDep: null,\r\n    asyncResolved: false,\r\n\r\n    // lifecycle hooks\r\n    // not using enums here because it results in computed properties\r\n    isMounted: false,\r\n    isUnmounted: false,\r\n    isDeactivated: false,\r\n    bc: null,\r\n    c: null,\r\n    bm: null,\r\n    m: null,\r\n    bu: null,\r\n    u: null,\r\n    um: null,\r\n    bum: null,\r\n    da: null,\r\n    a: null,\r\n    rtg: null,\r\n    rtc: null,\r\n    ec: null,\r\n    sp: null\r\n  }\r\n  if (__DEV__) {\r\n    instance.ctx = createDevRenderContext(instance)\r\n  } else {\r\n    instance.ctx = { _: instance }\r\n  }\r\n  instance.root = parent ? parent.root : instance\r\n  instance.emit = emit.bind(null, instance)\r\n\r\n  // apply custom element special handling\r\n  if (vnode.ce) {\r\n    vnode.ce(instance)\r\n  }\r\n\r\n  return instance\r\n}\r\n\r\nexport let currentInstance: ComponentInternalInstance | null = null\r\n\r\nexport const getCurrentInstance: () => ComponentInternalInstance | null = () =>\r\n  currentInstance || currentRenderingInstance\r\n\r\ntype GlobalInstanceSetter = ((\r\n  instance: ComponentInternalInstance | null\r\n) => void) & { version?: string }\r\n\r\nlet internalSetCurrentInstance: GlobalInstanceSetter\r\nlet globalCurrentInstanceSetters: GlobalInstanceSetter[]\r\nlet settersKey = '__VUE_INSTANCE_SETTERS__'\r\n\r\n/**\r\n * The following makes getCurrentInstance() usage across multiple copies of Vue\r\n * work. Some cases of how this can happen are summarized in #7590. In principle\r\n * the duplication should be avoided, but in practice there are often cases\r\n * where the user is unable to resolve on their own, especially in complicated\r\n * SSR setups.\r\n *\r\n * Note this fix is technically incomplete, as we still rely on other singletons\r\n * for effectScope and global reactive dependency maps. However, it does make\r\n * some of the most common cases work. It also warns if the duplication is\r\n * found during browser execution.\r\n */\r\nif (__SSR__) {\r\n  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {\r\n    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = []\r\n  }\r\n  globalCurrentInstanceSetters.push(i => (currentInstance = i))\r\n  internalSetCurrentInstance = instance => {\r\n    if (globalCurrentInstanceSetters.length > 1) {\r\n      globalCurrentInstanceSetters.forEach(s => s(instance))\r\n    } else {\r\n      globalCurrentInstanceSetters[0](instance)\r\n    }\r\n  }\r\n} else {\r\n  internalSetCurrentInstance = i => {\r\n    currentInstance = i\r\n  }\r\n}\r\n\r\nexport const setCurrentInstance = (instance: ComponentInternalInstance) => {\r\n  internalSetCurrentInstance(instance)\r\n  instance.scope.on()\r\n}\r\n\r\nexport const unsetCurrentInstance = () => {\r\n  currentInstance && currentInstance.scope.off()\r\n  internalSetCurrentInstance(null)\r\n}\r\n\r\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')\r\n\r\nexport function validateComponentName(name: string, config: AppConfig) {\r\n  const appIsNativeTag = config.isNativeTag || NO\r\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\r\n    warn(\r\n      'Do not use built-in or reserved HTML elements as component id: ' + name\r\n    )\r\n  }\r\n}\r\n\r\nexport function isStatefulComponent(instance: ComponentInternalInstance) {\r\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\r\n}\r\n\r\nexport let isInSSRComponentSetup = false\r\n\r\nexport function setupComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR = false\r\n) {\r\n  isInSSRComponentSetup = isSSR\r\n\r\n  const { props, children } = instance.vnode\r\n  const isStateful = isStatefulComponent(instance)\r\n  initProps(instance, props, isStateful, isSSR)\r\n  initSlots(instance, children)\r\n\r\n  const setupResult = isStateful\r\n    ? setupStatefulComponent(instance, isSSR)\r\n    : undefined\r\n  isInSSRComponentSetup = false\r\n  return setupResult\r\n}\r\n\r\nfunction setupStatefulComponent(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__DEV__) {\r\n    if (Component.name) {\r\n      validateComponentName(Component.name, instance.appContext.config)\r\n    }\r\n    if (Component.components) {\r\n      const names = Object.keys(Component.components)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateComponentName(names[i], instance.appContext.config)\r\n      }\r\n    }\r\n    if (Component.directives) {\r\n      const names = Object.keys(Component.directives)\r\n      for (let i = 0; i < names.length; i++) {\r\n        validateDirectiveName(names[i])\r\n      }\r\n    }\r\n    if (Component.compilerOptions && isRuntimeOnly()) {\r\n      warn(\r\n        `\"compilerOptions\" is only supported when using a build of Vue that ` +\r\n          `includes the runtime compiler. Since you are using a runtime-only ` +\r\n          `build, the options should be passed via your build tool config instead.`\r\n      )\r\n    }\r\n  }\r\n  // 0. create render proxy property access cache\r\n  instance.accessCache = Object.create(null)\r\n  // 1. create public instance / render proxy\r\n  // also mark it raw so it's never observed\r\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\r\n  if (__DEV__) {\r\n    exposePropsOnRenderContext(instance)\r\n  }\r\n  // 2. call setup()\r\n  const { setup } = Component\r\n  if (setup) {\r\n    const setupContext = (instance.setupContext =\r\n      setup.length > 1 ? createSetupContext(instance) : null)\r\n\r\n    setCurrentInstance(instance)\r\n    pauseTracking()\r\n    const setupResult = callWithErrorHandling(\r\n      setup,\r\n      instance,\r\n      ErrorCodes.SETUP_FUNCTION,\r\n      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]\r\n    )\r\n    resetTracking()\r\n    unsetCurrentInstance()\r\n\r\n    if (isPromise(setupResult)) {\r\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\r\n      if (isSSR) {\r\n        // return the promise so server-renderer can wait on it\r\n        return setupResult\r\n          .then((resolvedResult: unknown) => {\r\n            handleSetupResult(instance, resolvedResult, isSSR)\r\n          })\r\n          .catch(e => {\r\n            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)\r\n          })\r\n      } else if (__FEATURE_SUSPENSE__) {\r\n        // async setup returned Promise.\r\n        // bail here and wait for re-entry.\r\n        instance.asyncDep = setupResult\r\n        if (__DEV__ && !instance.suspense) {\r\n          const name = Component.name ?? 'Anonymous'\r\n          warn(\r\n            `Component <${name}>: setup function returned a promise, but no ` +\r\n              `<Suspense> boundary was found in the parent component tree. ` +\r\n              `A component with async setup() must be nested in a <Suspense> ` +\r\n              `in order to be rendered.`\r\n          )\r\n        }\r\n      } else if (__DEV__) {\r\n        warn(\r\n          `setup() returned a Promise, but the version of Vue you are using ` +\r\n            `does not support it yet.`\r\n        )\r\n      }\r\n    } else {\r\n      handleSetupResult(instance, setupResult, isSSR)\r\n    }\r\n  } else {\r\n    finishComponentSetup(instance, isSSR)\r\n  }\r\n}\r\n\r\nexport function handleSetupResult(\r\n  instance: ComponentInternalInstance,\r\n  setupResult: unknown,\r\n  isSSR: boolean\r\n) {\r\n  if (isFunction(setupResult)) {\r\n    // setup returned an inline render function\r\n    if (__SSR__ && (instance.type as ComponentOptions).__ssrInlineRender) {\r\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n      // set it as ssrRender instead.\r\n      instance.ssrRender = setupResult\r\n    } else {\r\n      instance.render = setupResult as InternalRenderFunction\r\n    }\r\n  } else if (isObject(setupResult)) {\r\n    if (__DEV__ && isVNode(setupResult)) {\r\n      warn(\r\n        `setup() should not return VNodes directly - ` +\r\n          `return a render function instead.`\r\n      )\r\n    }\r\n    // setup returned bindings.\r\n    // assuming a render function compiled from template is present.\r\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\r\n      instance.devtoolsRawSetupState = setupResult\r\n    }\r\n    instance.setupState = proxyRefs(setupResult)\r\n    if (__DEV__) {\r\n      exposeSetupStateOnRenderContext(instance)\r\n    }\r\n  } else if (__DEV__ && setupResult !== undefined) {\r\n    warn(\r\n      `setup() should return an object. Received: ${\r\n        setupResult === null ? 'null' : typeof setupResult\r\n      }`\r\n    )\r\n  }\r\n  finishComponentSetup(instance, isSSR)\r\n}\r\n\r\ntype CompileFunction = (\r\n  template: string | object,\r\n  options?: CompilerOptions\r\n) => InternalRenderFunction\r\n\r\nlet compile: CompileFunction | undefined\r\nlet installWithProxy: (i: ComponentInternalInstance) => void\r\n\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nexport function registerRuntimeCompiler(_compile: any) {\r\n  compile = _compile\r\n  installWithProxy = i => {\r\n    if (i.render!._rc) {\r\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\r\n    }\r\n  }\r\n}\r\n\r\n// dev only\r\nexport const isRuntimeOnly = () => !compile\r\n\r\nexport function finishComponentSetup(\r\n  instance: ComponentInternalInstance,\r\n  isSSR: boolean,\r\n  skipOptions?: boolean\r\n) {\r\n  const Component = instance.type as ComponentOptions\r\n\r\n  if (__COMPAT__) {\r\n    convertLegacyRenderFn(instance)\r\n\r\n    if (__DEV__ && Component.compatConfig) {\r\n      validateCompatConfig(Component.compatConfig)\r\n    }\r\n  }\r\n\r\n  // template / render function normalization\r\n  // could be already set when returned from setup()\r\n  if (!instance.render) {\r\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\r\n    // is done by server-renderer\r\n    if (!isSSR && compile && !Component.render) {\r\n      const template =\r\n        (__COMPAT__ &&\r\n          instance.vnode.props &&\r\n          instance.vnode.props['inline-template']) ||\r\n        Component.template ||\r\n        resolveMergedOptions(instance).template\r\n      if (template) {\r\n        if (__DEV__) {\r\n          startMeasure(instance, `compile`)\r\n        }\r\n        const { isCustomElement, compilerOptions } = instance.appContext.config\r\n        const { delimiters, compilerOptions: componentCompilerOptions } =\r\n          Component\r\n        const finalCompilerOptions: CompilerOptions = extend(\r\n          extend(\r\n            {\r\n              isCustomElement,\r\n              delimiters\r\n            },\r\n            compilerOptions\r\n          ),\r\n          componentCompilerOptions\r\n        )\r\n        if (__COMPAT__) {\r\n          // pass runtime compat config into the compiler\r\n          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)\r\n          if (Component.compatConfig) {\r\n            // @ts-expect-error types are not compatible\r\n            extend(finalCompilerOptions.compatConfig, Component.compatConfig)\r\n          }\r\n        }\r\n        Component.render = compile(template, finalCompilerOptions)\r\n        if (__DEV__) {\r\n          endMeasure(instance, `compile`)\r\n        }\r\n      }\r\n    }\r\n\r\n    instance.render = (Component.render || NOOP) as InternalRenderFunction\r\n\r\n    // for runtime-compiled render functions using `with` blocks, the render\r\n    // proxy used needs a different `has` handler which is more performant and\r\n    // also only allows a whitelist of globals to fallthrough.\r\n    if (installWithProxy) {\r\n      installWithProxy(instance)\r\n    }\r\n  }\r\n\r\n  // support for 2.x options\r\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\r\n    setCurrentInstance(instance)\r\n    pauseTracking()\r\n    try {\r\n      applyOptions(instance)\r\n    } finally {\r\n      resetTracking()\r\n      unsetCurrentInstance()\r\n    }\r\n  }\r\n\r\n  // warn missing template/render\r\n  // the runtime compilation of template in SSR is done by server-render\r\n  if (__DEV__ && !Component.render && instance.render === NOOP && !isSSR) {\r\n    /* istanbul ignore if */\r\n    if (!compile && Component.template) {\r\n      warn(\r\n        `Component provided template option but ` +\r\n          `runtime compilation is not supported in this build of Vue.` +\r\n          (__ESM_BUNDLER__\r\n            ? ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\r\n            : __ESM_BROWSER__\r\n              ? ` Use \"vue.esm-browser.js\" instead.`\r\n              : __GLOBAL__\r\n                ? ` Use \"vue.global.js\" instead.`\r\n                : ``) /* should not happen */\r\n      )\r\n    } else {\r\n      warn(`Component is missing template or render function.`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction getAttrsProxy(instance: ComponentInternalInstance): Data {\r\n  return (\r\n    instance.attrsProxy ||\r\n    (instance.attrsProxy = new Proxy(\r\n      instance.attrs,\r\n      __DEV__\r\n        ? {\r\n            get(target, key: string) {\r\n              markAttrsAccessed()\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            },\r\n            set() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            },\r\n            deleteProperty() {\r\n              warn(`setupContext.attrs is readonly.`)\r\n              return false\r\n            }\r\n          }\r\n        : {\r\n            get(target, key: string) {\r\n              track(instance, TrackOpTypes.GET, '$attrs')\r\n              return target[key]\r\n            }\r\n          }\r\n    ))\r\n  )\r\n}\r\n\r\n/**\r\n * Dev-only\r\n */\r\nfunction getSlotsProxy(instance: ComponentInternalInstance): Slots {\r\n  return (\r\n    instance.slotsProxy ||\r\n    (instance.slotsProxy = new Proxy(instance.slots, {\r\n      get(target, key: string) {\r\n        track(instance, TrackOpTypes.GET, '$slots')\r\n        return target[key]\r\n      }\r\n    }))\r\n  )\r\n}\r\n\r\nexport function createSetupContext(\r\n  instance: ComponentInternalInstance\r\n): SetupContext {\r\n  const expose: SetupContext['expose'] = exposed => {\r\n    if (__DEV__) {\r\n      if (instance.exposed) {\r\n        warn(`expose() should be called only once per setup().`)\r\n      }\r\n      if (exposed != null) {\r\n        let exposedType: string = typeof exposed\r\n        if (exposedType === 'object') {\r\n          if (isArray(exposed)) {\r\n            exposedType = 'array'\r\n          } else if (isRef(exposed)) {\r\n            exposedType = 'ref'\r\n          }\r\n        }\r\n        if (exposedType !== 'object') {\r\n          warn(\r\n            `expose() should be passed a plain object, received ${exposedType}.`\r\n          )\r\n        }\r\n      }\r\n    }\r\n    instance.exposed = exposed || {}\r\n  }\r\n\r\n  if (__DEV__) {\r\n    // We use getters in dev in case libs like test-utils overwrite instance\r\n    // properties (overwrites should not be done in prod)\r\n    return Object.freeze({\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      get slots() {\r\n        return getSlotsProxy(instance)\r\n      },\r\n      get emit() {\r\n        return (event: string, ...args: any[]) => instance.emit(event, ...args)\r\n      },\r\n      expose\r\n    })\r\n  } else {\r\n    return {\r\n      get attrs() {\r\n        return getAttrsProxy(instance)\r\n      },\r\n      slots: instance.slots,\r\n      emit: instance.emit,\r\n      expose\r\n    }\r\n  }\r\n}\r\n\r\nexport function getExposeProxy(instance: ComponentInternalInstance) {\r\n  if (instance.exposed) {\r\n    return (\r\n      instance.exposeProxy ||\r\n      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\r\n        get(target, key: string) {\r\n          if (key in target) {\r\n            return target[key]\r\n          } else if (key in publicPropertiesMap) {\r\n            return publicPropertiesMap[key](instance)\r\n          }\r\n        },\r\n        has(target, key: string) {\r\n          return key in target || key in publicPropertiesMap\r\n        }\r\n      }))\r\n    )\r\n  }\r\n}\r\n\r\nconst classifyRE = /(?:^|[-_])(\\w)/g\r\nconst classify = (str: string): string =>\r\n  str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')\r\n\r\nexport function getComponentName(\r\n  Component: ConcreteComponent,\r\n  includeInferred = true\r\n): string | false | undefined {\r\n  return isFunction(Component)\r\n    ? Component.displayName || Component.name\r\n    : Component.name || (includeInferred && Component.__name)\r\n}\r\n\r\n/* istanbul ignore next */\r\nexport function formatComponentName(\r\n  instance: ComponentInternalInstance | null,\r\n  Component: ConcreteComponent,\r\n  isRoot = false\r\n): string {\r\n  let name = getComponentName(Component)\r\n  if (!name && Component.__file) {\r\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/)\r\n    if (match) {\r\n      name = match[1]\r\n    }\r\n  }\r\n\r\n  if (!name && instance && instance.parent) {\r\n    // try to infer the name based on reverse resolution\r\n    const inferFromRegistry = (registry: Record<string, any> | undefined) => {\r\n      for (const key in registry) {\r\n        if (registry[key] === Component) {\r\n          return key\r\n        }\r\n      }\r\n    }\r\n    name =\r\n      inferFromRegistry(\r\n        instance.components ||\r\n          (instance.parent.type as ComponentOptions).components\r\n      ) || inferFromRegistry(instance.appContext.components)\r\n  }\r\n\r\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`\r\n}\r\n\r\nexport function isClassComponent(value: unknown): value is ClassComponent {\r\n  return isFunction(value) && '__vccOpts' in value\r\n}\r\n", "import { computed as _computed } from '@vue/reactivity'\r\nimport { isInSSRComponentSetup } from './component'\r\n\r\nexport const computed: typeof _computed = (\r\n  getterOrOptions: any,\r\n  debugOptions?: any\r\n) => {\r\n  // @ts-ignore\r\n  return _computed(getterOrOptions, debugOptions, isInSSRComponentSetup)\r\n}\r\n", "import {\r\n  VNode,\r\n  VNodeProps,\r\n  createVNode,\r\n  VNodeArrayChildren,\r\n  Fragment,\r\n  Text,\r\n  Comment,\r\n  isVNode\r\n} from './vnode'\r\nimport { Teleport, TeleportProps } from './components/Teleport'\r\nimport { Suspense, SuspenseProps } from './components/Suspense'\r\nimport { isObject, isArray } from '@vue/shared'\r\nimport { RawSlots } from './componentSlots'\r\nimport {\r\n  FunctionalComponent,\r\n  Component,\r\n  ComponentOptions,\r\n  ConcreteComponent\r\n} from './component'\r\nimport { EmitsOptions } from './componentEmits'\r\nimport { DefineComponent } from './apiDefineComponent'\r\n\r\n// `h` is a more user-friendly version of `createVNode` that allows omitting the\r\n// props when possible. It is intended for manually written render functions.\r\n// Compiler-generated code uses `createVNode` because\r\n// 1. it is monomorphic and avoids the extra call overhead\r\n// 2. it allows specifying patchFlags for optimization\r\n\r\n/*\r\n// type only\r\nh('div')\r\n\r\n// type + props\r\nh('div', {})\r\n\r\n// type + omit props + children\r\n// Omit props does NOT support named slots\r\nh('div', []) // array\r\nh('div', 'foo') // text\r\nh('div', h('br')) // vnode\r\nh(Component, () => {}) // default slot\r\n\r\n// type + props + children\r\nh('div', {}, []) // array\r\nh('div', {}, 'foo') // text\r\nh('div', {}, h('br')) // vnode\r\nh(Component, {}, () => {}) // default slot\r\nh(Component, {}, {}) // named slots\r\n\r\n// named slots without props requires explicit `null` to avoid ambiguity\r\nh(Component, null, {})\r\n**/\r\n\r\ntype RawProps = VNodeProps & {\r\n  // used to differ from a single VNode object as children\r\n  __v_isVNode?: never\r\n  // used to differ from Array children\r\n  [Symbol.iterator]?: never\r\n} & Record<string, any>\r\n\r\ntype RawChildren =\r\n  | string\r\n  | number\r\n  | boolean\r\n  | VNode\r\n  | VNodeArrayChildren\r\n  | (() => any)\r\n\r\n// fake constructor type returned from `defineComponent`\r\ninterface Constructor<P = any> {\r\n  __isFragment?: never\r\n  __isTeleport?: never\r\n  __isSuspense?: never\r\n  new (...args: any[]): { $props: P }\r\n}\r\n\r\n// The following is a series of overloads for providing props validation of\r\n// manually written render functions.\r\n\r\n// element\r\nexport function h(type: string, children?: RawChildren): VNode\r\nexport function h(\r\n  type: string,\r\n  props?: RawProps | null,\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// text/comment\r\nexport function h(\r\n  type: typeof Text | typeof Comment,\r\n  children?: string | number | boolean\r\n): VNode\r\nexport function h(\r\n  type: typeof Text | typeof Comment,\r\n  props?: null,\r\n  children?: string | number | boolean\r\n): VNode\r\n// fragment\r\nexport function h(type: typeof Fragment, children?: VNodeArrayChildren): VNode\r\nexport function h(\r\n  type: typeof Fragment,\r\n  props?: RawProps | null,\r\n  children?: VNodeArrayChildren\r\n): VNode\r\n\r\n// teleport (target prop is required)\r\nexport function h(\r\n  type: typeof Teleport,\r\n  props: RawProps & TeleportProps,\r\n  children: RawChildren | RawSlots\r\n): VNode\r\n\r\n// suspense\r\nexport function h(type: typeof Suspense, children?: RawChildren): VNode\r\nexport function h(\r\n  type: typeof Suspense,\r\n  props?: (RawProps & SuspenseProps) | null,\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// functional component\r\nexport function h<\r\n  P,\r\n  E extends EmitsOptions = {},\r\n  S extends Record<string, any> = {}\r\n>(\r\n  type: FunctionalComponent<P, E, S>,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// catch-all for generic component types\r\nexport function h(type: Component, children?: RawChildren): VNode\r\n\r\n// concrete component\r\nexport function h<P>(\r\n  type: ConcreteComponent | string,\r\n  children?: RawChildren\r\n): VNode\r\nexport function h<P>(\r\n  type: ConcreteComponent<P> | string,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren\r\n): VNode\r\n\r\n// component without props\r\nexport function h<P>(\r\n  type: Component<P>,\r\n  props?: (RawProps & P) | null,\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// exclude `defineComponent` constructors\r\nexport function h<P>(\r\n  type: ComponentOptions<P>,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// fake constructor type returned by `defineComponent` or class component\r\nexport function h(type: Constructor, children?: RawChildren): VNode\r\nexport function h<P>(\r\n  type: Constructor<P>,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// fake constructor type returned by `defineComponent`\r\nexport function h(type: DefineComponent, children?: RawChildren): VNode\r\nexport function h<P>(\r\n  type: DefineComponent<P>,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// catch all types\r\nexport function h(type: string | Component, children?: RawChildren): VNode\r\nexport function h<P>(\r\n  type: string | Component<P>,\r\n  props?: (RawProps & P) | ({} extends P ? null : never),\r\n  children?: RawChildren | RawSlots\r\n): VNode\r\n\r\n// Actual implementation\r\nexport function h(type: any, propsOrChildren?: any, children?: any): VNode {\r\n  const l = arguments.length\r\n  if (l === 2) {\r\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\r\n      // single vnode without props\r\n      if (isVNode(propsOrChildren)) {\r\n        return createVNode(type, null, [propsOrChildren])\r\n      }\r\n      // props without children\r\n      return createVNode(type, propsOrChildren)\r\n    } else {\r\n      // omit props\r\n      return createVNode(type, null, propsOrChildren)\r\n    }\r\n  } else {\r\n    if (l > 3) {\r\n      children = Array.prototype.slice.call(arguments, 2)\r\n    } else if (l === 3 && isVNode(children)) {\r\n      children = [children]\r\n    }\r\n    return createVNode(type, propsOrChildren, children)\r\n  }\r\n}\r\n", "import { inject } from '../apiInject'\r\nimport { warn } from '../warning'\r\n\r\nexport const ssrContextKey = Symbol.for('v-scx')\r\n\r\nexport const useSSRContext = <T = Record<string, any>>() => {\r\n  if (!__GLOBAL__) {\r\n    const ctx = inject<T>(ssrContextKey)\r\n    if (!ctx) {\r\n      __DEV__ &&\r\n        warn(\r\n          `Server rendering context not provided. Make sure to only call ` +\r\n            `useSSRContext() conditionally in the server build.`\r\n        )\r\n    }\r\n    return ctx\r\n  } else if (__DEV__) {\r\n    warn(`useSSRContext() is not supported in the global build.`)\r\n  }\r\n}\r\n", "import { isReactive, isReadonly, isRef, Ref, toRaw } from '@vue/reactivity'\r\nimport { EMPTY_OBJ, extend, isArray, isFunction, isObject } from '@vue/shared'\r\nimport { isShallow } from '../../reactivity/src/reactive'\r\nimport { ComponentInternalInstance, ComponentOptions } from './component'\r\nimport { ComponentPublicInstance } from './componentPublicInstance'\r\n\r\nexport function initCustomFormatter() {\r\n  /* eslint-disable no-restricted-globals */\r\n  if (!__DEV__ || typeof window === 'undefined') {\r\n    return\r\n  }\r\n\r\n  const vueStyle = { style: 'color:#3ba776' }\r\n  const numberStyle = { style: 'color:#1677ff' }\r\n  const stringStyle = { style: 'color:#f5222d' }\r\n  const keywordStyle = { style: 'color:#eb2f96' }\r\n\r\n  // custom formatter for Chrome\r\n  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\r\n  const formatter = {\r\n    header(obj: unknown) {\r\n      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\r\n      if (!isObject(obj)) {\r\n        return null\r\n      }\r\n\r\n      if (obj.__isVue) {\r\n        return ['div', vueStyle, `VueInstance`]\r\n      } else if (isRef(obj)) {\r\n        return [\r\n          'div',\r\n          {},\r\n          ['span', vueStyle, genRefFlag(obj)],\r\n          '<',\r\n          formatValue(obj.value),\r\n          `>`\r\n        ]\r\n      } else if (isReactive(obj)) {\r\n        return [\r\n          'div',\r\n          {},\r\n          ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\r\n          '<',\r\n          formatValue(obj),\r\n          `>${isReadonly(obj) ? ` (readonly)` : ``}`\r\n        ]\r\n      } else if (isReadonly(obj)) {\r\n        return [\r\n          'div',\r\n          {},\r\n          ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\r\n          '<',\r\n          formatValue(obj),\r\n          '>'\r\n        ]\r\n      }\r\n      return null\r\n    },\r\n    hasBody(obj: unknown) {\r\n      return obj && (obj as any).__isVue\r\n    },\r\n    body(obj: unknown) {\r\n      if (obj && (obj as any).__isVue) {\r\n        return [\r\n          'div',\r\n          {},\r\n          ...formatInstance((obj as ComponentPublicInstance).$)\r\n        ]\r\n      }\r\n    }\r\n  }\r\n\r\n  function formatInstance(instance: ComponentInternalInstance) {\r\n    const blocks = []\r\n    if (instance.type.props && instance.props) {\r\n      blocks.push(createInstanceBlock('props', toRaw(instance.props)))\r\n    }\r\n    if (instance.setupState !== EMPTY_OBJ) {\r\n      blocks.push(createInstanceBlock('setup', instance.setupState))\r\n    }\r\n    if (instance.data !== EMPTY_OBJ) {\r\n      blocks.push(createInstanceBlock('data', toRaw(instance.data)))\r\n    }\r\n    const computed = extractKeys(instance, 'computed')\r\n    if (computed) {\r\n      blocks.push(createInstanceBlock('computed', computed))\r\n    }\r\n    const injected = extractKeys(instance, 'inject')\r\n    if (injected) {\r\n      blocks.push(createInstanceBlock('injected', injected))\r\n    }\r\n\r\n    blocks.push([\r\n      'div',\r\n      {},\r\n      [\r\n        'span',\r\n        {\r\n          style: keywordStyle.style + ';opacity:0.66'\r\n        },\r\n        '$ (internal): '\r\n      ],\r\n      ['object', { object: instance }]\r\n    ])\r\n    return blocks\r\n  }\r\n\r\n  function createInstanceBlock(type: string, target: any) {\r\n    target = extend({}, target)\r\n    if (!Object.keys(target).length) {\r\n      return ['span', {}]\r\n    }\r\n    return [\r\n      'div',\r\n      { style: 'line-height:1.25em;margin-bottom:0.6em' },\r\n      [\r\n        'div',\r\n        {\r\n          style: 'color:#476582'\r\n        },\r\n        type\r\n      ],\r\n      [\r\n        'div',\r\n        {\r\n          style: 'padding-left:1.25em'\r\n        },\r\n        ...Object.keys(target).map(key => {\r\n          return [\r\n            'div',\r\n            {},\r\n            ['span', keywordStyle, key + ': '],\r\n            formatValue(target[key], false)\r\n          ]\r\n        })\r\n      ]\r\n    ]\r\n  }\r\n\r\n  function formatValue(v: unknown, asRaw = true) {\r\n    if (typeof v === 'number') {\r\n      return ['span', numberStyle, v]\r\n    } else if (typeof v === 'string') {\r\n      return ['span', stringStyle, JSON.stringify(v)]\r\n    } else if (typeof v === 'boolean') {\r\n      return ['span', keywordStyle, v]\r\n    } else if (isObject(v)) {\r\n      return ['object', { object: asRaw ? toRaw(v) : v }]\r\n    } else {\r\n      return ['span', stringStyle, String(v)]\r\n    }\r\n  }\r\n\r\n  function extractKeys(instance: ComponentInternalInstance, type: string) {\r\n    const Comp = instance.type\r\n    if (isFunction(Comp)) {\r\n      return\r\n    }\r\n    const extracted: Record<string, any> = {}\r\n    for (const key in instance.ctx) {\r\n      if (isKeyOfType(Comp, key, type)) {\r\n        extracted[key] = instance.ctx[key]\r\n      }\r\n    }\r\n    return extracted\r\n  }\r\n\r\n  function isKeyOfType(Comp: ComponentOptions, key: string, type: string) {\r\n    const opts = Comp[type]\r\n    if (\r\n      (isArray(opts) && opts.includes(key)) ||\r\n      (isObject(opts) && key in opts)\r\n    ) {\r\n      return true\r\n    }\r\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\r\n      return true\r\n    }\r\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  function genRefFlag(v: Ref) {\r\n    if (isShallow(v)) {\r\n      return `ShallowRef`\r\n    }\r\n    if ((v as any).effect) {\r\n      return `ComputedRef`\r\n    }\r\n    return `Ref`\r\n  }\r\n\r\n  if ((window as any).devtoolsFormatters) {\r\n    ;(window as any).devtoolsFormatters.push(formatter)\r\n  } else {\r\n    ;(window as any).devtoolsFormatters = [formatter]\r\n  }\r\n}\r\n", "import { hasChanged } from '@vue/shared'\r\nimport { currentBlock, isBlockTreeEnabled, VNode } from '../vnode'\r\n\r\nexport function withMemo(\r\n  memo: any[],\r\n  render: () => VNode<any, any>,\r\n  cache: any[],\r\n  index: number\r\n) {\r\n  const cached = cache[index] as VNode | undefined\r\n  if (cached && isMemoSame(cached, memo)) {\r\n    return cached\r\n  }\r\n  const ret = render()\r\n\r\n  // shallow clone\r\n  ret.memo = memo.slice()\r\n  return (cache[index] = ret)\r\n}\r\n\r\nexport function isMemoSame(cached: VNode, memo: any[]) {\r\n  const prev: any[] = cached.memo!\r\n  if (prev.length != memo.length) {\r\n    return false\r\n  }\r\n\r\n  for (let i = 0; i < prev.length; i++) {\r\n    if (hasChanged(prev[i], memo[i])) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  // make sure to let parent block track it when returning cached\r\n  if (isBlockTreeEnabled > 0 && currentBlock) {\r\n    currentBlock.push(cached)\r\n  }\r\n  return true\r\n}\r\n", "// Core API ------------------------------------------------------------------\r\n\r\nexport const version = __VERSION__\r\nexport {\r\n  // core\r\n  reactive,\r\n  ref,\r\n  readonly,\r\n  // utilities\r\n  unref,\r\n  proxyRefs,\r\n  isRef,\r\n  toRef,\r\n  toValue,\r\n  toRefs,\r\n  isProxy,\r\n  isReactive,\r\n  isReadonly,\r\n  isShallow,\r\n  // advanced\r\n  customRef,\r\n  triggerRef,\r\n  shallowRef,\r\n  shallowReactive,\r\n  shallowReadonly,\r\n  markRaw,\r\n  toRaw,\r\n  // effect\r\n  effect,\r\n  stop,\r\n  ReactiveEffect,\r\n  // effect scope\r\n  effectScope,\r\n  EffectScope,\r\n  getCurrentScope,\r\n  onScopeDispose\r\n} from '@vue/reactivity'\r\nexport { computed } from './apiComputed'\r\nexport {\r\n  watch,\r\n  watchEffect,\r\n  watchPostEffect,\r\n  watchSyncEffect\r\n} from './apiWatch'\r\nexport {\r\n  onBeforeMount,\r\n  onMounted,\r\n  onBeforeUpdate,\r\n  onUpdated,\r\n  onBeforeUnmount,\r\n  onUnmounted,\r\n  onActivated,\r\n  onDeactivated,\r\n  onRenderTracked,\r\n  onRenderTriggered,\r\n  onErrorCaptured,\r\n  onServerPrefetch\r\n} from './apiLifecycle'\r\nexport { provide, inject, hasInjectionContext } from './apiInject'\r\nexport { nextTick } from './scheduler'\r\nexport { defineComponent } from './apiDefineComponent'\r\nexport { defineAsyncComponent } from './apiAsyncComponent'\r\nexport { useAttrs, useSlots } from './apiSetupHelpers'\r\n\r\n// <script setup> API ----------------------------------------------------------\r\n\r\nexport {\r\n  // macros runtime, for typing and warnings only\r\n  defineProps,\r\n  defineEmits,\r\n  defineExpose,\r\n  defineOptions,\r\n  defineSlots,\r\n  defineModel,\r\n  withDefaults,\r\n  useModel\r\n} from './apiSetupHelpers'\r\n\r\n/**\r\n * @internal\r\n */\r\nexport {\r\n  mergeDefaults,\r\n  mergeModels,\r\n  createPropsRestProxy,\r\n  withAsyncContext\r\n} from './apiSetupHelpers'\r\n\r\n// Advanced API ----------------------------------------------------------------\r\n\r\n// For getting a hold of the internal instance in setup() - useful for advanced\r\n// plugins\r\nexport { getCurrentInstance } from './component'\r\n\r\n// For raw render function users\r\nexport { h } from './h'\r\n// Advanced render function utilities\r\nexport { createVNode, cloneVNode, mergeProps, isVNode } from './vnode'\r\n// VNode types\r\nexport { Fragment, Text, Comment, Static, type VNodeRef } from './vnode'\r\n// Built-in components\r\nexport { Teleport, type TeleportProps } from './components/Teleport'\r\nexport { Suspense, type SuspenseProps } from './components/Suspense'\r\nexport { KeepAlive, type KeepAliveProps } from './components/KeepAlive'\r\nexport {\r\n  BaseTransition,\r\n  BaseTransitionPropsValidators,\r\n  type BaseTransitionProps\r\n} from './components/BaseTransition'\r\n// For using custom directives\r\nexport { withDirectives } from './directives'\r\n// SSR context\r\nexport { useSSRContext, ssrContextKey } from './helpers/useSsrContext'\r\n\r\n// Custom Renderer API ---------------------------------------------------------\r\n\r\nexport { createRenderer, createHydrationRenderer } from './renderer'\r\nexport { queuePostFlushCb } from './scheduler'\r\nexport { warn } from './warning'\r\n/** @internal */\r\nexport { assertNumber } from './warning'\r\nexport {\r\n  handleError,\r\n  callWithErrorHandling,\r\n  callWithAsyncErrorHandling,\r\n  ErrorCodes\r\n} from './errorHandling'\r\nexport {\r\n  resolveComponent,\r\n  resolveDirective,\r\n  resolveDynamicComponent\r\n} from './helpers/resolveAssets'\r\n// For integration with runtime compiler\r\nexport { registerRuntimeCompiler, isRuntimeOnly } from './component'\r\nexport {\r\n  useTransitionState,\r\n  resolveTransitionHooks,\r\n  setTransitionHooks,\r\n  getTransitionRawChildren\r\n} from './components/BaseTransition'\r\nexport { initCustomFormatter } from './customFormatter'\r\n\r\n// For devtools\r\nexport { devtools, setDevtoolsHook } from './devtools'\r\n\r\n// Types -------------------------------------------------------------------------\r\n\r\nimport { VNode } from './vnode'\r\nimport { ComponentInternalInstance } from './component'\r\n\r\n// Augment Ref unwrap bail types.\r\ndeclare module '@vue/reactivity' {\r\n  export interface RefUnwrapBailTypes {\r\n    runtimeCoreBailTypes:\r\n      | VNode\r\n      | {\r\n          // directly bailing on ComponentPublicInstance results in recursion\r\n          // so we use this as a bail hint\r\n          $: ComponentInternalInstance\r\n        }\r\n  }\r\n}\r\n\r\nexport { TrackOpTypes, TriggerOpTypes } from '@vue/reactivity'\r\nexport type {\r\n  Ref,\r\n  MaybeRef,\r\n  MaybeRefOrGetter,\r\n  ToRef,\r\n  ToRefs,\r\n  UnwrapRef,\r\n  ShallowRef,\r\n  ShallowUnwrapRef,\r\n  CustomRefFactory,\r\n  ReactiveFlags,\r\n  DeepReadonly,\r\n  ShallowReactive,\r\n  UnwrapNestedRefs,\r\n  ComputedRef,\r\n  WritableComputedRef,\r\n  WritableComputedOptions,\r\n  ComputedGetter,\r\n  ComputedSetter,\r\n  ReactiveEffectRunner,\r\n  ReactiveEffectOptions,\r\n  EffectScheduler,\r\n  DebuggerOptions,\r\n  DebuggerEvent,\r\n  DebuggerEventExtraInfo,\r\n  Raw\r\n} from '@vue/reactivity'\r\nexport type {\r\n  WatchEffect,\r\n  WatchOptions,\r\n  WatchOptionsBase,\r\n  WatchCallback,\r\n  WatchSource,\r\n  WatchStopHandle\r\n} from './apiWatch'\r\nexport type { InjectionKey } from './apiInject'\r\nexport type {\r\n  App,\r\n  AppConfig,\r\n  AppContext,\r\n  Plugin,\r\n  CreateAppFunction,\r\n  OptionMergeFunction\r\n} from './apiCreateApp'\r\nexport type {\r\n  VNode,\r\n  VNodeChild,\r\n  VNodeTypes,\r\n  VNodeProps,\r\n  VNodeArrayChildren,\r\n  VNodeNormalizedChildren\r\n} from './vnode'\r\nexport type {\r\n  Component,\r\n  ConcreteComponent,\r\n  FunctionalComponent,\r\n  ComponentInternalInstance,\r\n  SetupContext,\r\n  ComponentCustomProps,\r\n  AllowedComponentProps\r\n} from './component'\r\nexport type { DefineComponent } from './apiDefineComponent'\r\nexport type {\r\n  ComponentOptions,\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithoutProps,\r\n  ComponentOptionsWithObjectProps,\r\n  ComponentOptionsWithArrayProps,\r\n  ComponentCustomOptions,\r\n  ComponentOptionsBase,\r\n  ComponentProvideOptions,\r\n  RenderFunction,\r\n  MethodOptions,\r\n  ComputedOptions,\r\n  RuntimeCompilerOptions,\r\n  ComponentInjectOptions\r\n} from './componentOptions'\r\nexport type { EmitsOptions, ObjectEmitsOptions } from './componentEmits'\r\nexport type {\r\n  ComponentPublicInstance,\r\n  ComponentCustomProperties,\r\n  CreateComponentPublicInstance\r\n} from './componentPublicInstance'\r\nexport type {\r\n  Renderer,\r\n  RendererNode,\r\n  RendererElement,\r\n  HydrationRenderer,\r\n  RendererOptions,\r\n  RootRenderFunction\r\n} from './renderer'\r\nexport type { RootHydrateFunction } from './hydration'\r\nexport type { Slot, Slots, SlotsType } from './componentSlots'\r\nexport type {\r\n  Prop,\r\n  PropType,\r\n  ComponentPropsOptions,\r\n  ComponentObjectPropsOptions,\r\n  ExtractPropTypes,\r\n  ExtractPublicPropTypes,\r\n  ExtractDefaultPropTypes\r\n} from './componentProps'\r\nexport type {\r\n  Directive,\r\n  DirectiveBinding,\r\n  DirectiveHook,\r\n  ObjectDirective,\r\n  FunctionDirective,\r\n  DirectiveArguments\r\n} from './directives'\r\nexport type { SuspenseBoundary } from './components/Suspense'\r\nexport type {\r\n  TransitionState,\r\n  TransitionHooks\r\n} from './components/BaseTransition'\r\nexport type {\r\n  AsyncComponentOptions,\r\n  AsyncComponentLoader\r\n} from './apiAsyncComponent'\r\nexport type { HMRRuntime } from './hmr'\r\n\r\n// Internal API ----------------------------------------------------------------\r\n\r\n// **IMPORTANT** Internal APIs may change without notice between versions and\r\n// user code should avoid relying on them.\r\n\r\n// For compiler generated code\r\n// should sync with '@vue/compiler-core/src/runtimeHelpers.ts'\r\nexport {\r\n  withCtx,\r\n  pushScopeId,\r\n  popScopeId,\r\n  withScopeId\r\n} from './componentRenderContext'\r\nexport { renderList } from './helpers/renderList'\r\nexport { toHandlers } from './helpers/toHandlers'\r\nexport { renderSlot } from './helpers/renderSlot'\r\nexport { createSlots } from './helpers/createSlots'\r\nexport { withMemo, isMemoSame } from './helpers/withMemo'\r\nexport {\r\n  openBlock,\r\n  createBlock,\r\n  setBlockTracking,\r\n  createTextVNode,\r\n  createCommentVNode,\r\n  createStaticVNode,\r\n  createElementVNode,\r\n  createElementBlock,\r\n  guardReactiveProps\r\n} from './vnode'\r\nexport {\r\n  toDisplayString,\r\n  camelize,\r\n  capitalize,\r\n  toHandlerKey,\r\n  normalizeProps,\r\n  normalizeClass,\r\n  normalizeStyle\r\n} from '@vue/shared'\r\n\r\n// For test-utils\r\nexport { transformVNodeArgs } from './vnode'\r\n\r\n// SSR -------------------------------------------------------------------------\r\n\r\n// **IMPORTANT** These APIs are exposed solely for @vue/server-renderer and may\r\n// change without notice between versions. User code should never rely on them.\r\n\r\nimport { createComponentInstance, setupComponent } from './component'\r\nimport { renderComponentRoot } from './componentRenderUtils'\r\nimport { setCurrentRenderingInstance } from './componentRenderContext'\r\nimport { isVNode, normalizeVNode } from './vnode'\r\n\r\nconst _ssrUtils = {\r\n  createComponentInstance,\r\n  setupComponent,\r\n  renderComponentRoot,\r\n  setCurrentRenderingInstance,\r\n  isVNode,\r\n  normalizeVNode\r\n}\r\n\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\r\n * @internal\r\n */\r\nexport const ssrUtils = (__SSR__ ? _ssrUtils : null) as typeof _ssrUtils\r\n\r\n// 2.x COMPAT ------------------------------------------------------------------\r\n\r\nexport { DeprecationTypes } from './compat/compatConfig'\r\nexport type { CompatVue } from './compat/global'\r\nexport type { LegacyConfig } from './compat/globalConfig'\r\n\r\nimport { warnDeprecation } from './compat/compatConfig'\r\nimport { createCompatVue } from './compat/global'\r\nimport {\r\n  isCompatEnabled,\r\n  checkCompatEnabled,\r\n  softAssertCompatEnabled\r\n} from './compat/compatConfig'\r\nimport { resolveFilter as _resolveFilter } from './helpers/resolveAssets'\r\n\r\n/**\r\n * @internal only exposed in compat builds\r\n */\r\nexport const resolveFilter = __COMPAT__ ? _resolveFilter : null\r\n\r\nconst _compatUtils = {\r\n  warnDeprecation,\r\n  createCompatVue,\r\n  isCompatEnabled,\r\n  checkCompatEnabled,\r\n  softAssertCompatEnabled\r\n}\r\n\r\n/**\r\n * @internal only exposed in compat builds.\r\n */\r\nexport const compatUtils = (\r\n  __COMPAT__ ? _compatUtils : null\r\n) as typeof _compatUtils\r\n", "import { RendererOptions } from '@vue/runtime-core'\r\n\r\nexport const svgNS = 'http://www.w3.org/2000/svg'\r\n\r\nconst doc = (typeof document !== 'undefined' ? document : null) as Document\r\n\r\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template')\r\n\r\nexport const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {\r\n  insert: (child, parent, anchor) => {\r\n    parent.insertBefore(child, anchor || null)\r\n  },\r\n\r\n  remove: child => {\r\n    const parent = child.parentNode\r\n    if (parent) {\r\n      parent.removeChild(child)\r\n    }\r\n  },\r\n\r\n  createElement: (tag, isSVG, is, props): Element => {\r\n    const el = isSVG\r\n      ? doc.createElementNS(svgNS, tag)\r\n      : doc.createElement(tag, is ? { is } : undefined)\r\n\r\n    if (tag === 'select' && props && props.multiple != null) {\r\n      ;(el as HTMLSelectElement).setAttribute('multiple', props.multiple)\r\n    }\r\n\r\n    return el\r\n  },\r\n\r\n  createText: text => doc.createTextNode(text),\r\n\r\n  createComment: text => doc.createComment(text),\r\n\r\n  setText: (node, text) => {\r\n    node.nodeValue = text\r\n  },\r\n\r\n  setElementText: (el, text) => {\r\n    el.textContent = text\r\n  },\r\n\r\n  parentNode: node => node.parentNode as Element | null,\r\n\r\n  nextSibling: node => node.nextSibling,\r\n\r\n  querySelector: selector => doc.querySelector(selector),\r\n\r\n  setScopeId(el, id) {\r\n    el.setAttribute(id, '')\r\n  },\r\n\r\n  // __UNSAFE__\r\n  // Reason: innerHTML.\r\n  // Static content here can only come from compiled templates.\r\n  // As long as the user only uses trusted templates, this is safe.\r\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\r\n    // <parent> before | first ... last | anchor </parent>\r\n    const before = anchor ? anchor.previousSibling : parent.lastChild\r\n    // #5308 can only take cached path if:\r\n    // - has a single root node\r\n    // - nextSibling info is still available\r\n    if (start && (start === end || start.nextSibling)) {\r\n      // cached\r\n      while (true) {\r\n        parent.insertBefore(start!.cloneNode(true), anchor)\r\n        if (start === end || !(start = start!.nextSibling)) break\r\n      }\r\n    } else {\r\n      // fresh insert\r\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content\r\n      const template = templateContainer.content\r\n      if (isSVG) {\r\n        // remove outer svg wrapper\r\n        const wrapper = template.firstChild!\r\n        while (wrapper.firstChild) {\r\n          template.appendChild(wrapper.firstChild)\r\n        }\r\n        template.removeChild(wrapper)\r\n      }\r\n      parent.insertBefore(template, anchor)\r\n    }\r\n    return [\r\n      // first\r\n      before ? before.nextSibling! : parent.firstChild!,\r\n      // last\r\n      anchor ? anchor.previousSibling! : parent.lastChild!\r\n    ]\r\n  }\r\n}\r\n", "import {\r\n  BaseTransition,\r\n  BaseTransitionProps,\r\n  BaseTransitionPropsValidators,\r\n  h,\r\n  assertNumber,\r\n  FunctionalComponent,\r\n  compatUtils,\r\n  DeprecationTypes\r\n} from '@vue/runtime-core'\r\nimport { isObject, toNumber, extend, isArray } from '@vue/shared'\r\n\r\nconst TRANSITION = 'transition'\r\nconst ANIMATION = 'animation'\r\n\r\ntype AnimationTypes = typeof TRANSITION | typeof ANIMATION\r\n\r\nexport interface TransitionProps extends BaseTransitionProps<Element> {\r\n  name?: string\r\n  type?: AnimationTypes\r\n  css?: boolean\r\n  duration?: number | { enter: number; leave: number }\r\n  // custom transition classes\r\n  enterFromClass?: string\r\n  enterActiveClass?: string\r\n  enterToClass?: string\r\n  appearFromClass?: string\r\n  appearActiveClass?: string\r\n  appearToClass?: string\r\n  leaveFromClass?: string\r\n  leaveActiveClass?: string\r\n  leaveToClass?: string\r\n}\r\n\r\nexport const vtcKey = Symbol('_vtc')\r\n\r\nexport interface ElementWithTransition extends HTMLElement {\r\n  // _vtc = Vue Transition Classes.\r\n  // Store the temporarily-added transition classes on the element\r\n  // so that we can avoid overwriting them if the element's class is patched\r\n  // during the transition.\r\n  [vtcKey]?: Set<string>\r\n}\r\n\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nexport const Transition: FunctionalComponent<TransitionProps> = (\r\n  props,\r\n  { slots }\r\n) => h(BaseTransition, resolveTransitionProps(props), slots)\r\n\r\nTransition.displayName = 'Transition'\r\n\r\nif (__COMPAT__) {\r\n  Transition.__isBuiltIn = true\r\n}\r\n\r\nconst DOMTransitionPropsValidators = {\r\n  name: String,\r\n  type: String,\r\n  css: {\r\n    type: Boolean,\r\n    default: true\r\n  },\r\n  duration: [String, Number, Object],\r\n  enterFromClass: String,\r\n  enterActiveClass: String,\r\n  enterToClass: String,\r\n  appearFromClass: String,\r\n  appearActiveClass: String,\r\n  appearToClass: String,\r\n  leaveFromClass: String,\r\n  leaveActiveClass: String,\r\n  leaveToClass: String\r\n}\r\n\r\nexport const TransitionPropsValidators = (Transition.props =\r\n  /*#__PURE__*/ extend(\r\n    {},\r\n    BaseTransitionPropsValidators as any,\r\n    DOMTransitionPropsValidators\r\n  ))\r\n\r\n/**\r\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\r\n * with custom HOCs.\r\n */\r\nconst callHook = (\r\n  hook: Function | Function[] | undefined,\r\n  args: any[] = []\r\n) => {\r\n  if (isArray(hook)) {\r\n    hook.forEach(h => h(...args))\r\n  } else if (hook) {\r\n    hook(...args)\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a hook expects a callback (2nd arg), which means the user\r\n * intends to explicitly control the end of the transition.\r\n */\r\nconst hasExplicitCallback = (\r\n  hook: Function | Function[] | undefined\r\n): boolean => {\r\n  return hook\r\n    ? isArray(hook)\r\n      ? hook.some(h => h.length > 1)\r\n      : hook.length > 1\r\n    : false\r\n}\r\n\r\nexport function resolveTransitionProps(\r\n  rawProps: TransitionProps\r\n): BaseTransitionProps<Element> {\r\n  const baseProps: BaseTransitionProps<Element> = {}\r\n  for (const key in rawProps) {\r\n    if (!(key in DOMTransitionPropsValidators)) {\r\n      ;(baseProps as any)[key] = (rawProps as any)[key]\r\n    }\r\n  }\r\n\r\n  if (rawProps.css === false) {\r\n    return baseProps\r\n  }\r\n\r\n  const {\r\n    name = 'v',\r\n    type,\r\n    duration,\r\n    enterFromClass = `${name}-enter-from`,\r\n    enterActiveClass = `${name}-enter-active`,\r\n    enterToClass = `${name}-enter-to`,\r\n    appearFromClass = enterFromClass,\r\n    appearActiveClass = enterActiveClass,\r\n    appearToClass = enterToClass,\r\n    leaveFromClass = `${name}-leave-from`,\r\n    leaveActiveClass = `${name}-leave-active`,\r\n    leaveToClass = `${name}-leave-to`\r\n  } = rawProps\r\n\r\n  // legacy transition class compat\r\n  const legacyClassEnabled =\r\n    __COMPAT__ &&\r\n    compatUtils.isCompatEnabled(DeprecationTypes.TRANSITION_CLASSES, null)\r\n  let legacyEnterFromClass: string\r\n  let legacyAppearFromClass: string\r\n  let legacyLeaveFromClass: string\r\n  if (__COMPAT__ && legacyClassEnabled) {\r\n    const toLegacyClass = (cls: string) => cls.replace(/-from$/, '')\r\n    if (!rawProps.enterFromClass) {\r\n      legacyEnterFromClass = toLegacyClass(enterFromClass)\r\n    }\r\n    if (!rawProps.appearFromClass) {\r\n      legacyAppearFromClass = toLegacyClass(appearFromClass)\r\n    }\r\n    if (!rawProps.leaveFromClass) {\r\n      legacyLeaveFromClass = toLegacyClass(leaveFromClass)\r\n    }\r\n  }\r\n\r\n  const durations = normalizeDuration(duration)\r\n  const enterDuration = durations && durations[0]\r\n  const leaveDuration = durations && durations[1]\r\n  const {\r\n    onBeforeEnter,\r\n    onEnter,\r\n    onEnterCancelled,\r\n    onLeave,\r\n    onLeaveCancelled,\r\n    onBeforeAppear = onBeforeEnter,\r\n    onAppear = onEnter,\r\n    onAppearCancelled = onEnterCancelled\r\n  } = baseProps\r\n\r\n  const finishEnter = (el: Element, isAppear: boolean, done?: () => void) => {\r\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass)\r\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass)\r\n    done && done()\r\n  }\r\n\r\n  const finishLeave = (\r\n    el: Element & { _isLeaving?: boolean },\r\n    done?: () => void\r\n  ) => {\r\n    el._isLeaving = false\r\n    removeTransitionClass(el, leaveFromClass)\r\n    removeTransitionClass(el, leaveToClass)\r\n    removeTransitionClass(el, leaveActiveClass)\r\n    done && done()\r\n  }\r\n\r\n  const makeEnterHook = (isAppear: boolean) => {\r\n    return (el: Element, done: () => void) => {\r\n      const hook = isAppear ? onAppear : onEnter\r\n      const resolve = () => finishEnter(el, isAppear, done)\r\n      callHook(hook, [el, resolve])\r\n      nextFrame(() => {\r\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass)\r\n        if (__COMPAT__ && legacyClassEnabled) {\r\n          const legacyClass = isAppear\r\n            ? legacyAppearFromClass\r\n            : legacyEnterFromClass\r\n          if (legacyClass) {\r\n            removeTransitionClass(el, legacyClass)\r\n          }\r\n        }\r\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass)\r\n        if (!hasExplicitCallback(hook)) {\r\n          whenTransitionEnds(el, type, enterDuration, resolve)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  return extend(baseProps, {\r\n    onBeforeEnter(el) {\r\n      callHook(onBeforeEnter, [el])\r\n      addTransitionClass(el, enterFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyEnterFromClass) {\r\n        addTransitionClass(el, legacyEnterFromClass)\r\n      }\r\n      addTransitionClass(el, enterActiveClass)\r\n    },\r\n    onBeforeAppear(el) {\r\n      callHook(onBeforeAppear, [el])\r\n      addTransitionClass(el, appearFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyAppearFromClass) {\r\n        addTransitionClass(el, legacyAppearFromClass)\r\n      }\r\n      addTransitionClass(el, appearActiveClass)\r\n    },\r\n    onEnter: makeEnterHook(false),\r\n    onAppear: makeEnterHook(true),\r\n    onLeave(el: Element & { _isLeaving?: boolean }, done) {\r\n      el._isLeaving = true\r\n      const resolve = () => finishLeave(el, done)\r\n      addTransitionClass(el, leaveFromClass)\r\n      if (__COMPAT__ && legacyClassEnabled && legacyLeaveFromClass) {\r\n        addTransitionClass(el, legacyLeaveFromClass)\r\n      }\r\n      // force reflow so *-leave-from classes immediately take effect (#2593)\r\n      forceReflow()\r\n      addTransitionClass(el, leaveActiveClass)\r\n      nextFrame(() => {\r\n        if (!el._isLeaving) {\r\n          // cancelled\r\n          return\r\n        }\r\n        removeTransitionClass(el, leaveFromClass)\r\n        if (__COMPAT__ && legacyClassEnabled && legacyLeaveFromClass) {\r\n          removeTransitionClass(el, legacyLeaveFromClass)\r\n        }\r\n        addTransitionClass(el, leaveToClass)\r\n        if (!hasExplicitCallback(onLeave)) {\r\n          whenTransitionEnds(el, type, leaveDuration, resolve)\r\n        }\r\n      })\r\n      callHook(onLeave, [el, resolve])\r\n    },\r\n    onEnterCancelled(el) {\r\n      finishEnter(el, false)\r\n      callHook(onEnterCancelled, [el])\r\n    },\r\n    onAppearCancelled(el) {\r\n      finishEnter(el, true)\r\n      callHook(onAppearCancelled, [el])\r\n    },\r\n    onLeaveCancelled(el) {\r\n      finishLeave(el)\r\n      callHook(onLeaveCancelled, [el])\r\n    }\r\n  } as BaseTransitionProps<Element>)\r\n}\r\n\r\nfunction normalizeDuration(\r\n  duration: TransitionProps['duration']\r\n): [number, number] | null {\r\n  if (duration == null) {\r\n    return null\r\n  } else if (isObject(duration)) {\r\n    return [NumberOf(duration.enter), NumberOf(duration.leave)]\r\n  } else {\r\n    const n = NumberOf(duration)\r\n    return [n, n]\r\n  }\r\n}\r\n\r\nfunction NumberOf(val: unknown): number {\r\n  const res = toNumber(val)\r\n  if (__DEV__) {\r\n    assertNumber(res, '<transition> explicit duration')\r\n  }\r\n  return res\r\n}\r\n\r\nexport function addTransitionClass(el: Element, cls: string) {\r\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c))\r\n  ;(\r\n    (el as ElementWithTransition)[vtcKey] ||\r\n    ((el as ElementWithTransition)[vtcKey] = new Set())\r\n  ).add(cls)\r\n}\r\n\r\nexport function removeTransitionClass(el: Element, cls: string) {\r\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c))\r\n  const _vtc = (el as ElementWithTransition)[vtcKey]\r\n  if (_vtc) {\r\n    _vtc.delete(cls)\r\n    if (!_vtc!.size) {\r\n      ;(el as ElementWithTransition)[vtcKey] = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction nextFrame(cb: () => void) {\r\n  requestAnimationFrame(() => {\r\n    requestAnimationFrame(cb)\r\n  })\r\n}\r\n\r\nlet endId = 0\r\n\r\nfunction whenTransitionEnds(\r\n  el: Element & { _endId?: number },\r\n  expectedType: TransitionProps['type'] | undefined,\r\n  explicitTimeout: number | null,\r\n  resolve: () => void\r\n) {\r\n  const id = (el._endId = ++endId)\r\n  const resolveIfNotStale = () => {\r\n    if (id === el._endId) {\r\n      resolve()\r\n    }\r\n  }\r\n\r\n  if (explicitTimeout) {\r\n    return setTimeout(resolveIfNotStale, explicitTimeout)\r\n  }\r\n\r\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType)\r\n  if (!type) {\r\n    return resolve()\r\n  }\r\n\r\n  const endEvent = type + 'end'\r\n  let ended = 0\r\n  const end = () => {\r\n    el.removeEventListener(endEvent, onEnd)\r\n    resolveIfNotStale()\r\n  }\r\n  const onEnd = (e: Event) => {\r\n    if (e.target === el && ++ended >= propCount) {\r\n      end()\r\n    }\r\n  }\r\n  setTimeout(() => {\r\n    if (ended < propCount) {\r\n      end()\r\n    }\r\n  }, timeout + 1)\r\n  el.addEventListener(endEvent, onEnd)\r\n}\r\n\r\ninterface CSSTransitionInfo {\r\n  type: AnimationTypes | null\r\n  propCount: number\r\n  timeout: number\r\n  hasTransform: boolean\r\n}\r\n\r\ntype AnimationProperties = 'Delay' | 'Duration'\r\ntype StylePropertiesKey =\r\n  | `${AnimationTypes}${AnimationProperties}`\r\n  | `${typeof TRANSITION}Property`\r\n\r\nexport function getTransitionInfo(\r\n  el: Element,\r\n  expectedType?: TransitionProps['type']\r\n): CSSTransitionInfo {\r\n  const styles = window.getComputedStyle(el) as Pick<\r\n    CSSStyleDeclaration,\r\n    StylePropertiesKey\r\n  >\r\n  // JSDOM may return undefined for transition properties\r\n  const getStyleProperties = (key: StylePropertiesKey) =>\r\n    (styles[key] || '').split(', ')\r\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`)\r\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`)\r\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations)\r\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`)\r\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`)\r\n  const animationTimeout = getTimeout(animationDelays, animationDurations)\r\n\r\n  let type: CSSTransitionInfo['type'] = null\r\n  let timeout = 0\r\n  let propCount = 0\r\n  /* istanbul ignore if */\r\n  if (expectedType === TRANSITION) {\r\n    if (transitionTimeout > 0) {\r\n      type = TRANSITION\r\n      timeout = transitionTimeout\r\n      propCount = transitionDurations.length\r\n    }\r\n  } else if (expectedType === ANIMATION) {\r\n    if (animationTimeout > 0) {\r\n      type = ANIMATION\r\n      timeout = animationTimeout\r\n      propCount = animationDurations.length\r\n    }\r\n  } else {\r\n    timeout = Math.max(transitionTimeout, animationTimeout)\r\n    type =\r\n      timeout > 0\r\n        ? transitionTimeout > animationTimeout\r\n          ? TRANSITION\r\n          : ANIMATION\r\n        : null\r\n    propCount = type\r\n      ? type === TRANSITION\r\n        ? transitionDurations.length\r\n        : animationDurations.length\r\n      : 0\r\n  }\r\n  const hasTransform =\r\n    type === TRANSITION &&\r\n    /\\b(transform|all)(,|$)/.test(\r\n      getStyleProperties(`${TRANSITION}Property`).toString()\r\n    )\r\n  return {\r\n    type,\r\n    timeout,\r\n    propCount,\r\n    hasTransform\r\n  }\r\n}\r\n\r\nfunction getTimeout(delays: string[], durations: string[]): number {\r\n  while (delays.length < durations.length) {\r\n    delays = delays.concat(delays)\r\n  }\r\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])))\r\n}\r\n\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s: string): number {\r\n  // #8409 default value for CSS durations can be 'auto'\r\n  if (s === 'auto') return 0\r\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\r\n}\r\n\r\n// synchronously force layout to put elements into a certain state\r\nexport function forceReflow() {\r\n  return document.body.offsetHeight\r\n}\r\n", "import { ElementWithTransition, vtcKey } from '../components/Transition'\r\n\r\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nexport function patchClass(el: Element, value: string | null, isSVG: boolean) {\r\n  // directly setting className should be faster than setAttribute in theory\r\n  // if this is an element during a transition, take the temporary transition\r\n  // classes into account.\r\n  const transitionClasses = (el as ElementWithTransition)[vtcKey]\r\n  if (transitionClasses) {\r\n    value = (\r\n      value ? [value, ...transitionClasses] : [...transitionClasses]\r\n    ).join(' ')\r\n  }\r\n  if (value == null) {\r\n    el.removeAttribute('class')\r\n  } else if (isSVG) {\r\n    el.setAttribute('class', value)\r\n  } else {\r\n    el.className = value\r\n  }\r\n}\r\n", "import { ObjectDirective } from '@vue/runtime-core'\r\n\r\nexport const vShowOldKey = Symbol('_vod')\r\n\r\ninterface VShowElement extends HTMLElement {\r\n  // _vod = vue original display\r\n  [vShowOldKey]: string\r\n}\r\n\r\nexport const vShow: ObjectDirective<VShowElement> = {\r\n  beforeMount(el, { value }, { transition }) {\r\n    el[vShowOldKey] = el.style.display === 'none' ? '' : el.style.display\r\n    if (transition && value) {\r\n      transition.beforeEnter(el)\r\n    } else {\r\n      setDisplay(el, value)\r\n    }\r\n  },\r\n  mounted(el, { value }, { transition }) {\r\n    if (transition && value) {\r\n      transition.enter(el)\r\n    }\r\n  },\r\n  updated(el, { value, oldValue }, { transition }) {\r\n    if (!value === !oldValue) return\r\n    if (transition) {\r\n      if (value) {\r\n        transition.beforeEnter(el)\r\n        setDisplay(el, true)\r\n        transition.enter(el)\r\n      } else {\r\n        transition.leave(el, () => {\r\n          setDisplay(el, false)\r\n        })\r\n      }\r\n    } else {\r\n      setDisplay(el, value)\r\n    }\r\n  },\r\n  beforeUnmount(el, { value }) {\r\n    setDisplay(el, value)\r\n  }\r\n}\r\n\r\nfunction setDisplay(el: VShowElement, value: unknown): void {\r\n  el.style.display = value ? el[vShowOldKey] : 'none'\r\n}\r\n\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nexport function initVShowForSSR() {\r\n  vShow.getSSRProps = ({ value }) => {\r\n    if (!value) {\r\n      return { style: { display: 'none' } }\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  getCurrentInstance,\r\n  warn,\r\n  VNode,\r\n  Fragment,\r\n  Static,\r\n  watchPostEffect,\r\n  onMounted,\r\n  onUnmounted\r\n} from '@vue/runtime-core'\r\nimport { ShapeFlags } from '@vue/shared'\r\n\r\nexport const CSS_VAR_TEXT = Symbol(__DEV__ ? 'CSS_VAR_TEXT' : '')\r\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nexport function useCssVars(getter: (ctx: any) => Record<string, string>) {\r\n  if (!__BROWSER__ && !__TEST__) return\r\n\r\n  const instance = getCurrentInstance()\r\n  /* istanbul ignore next */\r\n  if (!instance) {\r\n    __DEV__ &&\r\n      warn(`useCssVars is called without current active component instance.`)\r\n    return\r\n  }\r\n\r\n  const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) => {\r\n    Array.from(\r\n      document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)\r\n    ).forEach(node => setVarsOnNode(node, vars))\r\n  })\r\n\r\n  const setVars = () => {\r\n    const vars = getter(instance.proxy)\r\n    setVarsOnVNode(instance.subTree, vars)\r\n    updateTeleports(vars)\r\n  }\r\n\r\n  watchPostEffect(setVars)\r\n\r\n  onMounted(() => {\r\n    const ob = new MutationObserver(setVars)\r\n    ob.observe(instance.subTree.el!.parentNode, { childList: true })\r\n    onUnmounted(() => ob.disconnect())\r\n  })\r\n}\r\n\r\nfunction setVarsOnVNode(vnode: VNode, vars: Record<string, string>) {\r\n  if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\r\n    const suspense = vnode.suspense!\r\n    vnode = suspense.activeBranch!\r\n    if (suspense.pendingBranch && !suspense.isHydrating) {\r\n      suspense.effects.push(() => {\r\n        setVarsOnVNode(suspense.activeBranch!, vars)\r\n      })\r\n    }\r\n  }\r\n\r\n  // drill down HOCs until it's a non-component vnode\r\n  while (vnode.component) {\r\n    vnode = vnode.component.subTree\r\n  }\r\n\r\n  if (vnode.shapeFlag & ShapeFlags.ELEMENT && vnode.el) {\r\n    setVarsOnNode(vnode.el as Node, vars)\r\n  } else if (vnode.type === Fragment) {\r\n    ;(vnode.children as VNode[]).forEach(c => setVarsOnVNode(c, vars))\r\n  } else if (vnode.type === Static) {\r\n    let { el, anchor } = vnode\r\n    while (el) {\r\n      setVarsOnNode(el as Node, vars)\r\n      if (el === anchor) break\r\n      el = el.nextSibling\r\n    }\r\n  }\r\n}\r\n\r\nfunction setVarsOnNode(el: Node, vars: Record<string, string>) {\r\n  if (el.nodeType === 1) {\r\n    const style = (el as HTMLElement).style\r\n    let cssText = ''\r\n    for (const key in vars) {\r\n      style.setProperty(`--${key}`, vars[key])\r\n      cssText += `--${key}: ${vars[key]};`\r\n    }\r\n    ;(style as any)[CSS_VAR_TEXT] = cssText\r\n  }\r\n}\r\n", "import { isString, hyphenate, capitalize, isArray } from '@vue/shared'\r\nimport { camelize, warn } from '@vue/runtime-core'\r\nimport { vShowOldKey } from '../directives/vShow'\r\nimport { CSS_VAR_TEXT } from '../helpers/useCssVars'\r\n\r\ntype Style = string | Record<string, string | string[]> | null\r\n\r\nexport function patchStyle(el: Element, prev: Style, next: Style) {\r\n  const style = (el as HTMLElement).style\r\n  const isCssString = isString(next)\r\n  if (next && !isCssString) {\r\n    if (prev && !isString(prev)) {\r\n      for (const key in prev) {\r\n        if (next[key] == null) {\r\n          setStyle(style, key, '')\r\n        }\r\n      }\r\n    }\r\n    for (const key in next) {\r\n      setStyle(style, key, next[key])\r\n    }\r\n  } else {\r\n    const currentDisplay = style.display\r\n    if (isCssString) {\r\n      if (prev !== next) {\r\n        // #9821\r\n        const cssVarText = (style as any)[CSS_VAR_TEXT]\r\n        if (cssVarText) {\r\n          ;(next as string) += ';' + cssVarText\r\n        }\r\n        style.cssText = next as string\r\n      }\r\n    } else if (prev) {\r\n      el.removeAttribute('style')\r\n    }\r\n    // indicates that the `display` of the element is controlled by `v-show`,\r\n    // so we always keep the current `display` value regardless of the `style`\r\n    // value, thus handing over control to `v-show`.\r\n    if (vShowOldKey in el) {\r\n      style.display = currentDisplay\r\n    }\r\n  }\r\n}\r\n\r\nconst semicolonRE = /[^\\\\];\\s*$/\r\nconst importantRE = /\\s*!important$/\r\n\r\nfunction setStyle(\r\n  style: CSSStyleDeclaration,\r\n  name: string,\r\n  val: string | string[]\r\n) {\r\n  if (isArray(val)) {\r\n    val.forEach(v => setStyle(style, name, v))\r\n  } else {\r\n    if (val == null) val = ''\r\n    if (__DEV__) {\r\n      if (semicolonRE.test(val)) {\r\n        warn(\r\n          `Unexpected semicolon at the end of '${name}' style value: '${val}'`\r\n        )\r\n      }\r\n    }\r\n    if (name.startsWith('--')) {\r\n      // custom property definition\r\n      style.setProperty(name, val)\r\n    } else {\r\n      const prefixed = autoPrefix(style, name)\r\n      if (importantRE.test(val)) {\r\n        // !important\r\n        style.setProperty(\r\n          hyphenate(prefixed),\r\n          val.replace(importantRE, ''),\r\n          'important'\r\n        )\r\n      } else {\r\n        style[prefixed as any] = val\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst prefixes = ['Webkit', 'Moz', 'ms']\r\nconst prefixCache: Record<string, string> = {}\r\n\r\nfunction autoPrefix(style: CSSStyleDeclaration, rawName: string): string {\r\n  const cached = prefixCache[rawName]\r\n  if (cached) {\r\n    return cached\r\n  }\r\n  let name = camelize(rawName)\r\n  if (name !== 'filter' && name in style) {\r\n    return (prefixCache[rawName] = name)\r\n  }\r\n  name = capitalize(name)\r\n  for (let i = 0; i < prefixes.length; i++) {\r\n    const prefixed = prefixes[i] + name\r\n    if (prefixed in style) {\r\n      return (prefixCache[rawName] = prefixed)\r\n    }\r\n  }\r\n  return rawName\r\n}\r\n", "import {\r\n  includeBooleanAttr,\r\n  isSpecialBooleanAttr,\r\n  makeMap,\r\n  NOOP\r\n} from '@vue/shared'\r\nimport {\r\n  compatUtils,\r\n  ComponentInternalInstance,\r\n  DeprecationTypes\r\n} from '@vue/runtime-core'\r\n\r\nexport const xlinkNS = 'http://www.w3.org/1999/xlink'\r\n\r\nexport function patchAttr(\r\n  el: Element,\r\n  key: string,\r\n  value: any,\r\n  isSVG: boolean,\r\n  instance?: ComponentInternalInstance | null\r\n) {\r\n  if (isSVG && key.startsWith('xlink:')) {\r\n    if (value == null) {\r\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length))\r\n    } else {\r\n      el.setAttributeNS(xlinkNS, key, value)\r\n    }\r\n  } else {\r\n    if (__COMPAT__ && compatCoerceAttr(el, key, value, instance)) {\r\n      return\r\n    }\r\n\r\n    // note we are only checking boolean attributes that don't have a\r\n    // corresponding dom prop of the same name here.\r\n    const isBoolean = isSpecialBooleanAttr(key)\r\n    if (value == null || (isBoolean && !includeBooleanAttr(value))) {\r\n      el.removeAttribute(key)\r\n    } else {\r\n      el.setAttribute(key, isBoolean ? '' : value)\r\n    }\r\n  }\r\n}\r\n\r\n// 2.x compat\r\nconst isEnumeratedAttr = __COMPAT__\r\n  ? /*#__PURE__*/ makeMap('contenteditable,draggable,spellcheck')\r\n  : NOOP\r\n\r\nexport function compatCoerceAttr(\r\n  el: Element,\r\n  key: string,\r\n  value: unknown,\r\n  instance: ComponentInternalInstance | null = null\r\n): boolean {\r\n  if (isEnumeratedAttr(key)) {\r\n    const v2CoercedValue =\r\n      value === null\r\n        ? 'false'\r\n        : typeof value !== 'boolean' && value !== undefined\r\n          ? 'true'\r\n          : null\r\n    if (\r\n      v2CoercedValue &&\r\n      compatUtils.softAssertCompatEnabled(\r\n        DeprecationTypes.ATTR_ENUMERATED_COERCION,\r\n        instance,\r\n        key,\r\n        value,\r\n        v2CoercedValue\r\n      )\r\n    ) {\r\n      el.setAttribute(key, v2CoercedValue)\r\n      return true\r\n    }\r\n  } else if (\r\n    value === false &&\r\n    !isSpecialBooleanAttr(key) &&\r\n    compatUtils.softAssertCompatEnabled(\r\n      DeprecationTypes.ATTR_FALSE_VALUE,\r\n      instance,\r\n      key\r\n    )\r\n  ) {\r\n    el.removeAttribute(key)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n", "// __UNSAFE__\r\n// Reason: potentially setting innerHTML.\r\n// This can come from explicit usage of v-html or innerHTML as a prop in render\r\n\r\nimport { warn, DeprecationTypes, compatUtils } from '@vue/runtime-core'\r\nimport { includeBooleanAttr } from '@vue/shared'\r\n\r\n// functions. The user is responsible for using them with only trusted content.\r\nexport function patchDOMProp(\r\n  el: any,\r\n  key: string,\r\n  value: any,\r\n  // the following args are passed only due to potential innerHTML/textContent\r\n  // overriding existing VNodes, in which case the old tree must be properly\r\n  // unmounted.\r\n  prevChildren: any,\r\n  parentComponent: any,\r\n  parentSuspense: any,\r\n  unmountChildren: any\r\n) {\r\n  if (key === 'innerHTML' || key === 'textContent') {\r\n    if (prevChildren) {\r\n      unmountChildren(prevChildren, parentComponent, parentSuspense)\r\n    }\r\n    el[key] = value == null ? '' : value\r\n    return\r\n  }\r\n\r\n  const tag = el.tagName\r\n\r\n  if (\r\n    key === 'value' &&\r\n    tag !== 'PROGRESS' &&\r\n    // custom elements may use _value internally\r\n    !tag.includes('-')\r\n  ) {\r\n    // store value as _value as well since\r\n    // non-string values will be stringified.\r\n    el._value = value\r\n    // #4956: <option> value will fallback to its text content so we need to\r\n    // compare against its attribute value instead.\r\n    const oldValue = tag === 'OPTION' ? el.getAttribute('value') : el.value\r\n    const newValue = value == null ? '' : value\r\n    if (oldValue !== newValue) {\r\n      el.value = newValue\r\n    }\r\n    if (value == null) {\r\n      el.removeAttribute(key)\r\n    }\r\n    return\r\n  }\r\n\r\n  let needRemove = false\r\n  if (value === '' || value == null) {\r\n    const type = typeof el[key]\r\n    if (type === 'boolean') {\r\n      // e.g. <select multiple> compiles to { multiple: '' }\r\n      value = includeBooleanAttr(value)\r\n    } else if (value == null && type === 'string') {\r\n      // e.g. <div :id=\"null\">\r\n      value = ''\r\n      needRemove = true\r\n    } else if (type === 'number') {\r\n      // e.g. <img :width=\"null\">\r\n      value = 0\r\n      needRemove = true\r\n    }\r\n  } else {\r\n    if (\r\n      __COMPAT__ &&\r\n      value === false &&\r\n      compatUtils.isCompatEnabled(\r\n        DeprecationTypes.ATTR_FALSE_VALUE,\r\n        parentComponent\r\n      )\r\n    ) {\r\n      const type = typeof el[key]\r\n      if (type === 'string' || type === 'number') {\r\n        __DEV__ &&\r\n          compatUtils.warnDeprecation(\r\n            DeprecationTypes.ATTR_FALSE_VALUE,\r\n            parentComponent,\r\n            key\r\n          )\r\n        value = type === 'number' ? 0 : ''\r\n        needRemove = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // some properties perform value validation and throw,\r\n  // some properties has getter, no setter, will error in 'use strict'\r\n  // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\r\n  try {\r\n    el[key] = value\r\n  } catch (e: any) {\r\n    // do not warn if value is auto-coerced from nullish values\r\n    if (__DEV__ && !needRemove) {\r\n      warn(\r\n        `Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: ` +\r\n          `value ${value} is invalid.`,\r\n        e\r\n      )\r\n    }\r\n  }\r\n  needRemove && el.removeAttribute(key)\r\n}\r\n", "import { hyphenate, isArray } from '@vue/shared'\r\nimport {\r\n  ErrorCodes,\r\n  ComponentInternalInstance,\r\n  callWithAsyncErrorHandling\r\n} from '@vue/runtime-core'\r\n\r\ninterface Invoker extends EventListener {\r\n  value: EventValue\r\n  attached: number\r\n}\r\n\r\ntype EventValue = Function | Function[]\r\n\r\nexport function addEventListener(\r\n  el: Element,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventListenerOptions\r\n) {\r\n  el.addEventListener(event, handler, options)\r\n}\r\n\r\nexport function removeEventListener(\r\n  el: Element,\r\n  event: string,\r\n  handler: EventListener,\r\n  options?: EventListenerOptions\r\n) {\r\n  el.removeEventListener(event, handler, options)\r\n}\r\n\r\nconst veiKey = Symbol('_vei')\r\n\r\nexport function patchEvent(\r\n  el: Element & { [veiKey]?: Record<string, Invoker | undefined> },\r\n  rawName: string,\r\n  prevValue: EventValue | null,\r\n  nextValue: EventValue | null,\r\n  instance: ComponentInternalInstance | null = null\r\n) {\r\n  // vei = vue event invokers\r\n  const invokers = el[veiKey] || (el[veiKey] = {})\r\n  const existingInvoker = invokers[rawName]\r\n  if (nextValue && existingInvoker) {\r\n    // patch\r\n    existingInvoker.value = nextValue\r\n  } else {\r\n    const [name, options] = parseName(rawName)\r\n    if (nextValue) {\r\n      // add\r\n      const invoker = (invokers[rawName] = createInvoker(nextValue, instance))\r\n      addEventListener(el, name, invoker, options)\r\n    } else if (existingInvoker) {\r\n      // remove\r\n      removeEventListener(el, name, existingInvoker, options)\r\n      invokers[rawName] = undefined\r\n    }\r\n  }\r\n}\r\n\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/\r\n\r\nfunction parseName(name: string): [string, EventListenerOptions | undefined] {\r\n  let options: EventListenerOptions | undefined\r\n  if (optionsModifierRE.test(name)) {\r\n    options = {}\r\n    let m\r\n    while ((m = name.match(optionsModifierRE))) {\r\n      name = name.slice(0, name.length - m[0].length)\r\n      ;(options as any)[m[0].toLowerCase()] = true\r\n    }\r\n  }\r\n  const event = name[2] === ':' ? name.slice(3) : hyphenate(name.slice(2))\r\n  return [event, options]\r\n}\r\n\r\n// To avoid the overhead of repeatedly calling Date.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow: number = 0\r\nconst p = /*#__PURE__*/ Promise.resolve()\r\nconst getNow = () =>\r\n  cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()))\r\n\r\nfunction createInvoker(\r\n  initialValue: EventValue,\r\n  instance: ComponentInternalInstance | null\r\n) {\r\n  const invoker: Invoker = (e: Event & { _vts?: number }) => {\r\n    // async edge case vuejs/vue#6566\r\n    // inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // this no longer happens for templates in Vue 3, but could still be\r\n    // theoretically possible for hand-written render functions.\r\n    // the solution: we save the timestamp when a handler is attached,\r\n    // and also attach the timestamp to any event that was handled by vue\r\n    // for the first time (to avoid inconsistent event timestamp implementations\r\n    // or events fired from iframes, e.g. #2513)\r\n    // The handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (!e._vts) {\r\n      e._vts = Date.now()\r\n    } else if (e._vts <= invoker.attached) {\r\n      return\r\n    }\r\n    callWithAsyncErrorHandling(\r\n      patchStopImmediatePropagation(e, invoker.value),\r\n      instance,\r\n      ErrorCodes.NATIVE_EVENT_HANDLER,\r\n      [e]\r\n    )\r\n  }\r\n  invoker.value = initialValue\r\n  invoker.attached = getNow()\r\n  return invoker\r\n}\r\n\r\nfunction patchStopImmediatePropagation(\r\n  e: Event,\r\n  value: EventValue\r\n): EventValue {\r\n  if (isArray(value)) {\r\n    const originalStop = e.stopImmediatePropagation\r\n    e.stopImmediatePropagation = () => {\r\n      originalStop.call(e)\r\n      ;(e as any)._stopped = true\r\n    }\r\n    return value.map(fn => (e: Event) => !(e as any)._stopped && fn && fn(e))\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n", "import { patchClass } from './modules/class'\r\nimport { patchStyle } from './modules/style'\r\nimport { patchAttr } from './modules/attrs'\r\nimport { patchDOMProp } from './modules/props'\r\nimport { patchEvent } from './modules/events'\r\nimport { isOn, isString, isFunction, isModelListener } from '@vue/shared'\r\nimport { RendererOptions } from '@vue/runtime-core'\r\n\r\nconst isNativeOn = (key: string) =>\r\n  key.charCodeAt(0) === 111 /* o */ &&\r\n  key.charCodeAt(1) === 110 /* n */ &&\r\n  // lowercase letter\r\n  key.charCodeAt(2) > 96 &&\r\n  key.charCodeAt(2) < 123\r\n\r\ntype DOMRendererOptions = RendererOptions<Node, Element>\r\n\r\nexport const patchProp: DOMRendererOptions['patchProp'] = (\r\n  el,\r\n  key,\r\n  prevValue,\r\n  nextValue,\r\n  isSVG = false,\r\n  prevChildren,\r\n  parentComponent,\r\n  parentSuspense,\r\n  unmountChildren\r\n) => {\r\n  if (key === 'class') {\r\n    patchClass(el, nextValue, isSVG)\r\n  } else if (key === 'style') {\r\n    patchStyle(el, prevValue, nextValue)\r\n  } else if (isOn(key)) {\r\n    // ignore v-model listeners\r\n    if (!isModelListener(key)) {\r\n      patchEvent(el, key, prevValue, nextValue, parentComponent)\r\n    }\r\n  } else if (\r\n    key[0] === '.'\r\n      ? ((key = key.slice(1)), true)\r\n      : key[0] === '^'\r\n        ? ((key = key.slice(1)), false)\r\n        : shouldSetAsProp(el, key, nextValue, isSVG)\r\n  ) {\r\n    patchDOMProp(\r\n      el,\r\n      key,\r\n      nextValue,\r\n      prevChildren,\r\n      parentComponent,\r\n      parentSuspense,\r\n      unmountChildren\r\n    )\r\n  } else {\r\n    // special case for <input v-model type=\"checkbox\"> with\r\n    // :true-value & :false-value\r\n    // store value as dom properties since non-string values will be\r\n    // stringified.\r\n    if (key === 'true-value') {\r\n      ;(el as any)._trueValue = nextValue\r\n    } else if (key === 'false-value') {\r\n      ;(el as any)._falseValue = nextValue\r\n    }\r\n    patchAttr(el, key, nextValue, isSVG, parentComponent)\r\n  }\r\n}\r\n\r\nfunction shouldSetAsProp(\r\n  el: Element,\r\n  key: string,\r\n  value: unknown,\r\n  isSVG: boolean\r\n) {\r\n  if (isSVG) {\r\n    // most keys must be set as attribute on svg elements to work\r\n    // ...except innerHTML & textContent\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n      return true\r\n    }\r\n    // or native onclick with function values\r\n    if (key in el && isNativeOn(key) && isFunction(value)) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  // these are enumerated attrs, however their corresponding DOM properties\r\n  // are actually booleans - this leads to setting it with a string \"false\"\r\n  // value leading it to be coerced to `true`, so we need to always treat\r\n  // them as attributes.\r\n  // Note that `contentEditable` doesn't have this problem: its DOM\r\n  // property is also enumerated string values.\r\n  if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\r\n    return false\r\n  }\r\n\r\n  // #1787, #2840 form property on form elements is readonly and must be set as\r\n  // attribute.\r\n  if (key === 'form') {\r\n    return false\r\n  }\r\n\r\n  // #1526 <input list> must be set as attribute\r\n  if (key === 'list' && el.tagName === 'INPUT') {\r\n    return false\r\n  }\r\n\r\n  // #2766 <textarea type> must be set as attribute\r\n  if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n    return false\r\n  }\r\n\r\n  // #8780 the width or height of embedded tags must be set as attribute\r\n  if (key === 'width' || key === 'height') {\r\n    const tag = el.tagName\r\n    if (\r\n      tag === 'IMG' ||\r\n      tag === 'VIDEO' ||\r\n      tag === 'CANVAS' ||\r\n      tag === 'SOURCE'\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  // native onclick with string value, must be set as attribute\r\n  if (isNativeOn(key) && isString(value)) {\r\n    return false\r\n  }\r\n\r\n  return key in el\r\n}\r\n", "import {\r\n  ComponentOptionsMixin,\r\n  ComponentOptionsWithArrayProps,\r\n  ComponentOptionsWithObjectProps,\r\n  ComponentOptionsWithoutProps,\r\n  ComponentPropsOptions,\r\n  ComputedOptions,\r\n  EmitsOptions,\r\n  MethodOptions,\r\n  RenderFunction,\r\n  SetupContext,\r\n  ComponentInternalInstance,\r\n  VNode,\r\n  RootHydrateFunction,\r\n  ExtractPropTypes,\r\n  createVNode,\r\n  defineComponent,\r\n  nextTick,\r\n  warn,\r\n  ConcreteComponent,\r\n  ComponentOptions,\r\n  ComponentInjectOptions,\r\n  SlotsType,\r\n  DefineComponent\r\n} from '@vue/runtime-core'\r\nimport { camelize, extend, hyphenate, isArray, toNumber } from '@vue/shared'\r\nimport { hydrate, render } from '.'\r\n\r\nexport type VueElementConstructor<P = {}> = {\r\n  new (initialProps?: Record<string, any>): VueElement & P\r\n}\r\n\r\n// defineCustomElement provides the same type inference as defineComponent\r\n// so most of the following overloads should be kept in sync w/ defineComponent.\r\n\r\n// overload 1: direct setup function\r\nexport function defineCustomElement<Props, RawBindings = object>(\r\n  setup: (\r\n    props: Readonly<Props>,\r\n    ctx: SetupContext\r\n  ) => RawBindings | RenderFunction\r\n): VueElementConstructor<Props>\r\n\r\n// overload 2: object format with no props\r\nexport function defineCustomElement<\r\n  Props = {},\r\n  RawBindings = {},\r\n  D = {},\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = EmitsOptions,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {}\r\n>(\r\n  options: ComponentOptionsWithoutProps<\r\n    Props,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  > & { styles?: string[] }\r\n): VueElementConstructor<Props>\r\n\r\n// overload 3: object format with array props declaration\r\nexport function defineCustomElement<\r\n  PropNames extends string,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = Record<string, any>,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {}\r\n>(\r\n  options: ComponentOptionsWithArrayProps<\r\n    PropNames,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  > & { styles?: string[] }\r\n): VueElementConstructor<{ [K in PropNames]: any }>\r\n\r\n// overload 4: object format with object props declaration\r\nexport function defineCustomElement<\r\n  PropsOptions extends Readonly<ComponentPropsOptions>,\r\n  RawBindings,\r\n  D,\r\n  C extends ComputedOptions = {},\r\n  M extends MethodOptions = {},\r\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\r\n  E extends EmitsOptions = Record<string, any>,\r\n  EE extends string = string,\r\n  I extends ComponentInjectOptions = {},\r\n  II extends string = string,\r\n  S extends SlotsType = {}\r\n>(\r\n  options: ComponentOptionsWithObjectProps<\r\n    PropsOptions,\r\n    RawBindings,\r\n    D,\r\n    C,\r\n    M,\r\n    Mixin,\r\n    Extends,\r\n    E,\r\n    EE,\r\n    I,\r\n    II,\r\n    S\r\n  > & { styles?: string[] }\r\n): VueElementConstructor<ExtractPropTypes<PropsOptions>>\r\n\r\n// overload 5: defining a custom element from the returned value of\r\n// `defineComponent`\r\nexport function defineCustomElement<P>(\r\n  options: DefineComponent<P, any, any, any>\r\n): VueElementConstructor<ExtractPropTypes<P>>\r\n\r\n/*! #__NO_SIDE_EFFECTS__ */\r\nexport function defineCustomElement(\r\n  options: any,\r\n  hydrate?: RootHydrateFunction\r\n): VueElementConstructor {\r\n  const Comp = defineComponent(options) as any\r\n  class VueCustomElement extends VueElement {\r\n    static def = Comp\r\n    constructor(initialProps?: Record<string, any>) {\r\n      super(Comp, initialProps, hydrate)\r\n    }\r\n  }\r\n\r\n  return VueCustomElement\r\n}\r\n\r\n/*! #__NO_SIDE_EFFECTS__ */\r\nexport const defineSSRCustomElement = ((options: any) => {\r\n  // @ts-ignore\r\n  return defineCustomElement(options, hydrate)\r\n}) as typeof defineCustomElement\r\n\r\nconst BaseClass = (\r\n  typeof HTMLElement !== 'undefined' ? HTMLElement : class {}\r\n) as typeof HTMLElement\r\n\r\ntype InnerComponentDef = ConcreteComponent & { styles?: string[] }\r\n\r\nexport class VueElement extends BaseClass {\r\n  /**\r\n   * @internal\r\n   */\r\n  _instance: ComponentInternalInstance | null = null\r\n\r\n  private _connected = false\r\n  private _resolved = false\r\n  private _numberProps: Record<string, true> | null = null\r\n  private _styles?: HTMLStyleElement[]\r\n  private _ob?: MutationObserver | null = null\r\n  constructor(\r\n    private _def: InnerComponentDef,\r\n    private _props: Record<string, any> = {},\r\n    hydrate?: RootHydrateFunction\r\n  ) {\r\n    super()\r\n    if (this.shadowRoot && hydrate) {\r\n      hydrate(this._createVNode(), this.shadowRoot)\r\n    } else {\r\n      if (__DEV__ && this.shadowRoot) {\r\n        warn(\r\n          `Custom element has pre-rendered declarative shadow root but is not ` +\r\n            `defined as hydratable. Use \\`defineSSRCustomElement\\`.`\r\n        )\r\n      }\r\n      this.attachShadow({ mode: 'open' })\r\n      if (!(this._def as ComponentOptions).__asyncLoader) {\r\n        // for sync component defs we can immediately resolve props\r\n        this._resolveProps(this._def)\r\n      }\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    this._connected = true\r\n    if (!this._instance) {\r\n      if (this._resolved) {\r\n        this._update()\r\n      } else {\r\n        this._resolveDef()\r\n      }\r\n    }\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this._connected = false\r\n    if (this._ob) {\r\n      this._ob.disconnect()\r\n      this._ob = null\r\n    }\r\n    nextTick(() => {\r\n      if (!this._connected) {\r\n        render(null, this.shadowRoot!)\r\n        this._instance = null\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * resolve inner component definition (handle possible async component)\r\n   */\r\n  private _resolveDef() {\r\n    this._resolved = true\r\n\r\n    // set initial attrs\r\n    for (let i = 0; i < this.attributes.length; i++) {\r\n      this._setAttr(this.attributes[i].name)\r\n    }\r\n\r\n    // watch future attr changes\r\n    this._ob = new MutationObserver(mutations => {\r\n      for (const m of mutations) {\r\n        this._setAttr(m.attributeName!)\r\n      }\r\n    })\r\n\r\n    this._ob.observe(this, { attributes: true })\r\n\r\n    const resolve = (def: InnerComponentDef, isAsync = false) => {\r\n      const { props, styles } = def\r\n\r\n      // cast Number-type props set before resolve\r\n      let numberProps\r\n      if (props && !isArray(props)) {\r\n        for (const key in props) {\r\n          const opt = props[key]\r\n          if (opt === Number || (opt && opt.type === Number)) {\r\n            if (key in this._props) {\r\n              this._props[key] = toNumber(this._props[key])\r\n            }\r\n            ;(numberProps || (numberProps = Object.create(null)))[\r\n              camelize(key)\r\n            ] = true\r\n          }\r\n        }\r\n      }\r\n      this._numberProps = numberProps\r\n\r\n      if (isAsync) {\r\n        // defining getter/setters on prototype\r\n        // for sync defs, this already happened in the constructor\r\n        this._resolveProps(def)\r\n      }\r\n\r\n      // apply CSS\r\n      this._applyStyles(styles)\r\n\r\n      // initial render\r\n      this._update()\r\n    }\r\n\r\n    const asyncDef = (this._def as ComponentOptions).__asyncLoader\r\n    if (asyncDef) {\r\n      asyncDef().then(def => resolve(def, true))\r\n    } else {\r\n      resolve(this._def)\r\n    }\r\n  }\r\n\r\n  private _resolveProps(def: InnerComponentDef) {\r\n    const { props } = def\r\n    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {})\r\n\r\n    // check if there are props set pre-upgrade or connect\r\n    for (const key of Object.keys(this)) {\r\n      if (key[0] !== '_' && declaredPropKeys.includes(key)) {\r\n        this._setProp(key, this[key as keyof this], true, false)\r\n      }\r\n    }\r\n\r\n    // defining getter/setters on prototype\r\n    for (const key of declaredPropKeys.map(camelize)) {\r\n      Object.defineProperty(this, key, {\r\n        get() {\r\n          return this._getProp(key)\r\n        },\r\n        set(val) {\r\n          this._setProp(key, val)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  protected _setAttr(key: string) {\r\n    let value = this.getAttribute(key)\r\n    const camelKey = camelize(key)\r\n    if (this._numberProps && this._numberProps[camelKey]) {\r\n      value = toNumber(value)\r\n    }\r\n    this._setProp(camelKey, value, false)\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  protected _getProp(key: string) {\r\n    return this._props[key]\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  protected _setProp(\r\n    key: string,\r\n    val: any,\r\n    shouldReflect = true,\r\n    shouldUpdate = true\r\n  ) {\r\n    if (val !== this._props[key]) {\r\n      this._props[key] = val\r\n      if (shouldUpdate && this._instance) {\r\n        this._update()\r\n      }\r\n      // reflect\r\n      if (shouldReflect) {\r\n        if (val === true) {\r\n          this.setAttribute(hyphenate(key), '')\r\n        } else if (typeof val === 'string' || typeof val === 'number') {\r\n          this.setAttribute(hyphenate(key), val + '')\r\n        } else if (!val) {\r\n          this.removeAttribute(hyphenate(key))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private _update() {\r\n    render(this._createVNode(), this.shadowRoot!)\r\n  }\r\n\r\n  private _createVNode(): VNode<any, any> {\r\n    const vnode = createVNode(this._def, extend({}, this._props))\r\n    if (!this._instance) {\r\n      vnode.ce = instance => {\r\n        this._instance = instance\r\n        instance.isCE = true\r\n        // HMR\r\n        if (__DEV__) {\r\n          instance.ceReload = newStyles => {\r\n            // always reset styles\r\n            if (this._styles) {\r\n              this._styles.forEach(s => this.shadowRoot!.removeChild(s))\r\n              this._styles.length = 0\r\n            }\r\n            this._applyStyles(newStyles)\r\n            this._instance = null\r\n            this._update()\r\n          }\r\n        }\r\n\r\n        const dispatch = (event: string, args: any[]) => {\r\n          this.dispatchEvent(\r\n            new CustomEvent(event, {\r\n              detail: args\r\n            })\r\n          )\r\n        }\r\n\r\n        // intercept emit\r\n        instance.emit = (event: string, ...args: any[]) => {\r\n          // dispatch both the raw and hyphenated versions of an event\r\n          // to match Vue behavior\r\n          dispatch(event, args)\r\n          if (hyphenate(event) !== event) {\r\n            dispatch(hyphenate(event), args)\r\n          }\r\n        }\r\n\r\n        // locate nearest Vue custom element parent for provide/inject\r\n        let parent: Node | null = this\r\n        while (\r\n          (parent =\r\n            parent && (parent.parentNode || (parent as ShadowRoot).host))\r\n        ) {\r\n          if (parent instanceof VueElement) {\r\n            instance.parent = parent._instance\r\n            instance.provides = parent._instance!.provides\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return vnode\r\n  }\r\n\r\n  private _applyStyles(styles: string[] | undefined) {\r\n    if (styles) {\r\n      styles.forEach(css => {\r\n        const s = document.createElement('style')\r\n        s.textContent = css\r\n        this.shadowRoot!.appendChild(s)\r\n        // record for HMR\r\n        if (__DEV__) {\r\n          ;(this._styles || (this._styles = [])).push(s)\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n", "import { warn, getCurrentInstance } from '@vue/runtime-core'\r\nimport { EMPTY_OBJ } from '@vue/shared'\r\n\r\nexport function useCssModule(name = '$style'): Record<string, string> {\r\n  /* istanbul ignore else */\r\n  if (!__GLOBAL__) {\r\n    const instance = getCurrentInstance()!\r\n    if (!instance) {\r\n      __DEV__ && warn(`useCssModule must be called inside setup()`)\r\n      return EMPTY_OBJ\r\n    }\r\n    const modules = instance.type.__cssModules\r\n    if (!modules) {\r\n      __DEV__ && warn(`Current instance does not have CSS modules injected.`)\r\n      return EMPTY_OBJ\r\n    }\r\n    const mod = modules[name]\r\n    if (!mod) {\r\n      __DEV__ &&\r\n        warn(`Current instance does not have CSS module named \"${name}\".`)\r\n      return EMPTY_OBJ\r\n    }\r\n    return mod as Record<string, string>\r\n  } else {\r\n    if (__DEV__) {\r\n      warn(`useCssModule() is not supported in the global build.`)\r\n    }\r\n    return EMPTY_OBJ\r\n  }\r\n}\r\n", "import {\r\n  TransitionProps,\r\n  addTransitionClass,\r\n  removeTransitionClass,\r\n  ElementWithTransition,\r\n  getTransitionInfo,\r\n  resolveTransitionProps,\r\n  TransitionPropsValidators,\r\n  forceReflow,\r\n  vtcKey\r\n} from './Transition'\r\nimport {\r\n  Fragment,\r\n  VNode,\r\n  warn,\r\n  resolveTransitionHooks,\r\n  useTransitionState,\r\n  getTransitionRawChildren,\r\n  getCurrentInstance,\r\n  setTransitionHooks,\r\n  createVNode,\r\n  onUpdated,\r\n  SetupContext,\r\n  toRaw,\r\n  compatUtils,\r\n  DeprecationTypes,\r\n  ComponentOptions\r\n} from '@vue/runtime-core'\r\nimport { extend } from '@vue/shared'\r\n\r\nconst positionMap = new WeakMap<VNode, DOMRect>()\r\nconst newPositionMap = new WeakMap<VNode, DOMRect>()\r\nconst moveCbKey = Symbol('_moveCb')\r\nconst enterCbKey = Symbol('_enterCb')\r\nexport type TransitionGroupProps = Omit<TransitionProps, 'mode'> & {\r\n  tag?: string\r\n  moveClass?: string\r\n}\r\n\r\nconst TransitionGroupImpl: ComponentOptions = {\r\n  name: 'TransitionGroup',\r\n\r\n  props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {\r\n    tag: String,\r\n    moveClass: String\r\n  }),\r\n\r\n  setup(props: TransitionGroupProps, { slots }: SetupContext) {\r\n    const instance = getCurrentInstance()!\r\n    const state = useTransitionState()\r\n    let prevChildren: VNode[]\r\n    let children: VNode[]\r\n\r\n    onUpdated(() => {\r\n      // children is guaranteed to exist after initial render\r\n      if (!prevChildren.length) {\r\n        return\r\n      }\r\n      const moveClass = props.moveClass || `${props.name || 'v'}-move`\r\n\r\n      if (\r\n        !hasCSSTransform(\r\n          prevChildren[0].el as ElementWithTransition,\r\n          instance.vnode.el as Node,\r\n          moveClass\r\n        )\r\n      ) {\r\n        return\r\n      }\r\n\r\n      // we divide the work into three loops to avoid mixing DOM reads and writes\r\n      // in each iteration - which helps prevent layout thrashing.\r\n      prevChildren.forEach(callPendingCbs)\r\n      prevChildren.forEach(recordPosition)\r\n      const movedChildren = prevChildren.filter(applyTranslation)\r\n\r\n      // force reflow to put everything in position\r\n      forceReflow()\r\n\r\n      movedChildren.forEach(c => {\r\n        const el = c.el as ElementWithTransition\r\n        const style = el.style\r\n        addTransitionClass(el, moveClass)\r\n        style.transform = style.webkitTransform = style.transitionDuration = ''\r\n        const cb = ((el as any)[moveCbKey] = (e: TransitionEvent) => {\r\n          if (e && e.target !== el) {\r\n            return\r\n          }\r\n          if (!e || /transform$/.test(e.propertyName)) {\r\n            el.removeEventListener('transitionend', cb)\r\n            ;(el as any)[moveCbKey] = null\r\n            removeTransitionClass(el, moveClass)\r\n          }\r\n        })\r\n        el.addEventListener('transitionend', cb)\r\n      })\r\n    })\r\n\r\n    return () => {\r\n      const rawProps = toRaw(props)\r\n      const cssTransitionProps = resolveTransitionProps(rawProps)\r\n      let tag = rawProps.tag || Fragment\r\n\r\n      if (\r\n        __COMPAT__ &&\r\n        !rawProps.tag &&\r\n        compatUtils.checkCompatEnabled(\r\n          DeprecationTypes.TRANSITION_GROUP_ROOT,\r\n          instance.parent\r\n        )\r\n      ) {\r\n        tag = 'span'\r\n      }\r\n\r\n      prevChildren = children\r\n      children = slots.default ? getTransitionRawChildren(slots.default()) : []\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (child.key != null) {\r\n          setTransitionHooks(\r\n            child,\r\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\r\n          )\r\n        } else if (__DEV__) {\r\n          warn(`<TransitionGroup> children must be keyed.`)\r\n        }\r\n      }\r\n\r\n      if (prevChildren) {\r\n        for (let i = 0; i < prevChildren.length; i++) {\r\n          const child = prevChildren[i]\r\n          setTransitionHooks(\r\n            child,\r\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\r\n          )\r\n          positionMap.set(child, (child.el as Element).getBoundingClientRect())\r\n        }\r\n      }\r\n\r\n      return createVNode(tag, null, children)\r\n    }\r\n  }\r\n}\r\n\r\nif (__COMPAT__) {\r\n  TransitionGroupImpl.__isBuiltIn = true\r\n}\r\n\r\n/**\r\n * TransitionGroup does not support \"mode\" so we need to remove it from the\r\n * props declarations, but direct delete operation is considered a side effect\r\n * and will make the entire transition feature non-tree-shakeable, so we do it\r\n * in a function and mark the function's invocation as pure.\r\n */\r\nconst removeMode = (props: any) => delete props.mode\r\n/*#__PURE__*/ removeMode(TransitionGroupImpl.props)\r\n\r\nexport const TransitionGroup = TransitionGroupImpl as unknown as {\r\n  new (): {\r\n    $props: TransitionGroupProps\r\n  }\r\n}\r\n\r\nfunction callPendingCbs(c: VNode) {\r\n  const el = c.el as any\r\n  if (el[moveCbKey]) {\r\n    el[moveCbKey]()\r\n  }\r\n  if (el[enterCbKey]) {\r\n    el[enterCbKey]()\r\n  }\r\n}\r\n\r\nfunction recordPosition(c: VNode) {\r\n  newPositionMap.set(c, (c.el as Element).getBoundingClientRect())\r\n}\r\n\r\nfunction applyTranslation(c: VNode): VNode | undefined {\r\n  const oldPos = positionMap.get(c)!\r\n  const newPos = newPositionMap.get(c)!\r\n  const dx = oldPos.left - newPos.left\r\n  const dy = oldPos.top - newPos.top\r\n  if (dx || dy) {\r\n    const s = (c.el as HTMLElement).style\r\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`\r\n    s.transitionDuration = '0s'\r\n    return c\r\n  }\r\n}\r\n\r\nfunction hasCSSTransform(\r\n  el: ElementWithTransition,\r\n  root: Node,\r\n  moveClass: string\r\n): boolean {\r\n  // Detect whether an element with the move class applied has\r\n  // CSS transitions. Since the element may be inside an entering\r\n  // transition at this very moment, we make a clone of it and remove\r\n  // all other transition classes applied to ensure only the move class\r\n  // is applied.\r\n  const clone = el.cloneNode() as HTMLElement\r\n  const _vtc = el[vtcKey]\r\n  if (_vtc) {\r\n    _vtc.forEach(cls => {\r\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c))\r\n    })\r\n  }\r\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c))\r\n  clone.style.display = 'none'\r\n  const container = (\r\n    root.nodeType === 1 ? root : root.parentNode\r\n  ) as HTMLElement\r\n  container.appendChild(clone)\r\n  const { hasTransform } = getTransitionInfo(clone)\r\n  container.removeChild(clone)\r\n  return hasTransform\r\n}\r\n", "import {\r\n  ObjectDirective,\r\n  VNode,\r\n  DirectiveHook,\r\n  DirectiveBinding,\r\n  warn\r\n} from '@vue/runtime-core'\r\nimport { addEventListener } from '../modules/events'\r\nimport {\r\n  isArray,\r\n  looseEqual,\r\n  looseIndexOf,\r\n  invokeArrayFns,\r\n  looseToNumber,\r\n  isSet\r\n} from '@vue/shared'\r\n\r\ntype AssignerFn = (value: any) => void\r\n\r\nconst getModelAssigner = (vnode: VNode): AssignerFn => {\r\n  const fn =\r\n    vnode.props!['onUpdate:modelValue'] ||\r\n    (__COMPAT__ && vnode.props!['onModelCompat:input'])\r\n  return isArray(fn) ? value => invokeArrayFns(fn, value) : fn\r\n}\r\n\r\nfunction onCompositionStart(e: Event) {\r\n  ;(e.target as any).composing = true\r\n}\r\n\r\nfunction onCompositionEnd(e: Event) {\r\n  const target = e.target as any\r\n  if (target.composing) {\r\n    target.composing = false\r\n    target.dispatchEvent(new Event('input'))\r\n  }\r\n}\r\n\r\nconst assignKey = Symbol('_assign')\r\n\r\ntype ModelDirective<T> = ObjectDirective<T & { [assignKey]: AssignerFn }>\r\n\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nexport const vModelText: ModelDirective<\r\n  HTMLInputElement | HTMLTextAreaElement\r\n> = {\r\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    const castToNumber =\r\n      number || (vnode.props && vnode.props.type === 'number')\r\n    addEventListener(el, lazy ? 'change' : 'input', e => {\r\n      if ((e.target as any).composing) return\r\n      let domValue: string | number = el.value\r\n      if (trim) {\r\n        domValue = domValue.trim()\r\n      }\r\n      if (castToNumber) {\r\n        domValue = looseToNumber(domValue)\r\n      }\r\n      el[assignKey](domValue)\r\n    })\r\n    if (trim) {\r\n      addEventListener(el, 'change', () => {\r\n        el.value = el.value.trim()\r\n      })\r\n    }\r\n    if (!lazy) {\r\n      addEventListener(el, 'compositionstart', onCompositionStart)\r\n      addEventListener(el, 'compositionend', onCompositionEnd)\r\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n      // switching focus before confirming composition choice\r\n      // this also fixes the issue where some browsers e.g. iOS Chrome\r\n      // fires \"change\" instead of \"input\" on autocomplete.\r\n      addEventListener(el, 'change', onCompositionEnd)\r\n    }\r\n  },\r\n  // set value on mounted so it's after min/max for type=\"range\"\r\n  mounted(el, { value }) {\r\n    el.value = value == null ? '' : value\r\n  },\r\n  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    // avoid clearing unresolved text. #2302\r\n    if ((el as any).composing) return\r\n\r\n    const elValue =\r\n      number || el.type === 'number' ? looseToNumber(el.value) : el.value\r\n    const newValue = value == null ? '' : value\r\n\r\n    if (elValue === newValue) {\r\n      return\r\n    }\r\n\r\n    if (document.activeElement === el && el.type !== 'range') {\r\n      if (lazy) {\r\n        return\r\n      }\r\n      if (trim && el.value.trim() === newValue) {\r\n        return\r\n      }\r\n    }\r\n\r\n    el.value = newValue\r\n  }\r\n}\r\n\r\nexport const vModelCheckbox: ModelDirective<HTMLInputElement> = {\r\n  // #4096 array checkboxes need to be deep traversed\r\n  deep: true,\r\n  created(el, _, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    addEventListener(el, 'change', () => {\r\n      const modelValue = (el as any)._modelValue\r\n      const elementValue = getValue(el)\r\n      const checked = el.checked\r\n      const assign = el[assignKey]\r\n      if (isArray(modelValue)) {\r\n        const index = looseIndexOf(modelValue, elementValue)\r\n        const found = index !== -1\r\n        if (checked && !found) {\r\n          assign(modelValue.concat(elementValue))\r\n        } else if (!checked && found) {\r\n          const filtered = [...modelValue]\r\n          filtered.splice(index, 1)\r\n          assign(filtered)\r\n        }\r\n      } else if (isSet(modelValue)) {\r\n        const cloned = new Set(modelValue)\r\n        if (checked) {\r\n          cloned.add(elementValue)\r\n        } else {\r\n          cloned.delete(elementValue)\r\n        }\r\n        assign(cloned)\r\n      } else {\r\n        assign(getCheckboxValue(el, checked))\r\n      }\r\n    })\r\n  },\r\n  // set initial checked on mount to wait for true-value/false-value\r\n  mounted: setChecked,\r\n  beforeUpdate(el, binding, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    setChecked(el, binding, vnode)\r\n  }\r\n}\r\n\r\nfunction setChecked(\r\n  el: HTMLInputElement,\r\n  { value, oldValue }: DirectiveBinding,\r\n  vnode: VNode\r\n) {\r\n  // store the v-model value on the element so it can be accessed by the\r\n  // change listener.\r\n  ;(el as any)._modelValue = value\r\n  if (isArray(value)) {\r\n    el.checked = looseIndexOf(value, vnode.props!.value) > -1\r\n  } else if (isSet(value)) {\r\n    el.checked = value.has(vnode.props!.value)\r\n  } else if (value !== oldValue) {\r\n    el.checked = looseEqual(value, getCheckboxValue(el, true))\r\n  }\r\n}\r\n\r\nexport const vModelRadio: ModelDirective<HTMLInputElement> = {\r\n  created(el, { value }, vnode) {\r\n    el.checked = looseEqual(value, vnode.props!.value)\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    addEventListener(el, 'change', () => {\r\n      el[assignKey](getValue(el))\r\n    })\r\n  },\r\n  beforeUpdate(el, { value, oldValue }, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n    if (value !== oldValue) {\r\n      el.checked = looseEqual(value, vnode.props!.value)\r\n    }\r\n  }\r\n}\r\n\r\nexport const vModelSelect: ModelDirective<HTMLSelectElement> = {\r\n  // <select multiple> value need to be deep traversed\r\n  deep: true,\r\n  created(el, { value, modifiers: { number } }, vnode) {\r\n    const isSetModel = isSet(value)\r\n    addEventListener(el, 'change', () => {\r\n      const selectedVal = Array.prototype.filter\r\n        .call(el.options, (o: HTMLOptionElement) => o.selected)\r\n        .map((o: HTMLOptionElement) =>\r\n          number ? looseToNumber(getValue(o)) : getValue(o)\r\n        )\r\n      el[assignKey](\r\n        el.multiple\r\n          ? isSetModel\r\n            ? new Set(selectedVal)\r\n            : selectedVal\r\n          : selectedVal[0]\r\n      )\r\n    })\r\n    el[assignKey] = getModelAssigner(vnode)\r\n  },\r\n  // set value in mounted & updated because <select> relies on its children\r\n  // <option>s.\r\n  mounted(el, { value }) {\r\n    setSelected(el, value)\r\n  },\r\n  beforeUpdate(el, _binding, vnode) {\r\n    el[assignKey] = getModelAssigner(vnode)\r\n  },\r\n  updated(el, { value }) {\r\n    setSelected(el, value)\r\n  }\r\n}\r\n\r\nfunction setSelected(el: HTMLSelectElement, value: any) {\r\n  const isMultiple = el.multiple\r\n  if (isMultiple && !isArray(value) && !isSet(value)) {\r\n    __DEV__ &&\r\n      warn(\r\n        `<select multiple v-model> expects an Array or Set value for its binding, ` +\r\n          `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`\r\n      )\r\n    return\r\n  }\r\n  for (let i = 0, l = el.options.length; i < l; i++) {\r\n    const option = el.options[i]\r\n    const optionValue = getValue(option)\r\n    if (isMultiple) {\r\n      if (isArray(value)) {\r\n        option.selected = looseIndexOf(value, optionValue) > -1\r\n      } else {\r\n        option.selected = value.has(optionValue)\r\n      }\r\n    } else {\r\n      if (looseEqual(getValue(option), value)) {\r\n        if (el.selectedIndex !== i) el.selectedIndex = i\r\n        return\r\n      }\r\n    }\r\n  }\r\n  if (!isMultiple && el.selectedIndex !== -1) {\r\n    el.selectedIndex = -1\r\n  }\r\n}\r\n\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el: HTMLOptionElement | HTMLInputElement) {\r\n  return '_value' in el ? (el as any)._value : el.value\r\n}\r\n\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(\r\n  el: HTMLInputElement & { _trueValue?: any; _falseValue?: any },\r\n  checked: boolean\r\n) {\r\n  const key = checked ? '_trueValue' : '_falseValue'\r\n  return key in el ? el[key] : checked\r\n}\r\n\r\nexport const vModelDynamic: ObjectDirective<\r\n  HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\r\n> = {\r\n  created(el, binding, vnode) {\r\n    callModelHook(el, binding, vnode, null, 'created')\r\n  },\r\n  mounted(el, binding, vnode) {\r\n    callModelHook(el, binding, vnode, null, 'mounted')\r\n  },\r\n  beforeUpdate(el, binding, vnode, prevVNode) {\r\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')\r\n  },\r\n  updated(el, binding, vnode, prevVNode) {\r\n    callModelHook(el, binding, vnode, prevVNode, 'updated')\r\n  }\r\n}\r\n\r\nfunction resolveDynamicModel(tagName: string, type: string | undefined) {\r\n  switch (tagName) {\r\n    case 'SELECT':\r\n      return vModelSelect\r\n    case 'TEXTAREA':\r\n      return vModelText\r\n    default:\r\n      switch (type) {\r\n        case 'checkbox':\r\n          return vModelCheckbox\r\n        case 'radio':\r\n          return vModelRadio\r\n        default:\r\n          return vModelText\r\n      }\r\n  }\r\n}\r\n\r\nfunction callModelHook(\r\n  el: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\r\n  binding: DirectiveBinding,\r\n  vnode: VNode,\r\n  prevVNode: VNode | null,\r\n  hook: keyof ObjectDirective\r\n) {\r\n  const modelToUse = resolveDynamicModel(\r\n    el.tagName,\r\n    vnode.props && vnode.props.type\r\n  )\r\n  const fn = modelToUse[hook] as DirectiveHook\r\n  fn && fn(el, binding, vnode, prevVNode)\r\n}\r\n\r\n// SSR vnode transforms, only used when user includes client-oriented render\r\n// function in SSR\r\nexport function initVModelForSSR() {\r\n  vModelText.getSSRProps = ({ value }) => ({ value })\r\n\r\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\r\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\r\n      return { checked: true }\r\n    }\r\n  }\r\n\r\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\r\n    if (isArray(value)) {\r\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\r\n        return { checked: true }\r\n      }\r\n    } else if (isSet(value)) {\r\n      if (vnode.props && value.has(vnode.props.value)) {\r\n        return { checked: true }\r\n      }\r\n    } else if (value) {\r\n      return { checked: true }\r\n    }\r\n  }\r\n\r\n  vModelDynamic.getSSRProps = (binding, vnode) => {\r\n    if (typeof vnode.type !== 'string') {\r\n      return\r\n    }\r\n    const modelToUse = resolveDynamicModel(\r\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\r\n      vnode.type.toUpperCase(),\r\n      vnode.props && vnode.props.type\r\n    )\r\n    if (modelToUse.getSSRProps) {\r\n      return modelToUse.getSSRProps(binding, vnode)\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  getCurrentInstance,\r\n  DeprecationTypes,\r\n  LegacyConfig,\r\n  compatUtils,\r\n  ComponentInternalInstance\r\n} from '@vue/runtime-core'\r\nimport { hyphenate, isArray } from '@vue/shared'\r\n\r\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta']\r\n\r\ntype KeyedEvent = KeyboardEvent | MouseEvent | TouchEvent\r\n\r\nconst modifierGuards: Record<\r\n  string,\r\n  (e: Event, modifiers: string[]) => void | boolean\r\n> = {\r\n  stop: e => e.stopPropagation(),\r\n  prevent: e => e.preventDefault(),\r\n  self: e => e.target !== e.currentTarget,\r\n  ctrl: e => !(e as KeyedEvent).ctrlKey,\r\n  shift: e => !(e as KeyedEvent).shiftKey,\r\n  alt: e => !(e as KeyedEvent).altKey,\r\n  meta: e => !(e as KeyedEvent).metaKey,\r\n  left: e => 'button' in e && (e as MouseEvent).button !== 0,\r\n  middle: e => 'button' in e && (e as MouseEvent).button !== 1,\r\n  right: e => 'button' in e && (e as MouseEvent).button !== 2,\r\n  exact: (e, modifiers) =>\r\n    systemModifiers.some(m => (e as any)[`${m}Key`] && !modifiers.includes(m))\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport const withModifiers = <\r\n  T extends (event: Event, ...args: unknown[]) => any\r\n>(\r\n  fn: T & { _withMods?: { [key: string]: T } },\r\n  modifiers: string[]\r\n) => {\r\n  const cache = fn._withMods || (fn._withMods = {})\r\n  const cacheKey = modifiers.join('.')\r\n  return (\r\n    cache[cacheKey] ||\r\n    (cache[cacheKey] = ((event, ...args) => {\r\n      for (let i = 0; i < modifiers.length; i++) {\r\n        const guard = modifierGuards[modifiers[i]]\r\n        if (guard && guard(event, modifiers)) return\r\n      }\r\n      return fn(event, ...args)\r\n    }) as T)\r\n  )\r\n}\r\n\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames: Record<string, string | string[]> = {\r\n  esc: 'escape',\r\n  space: ' ',\r\n  up: 'arrow-up',\r\n  left: 'arrow-left',\r\n  right: 'arrow-right',\r\n  down: 'arrow-down',\r\n  delete: 'backspace'\r\n}\r\n\r\n/**\r\n * @private\r\n */\r\nexport const withKeys = <T extends (event: KeyboardEvent) => any>(\r\n  fn: T & { _withKeys?: { [k: string]: T } },\r\n  modifiers: string[]\r\n) => {\r\n  let globalKeyCodes: LegacyConfig['keyCodes']\r\n  let instance: ComponentInternalInstance | null = null\r\n  if (__COMPAT__) {\r\n    instance = getCurrentInstance()\r\n    if (\r\n      compatUtils.isCompatEnabled(DeprecationTypes.CONFIG_KEY_CODES, instance)\r\n    ) {\r\n      if (instance) {\r\n        globalKeyCodes = (instance.appContext.config as LegacyConfig).keyCodes\r\n      }\r\n    }\r\n    if (__DEV__ && modifiers.some(m => /^\\d+$/.test(m))) {\r\n      compatUtils.warnDeprecation(\r\n        DeprecationTypes.V_ON_KEYCODE_MODIFIER,\r\n        instance\r\n      )\r\n    }\r\n  }\r\n\r\n  const cache: { [k: string]: T } = fn._withKeys || (fn._withKeys = {})\r\n  const cacheKey = modifiers.join('.')\r\n\r\n  return (\r\n    cache[cacheKey] ||\r\n    (cache[cacheKey] = (event => {\r\n      if (!('key' in event)) {\r\n        return\r\n      }\r\n\r\n      const eventKey = hyphenate(event.key)\r\n      if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n        return fn(event)\r\n      }\r\n\r\n      if (__COMPAT__) {\r\n        const keyCode = String(event.keyCode)\r\n        if (\r\n          compatUtils.isCompatEnabled(\r\n            DeprecationTypes.V_ON_KEYCODE_MODIFIER,\r\n            instance\r\n          ) &&\r\n          modifiers.some(mod => mod == keyCode)\r\n        ) {\r\n          return fn(event)\r\n        }\r\n        if (globalKeyCodes) {\r\n          for (const mod of modifiers) {\r\n            const codes = globalKeyCodes[mod]\r\n            if (codes) {\r\n              const matches = isArray(codes)\r\n                ? codes.some(code => String(code) === keyCode)\r\n                : String(codes) === keyCode\r\n              if (matches) {\r\n                return fn(event)\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }) as T)\r\n  )\r\n}\r\n", "import {\r\n  createRenderer,\r\n  createHydrationRenderer,\r\n  warn,\r\n  RootRenderFunction,\r\n  CreateAppFunction,\r\n  Renderer,\r\n  HydrationRenderer,\r\n  App,\r\n  RootHydrateFunction,\r\n  isRuntimeOnly,\r\n  DeprecationTypes,\r\n  compatUtils\r\n} from '@vue/runtime-core'\r\nimport { nodeOps } from './nodeOps'\r\nimport { patchProp } from './patchProp'\r\n// Importing from the compiler, will be tree-shaken in prod\r\nimport {\r\n  isFunction,\r\n  isString,\r\n  isHTMLTag,\r\n  isSVGTag,\r\n  extend,\r\n  NOOP\r\n} from '@vue/shared'\r\n\r\ndeclare module '@vue/reactivity' {\r\n  export interface RefUnwrapBailTypes {\r\n    runtimeDOMBailTypes: Node | Window\r\n  }\r\n}\r\n\r\nconst rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps)\r\n\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer: Renderer<Element | ShadowRoot> | HydrationRenderer\r\n\r\nlet enabledHydration = false\r\n\r\nfunction ensureRenderer() {\r\n  return (\r\n    renderer ||\r\n    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))\r\n  )\r\n}\r\n\r\nfunction ensureHydrationRenderer() {\r\n  renderer = enabledHydration\r\n    ? renderer\r\n    : createHydrationRenderer(rendererOptions)\r\n  enabledHydration = true\r\n  return renderer as HydrationRenderer\r\n}\r\n\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nexport const render = ((...args) => {\r\n  ensureRenderer().render(...args)\r\n}) as RootRenderFunction<Element | ShadowRoot>\r\n\r\nexport const hydrate = ((...args) => {\r\n  ensureHydrationRenderer().hydrate(...args)\r\n}) as RootHydrateFunction\r\n\r\nexport const createApp = ((...args) => {\r\n  const app = ensureRenderer().createApp(...args)\r\n\r\n  if (__DEV__) {\r\n    injectNativeTagCheck(app)\r\n    injectCompilerOptionsCheck(app)\r\n  }\r\n\r\n  const { mount } = app\r\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\r\n    const container = normalizeContainer(containerOrSelector)\r\n    if (!container) return\r\n\r\n    const component = app._component\r\n    if (!isFunction(component) && !component.render && !component.template) {\r\n      // __UNSAFE__\r\n      // Reason: potential execution of JS expressions in in-DOM template.\r\n      // The user must make sure the in-DOM template is trusted. If it's\r\n      // rendered by the server, the template should not contain any user data.\r\n      component.template = container.innerHTML\r\n      // 2.x compat check\r\n      if (__COMPAT__ && __DEV__) {\r\n        for (let i = 0; i < container.attributes.length; i++) {\r\n          const attr = container.attributes[i]\r\n          if (attr.name !== 'v-cloak' && /^(v-|:|@)/.test(attr.name)) {\r\n            compatUtils.warnDeprecation(\r\n              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,\r\n              null\r\n            )\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // clear content before mounting\r\n    container.innerHTML = ''\r\n    const proxy = mount(container, false, container instanceof SVGElement)\r\n    if (container instanceof Element) {\r\n      container.removeAttribute('v-cloak')\r\n      container.setAttribute('data-v-app', '')\r\n    }\r\n    return proxy\r\n  }\r\n\r\n  return app\r\n}) as CreateAppFunction<Element>\r\n\r\nexport const createSSRApp = ((...args) => {\r\n  const app = ensureHydrationRenderer().createApp(...args)\r\n\r\n  if (__DEV__) {\r\n    injectNativeTagCheck(app)\r\n    injectCompilerOptionsCheck(app)\r\n  }\r\n\r\n  const { mount } = app\r\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\r\n    const container = normalizeContainer(containerOrSelector)\r\n    if (container) {\r\n      return mount(container, true, container instanceof SVGElement)\r\n    }\r\n  }\r\n\r\n  return app\r\n}) as CreateAppFunction<Element>\r\n\r\nfunction injectNativeTagCheck(app: App) {\r\n  // Inject `isNativeTag`\r\n  // this is used for component name validation (dev only)\r\n  Object.defineProperty(app.config, 'isNativeTag', {\r\n    value: (tag: string) => isHTMLTag(tag) || isSVGTag(tag),\r\n    writable: false\r\n  })\r\n}\r\n\r\n// dev only\r\nfunction injectCompilerOptionsCheck(app: App) {\r\n  if (isRuntimeOnly()) {\r\n    const isCustomElement = app.config.isCustomElement\r\n    Object.defineProperty(app.config, 'isCustomElement', {\r\n      get() {\r\n        return isCustomElement\r\n      },\r\n      set() {\r\n        warn(\r\n          `The \\`isCustomElement\\` config option is deprecated. Use ` +\r\n            `\\`compilerOptions.isCustomElement\\` instead.`\r\n        )\r\n      }\r\n    })\r\n\r\n    const compilerOptions = app.config.compilerOptions\r\n    const msg =\r\n      `The \\`compilerOptions\\` config option is only respected when using ` +\r\n      `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\r\n      `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\r\n      `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\r\n      `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\r\n      `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\r\n      `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`\r\n\r\n    Object.defineProperty(app.config, 'compilerOptions', {\r\n      get() {\r\n        warn(msg)\r\n        return compilerOptions\r\n      },\r\n      set() {\r\n        warn(msg)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nfunction normalizeContainer(\r\n  container: Element | ShadowRoot | string\r\n): Element | null {\r\n  if (isString(container)) {\r\n    const res = document.querySelector(container)\r\n    if (__DEV__ && !res) {\r\n      warn(\r\n        `Failed to mount app: mount target selector \"${container}\" returned null.`\r\n      )\r\n    }\r\n    return res\r\n  }\r\n  if (\r\n    __DEV__ &&\r\n    window.ShadowRoot &&\r\n    container instanceof window.ShadowRoot &&\r\n    container.mode === 'closed'\r\n  ) {\r\n    warn(\r\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`\r\n    )\r\n  }\r\n  return container as any\r\n}\r\n\r\n// Custom element support\r\nexport {\r\n  defineCustomElement,\r\n  defineSSRCustomElement,\r\n  VueElement,\r\n  type VueElementConstructor\r\n} from './apiCustomElement'\r\n\r\n// SFC CSS utilities\r\nexport { useCssModule } from './helpers/useCssModule'\r\nexport { useCssVars } from './helpers/useCssVars'\r\n\r\n// DOM-only components\r\nexport { Transition, type TransitionProps } from './components/Transition'\r\nexport {\r\n  TransitionGroup,\r\n  type TransitionGroupProps\r\n} from './components/TransitionGroup'\r\n\r\n// **Internal** DOM-only runtime directive helpers\r\nexport {\r\n  vModelText,\r\n  vModelCheckbox,\r\n  vModelRadio,\r\n  vModelSelect,\r\n  vModelDynamic\r\n} from './directives/vModel'\r\nexport { withModifiers, withKeys } from './directives/vOn'\r\nexport { vShow } from './directives/vShow'\r\n\r\nimport { initVModelForSSR } from './directives/vModel'\r\nimport { initVShowForSSR } from './directives/vShow'\r\n\r\nlet ssrDirectiveInitialized = false\r\n\r\n/**\r\n * @internal\r\n */\r\nexport const initDirectivesForSSR = __SSR__\r\n  ? () => {\r\n      if (!ssrDirectiveInitialized) {\r\n        ssrDirectiveInitialized = true\r\n        initVModelForSSR()\r\n        initVShowForSSR()\r\n      }\r\n    }\r\n  : NOOP\r\n\r\n// re-export everything from core\r\n// h, Component, reactivity API, nextTick, flags & types\r\nexport * from '@vue/runtime-core'\r\n\r\nexport * from './jsx'\r\n", "import { initCustomFormatter } from '@vue/runtime-dom'\r\n\r\nexport function initDev() {\r\n  if (__BROWSER__) {\r\n    /* istanbul ignore if */\r\n    if (!__ESM_BUNDLER__) {\r\n      console.info(\r\n        `You are running a development build of Vue.\\n` +\r\n          `Make sure to use the production build (*.prod.js) when deploying for production.`\r\n      )\r\n    }\r\n\r\n    initCustomFormatter()\r\n  }\r\n}\r\n", "import { SourceLocation } from './ast'\r\n\r\nexport interface CompilerError extends SyntaxError {\r\n  code: number | string\r\n  loc?: SourceLocation\r\n}\r\n\r\nexport interface CoreCompilerError extends CompilerError {\r\n  code: ErrorCodes\r\n}\r\n\r\nexport function defaultOnError(error: CompilerError) {\r\n  throw error\r\n}\r\n\r\nexport function defaultOnWarn(msg: CompilerError) {\r\n  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)\r\n}\r\n\r\ntype InferCompilerError<T> = T extends ErrorCodes\r\n  ? CoreCompilerError\r\n  : CompilerError\r\n\r\nexport function createCompilerError<T extends number>(\r\n  code: T,\r\n  loc?: SourceLocation,\r\n  messages?: { [code: number]: string },\r\n  additionalMessage?: string\r\n): InferCompilerError<T> {\r\n  const msg =\r\n    __DEV__ || !__BROWSER__\r\n      ? (messages || errorMessages)[code] + (additionalMessage || ``)\r\n      : code\r\n  const error = new SyntaxError(String(msg)) as InferCompilerError<T>\r\n  error.code = code\r\n  error.loc = loc\r\n  return error\r\n}\r\n\r\nexport const enum ErrorCodes {\r\n  // parse errors\r\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\r\n  CDATA_IN_HTML_CONTENT,\r\n  DUPLICATE_ATTRIBUTE,\r\n  END_TAG_WITH_ATTRIBUTES,\r\n  END_TAG_WITH_TRAILING_SOLIDUS,\r\n  EOF_BEFORE_TAG_NAME,\r\n  EOF_IN_CDATA,\r\n  EOF_IN_COMMENT,\r\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\r\n  EOF_IN_TAG,\r\n  INCORRECTLY_CLOSED_COMMENT,\r\n  INCORRECTLY_OPENED_COMMENT,\r\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\r\n  MISSING_ATTRIBUTE_VALUE,\r\n  MISSING_END_TAG_NAME,\r\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\r\n  NESTED_COMMENT,\r\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\r\n  UNEXPECTED_NULL_CHARACTER,\r\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n  UNEXPECTED_SOLIDUS_IN_TAG,\r\n\r\n  // Vue-specific parse errors\r\n  X_INVALID_END_TAG,\r\n  X_MISSING_END_TAG,\r\n  X_MISSING_INTERPOLATION_END,\r\n  X_MISSING_DIRECTIVE_NAME,\r\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\r\n\r\n  // transform errors\r\n  X_V_IF_NO_EXPRESSION,\r\n  X_V_IF_SAME_KEY,\r\n  X_V_ELSE_NO_ADJACENT_IF,\r\n  X_V_FOR_NO_EXPRESSION,\r\n  X_V_FOR_MALFORMED_EXPRESSION,\r\n  X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n  X_V_BIND_NO_EXPRESSION,\r\n  X_V_ON_NO_EXPRESSION,\r\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n  X_V_SLOT_MIXED_SLOT_USAGE,\r\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n  X_V_SLOT_MISPLACED,\r\n  X_V_MODEL_NO_EXPRESSION,\r\n  X_V_MODEL_MALFORMED_EXPRESSION,\r\n  X_V_MODEL_ON_SCOPE_VARIABLE,\r\n  X_V_MODEL_ON_PROPS,\r\n  X_INVALID_EXPRESSION,\r\n  X_KEEP_ALIVE_INVALID_CHILDREN,\r\n\r\n  // generic errors\r\n  X_PREFIX_ID_NOT_SUPPORTED,\r\n  X_MODULE_MODE_NOT_SUPPORTED,\r\n  X_CACHE_HANDLER_NOT_SUPPORTED,\r\n  X_SCOPE_ID_NOT_SUPPORTED,\r\n\r\n  // deprecations\r\n  DEPRECATION_VNODE_HOOKS,\r\n  DEPRECATION_V_IS,\r\n\r\n  // Special value for higher-order compilers to pick up the last code\r\n  // to avoid collision of error codes. This should always be kept as the last\r\n  // item.\r\n  __EXTEND_POINT__\r\n}\r\n\r\nexport const errorMessages: Record<ErrorCodes, string> = {\r\n  // parse errors\r\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\r\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\r\n    'CDATA section is allowed only in XML context.',\r\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\r\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\r\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\r\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\r\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\r\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\r\n    'Unexpected EOF in script.',\r\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\r\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\r\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\r\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\r\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\r\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\r\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\r\n    'Whitespace was expected.',\r\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\r\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\r\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\r\n    \"Attribute name cannot start with '='.\",\r\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\r\n    \"'<?' is allowed only in XML context.\",\r\n  [ErrorCodes.UNEXPECTED_NULL_CHARACTER]: `Unexpected null character.`,\r\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\r\n\r\n  // Vue-specific parse errors\r\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\r\n  [ErrorCodes.X_MISSING_END_TAG]: 'Element is missing end tag.',\r\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\r\n    'Interpolation end sign was not found.',\r\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\r\n    'End bracket for dynamic directive argument was not found. ' +\r\n    'Note that dynamic directive argument cannot contain spaces.',\r\n  [ErrorCodes.X_MISSING_DIRECTIVE_NAME]: 'Legal directive name was expected.',\r\n\r\n  // transform errors\r\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\r\n  [ErrorCodes.X_V_IF_SAME_KEY]: `v-if/else branches must use unique keys.`,\r\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\r\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\r\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\r\n  [ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT]: `<template v-for> key should be placed on the <template> tag.`,\r\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\r\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\r\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\r\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\r\n    `Mixed v-slot usage on both the component and nested <template>. ` +\r\n    `When there are multiple named slots, all slots should use <template> ` +\r\n    `syntax to avoid scope ambiguity.`,\r\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\r\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN]:\r\n    `Extraneous children found when component already has explicitly named ` +\r\n    `default slot. These children will be ignored.`,\r\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\r\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\r\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\r\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n  [ErrorCodes.X_V_MODEL_ON_PROPS]: `v-model cannot be used on a prop, because local prop bindings are not writable.\\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\r\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Error parsing JavaScript expression: `,\r\n  [ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN]: `<KeepAlive> expects exactly one child component.`,\r\n\r\n  // generic errors\r\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`,\r\n  [ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n  [ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED]: `\"scopeId\" option is only supported in module mode.`,\r\n\r\n  // deprecations\r\n  [ErrorCodes.DEPRECATION_VNODE_HOOKS]: `@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.`,\r\n  [ErrorCodes.DEPRECATION_V_IS]: `v-is=\"component-name\" has been deprecated. Use is=\"vue:component-name\" instead. v-is support will be removed in 3.4.`,\r\n\r\n  // just to fulfill types\r\n  [ErrorCodes.__EXTEND_POINT__]: ``\r\n}\r\n", "export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\r\nexport const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)\r\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\r\nexport const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)\r\nexport const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)\r\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\r\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\r\nexport const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)\r\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\r\nexport const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)\r\nexport const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)\r\nexport const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)\r\nexport const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)\r\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\r\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\r\n  __DEV__ ? `resolveDynamicComponent` : ``\r\n)\r\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\r\nexport const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)\r\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\r\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\r\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\r\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\r\nexport const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)\r\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\r\nexport const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)\r\nexport const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)\r\nexport const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)\r\nexport const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)\r\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\r\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\r\nexport const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)\r\nexport const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)\r\nexport const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)\r\nexport const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)\r\nexport const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)\r\nexport const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)\r\nexport const UNREF = Symbol(__DEV__ ? `unref` : ``)\r\nexport const IS_REF = Symbol(__DEV__ ? `isRef` : ``)\r\nexport const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)\r\nexport const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)\r\n\r\n// Name mapping for runtime helpers that need to be imported from 'vue' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\nexport const helperNameMap: Record<symbol, string> = {\r\n  [FRAGMENT]: `Fragment`,\r\n  [TELEPORT]: `Teleport`,\r\n  [SUSPENSE]: `Suspense`,\r\n  [KEEP_ALIVE]: `KeepAlive`,\r\n  [BASE_TRANSITION]: `BaseTransition`,\r\n  [OPEN_BLOCK]: `openBlock`,\r\n  [CREATE_BLOCK]: `createBlock`,\r\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\r\n  [CREATE_VNODE]: `createVNode`,\r\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\r\n  [CREATE_COMMENT]: `createCommentVNode`,\r\n  [CREATE_TEXT]: `createTextVNode`,\r\n  [CREATE_STATIC]: `createStaticVNode`,\r\n  [RESOLVE_COMPONENT]: `resolveComponent`,\r\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n  [RESOLVE_FILTER]: `resolveFilter`,\r\n  [WITH_DIRECTIVES]: `withDirectives`,\r\n  [RENDER_LIST]: `renderList`,\r\n  [RENDER_SLOT]: `renderSlot`,\r\n  [CREATE_SLOTS]: `createSlots`,\r\n  [TO_DISPLAY_STRING]: `toDisplayString`,\r\n  [MERGE_PROPS]: `mergeProps`,\r\n  [NORMALIZE_CLASS]: `normalizeClass`,\r\n  [NORMALIZE_STYLE]: `normalizeStyle`,\r\n  [NORMALIZE_PROPS]: `normalizeProps`,\r\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\r\n  [TO_HANDLERS]: `toHandlers`,\r\n  [CAMELIZE]: `camelize`,\r\n  [CAPITALIZE]: `capitalize`,\r\n  [TO_HANDLER_KEY]: `toHandlerKey`,\r\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n  [PUSH_SCOPE_ID]: `pushScopeId`,\r\n  [POP_SCOPE_ID]: `popScopeId`,\r\n  [WITH_CTX]: `withCtx`,\r\n  [UNREF]: `unref`,\r\n  [IS_REF]: `isRef`,\r\n  [WITH_MEMO]: `withMemo`,\r\n  [IS_MEMO_SAME]: `isMemoSame`\r\n}\r\n\r\nexport function registerRuntimeHelpers(helpers: Record<symbol, string>) {\r\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n    helperNameMap[s] = helpers[s]\r\n  })\r\n}\r\n", "import { isString } from '@vue/shared'\r\nimport { ForParseResult } from './transforms/vFor'\r\nimport {\r\n  RENDER_SLOT,\r\n  CREATE_SLOTS,\r\n  RENDER_LIST,\r\n  OPEN_BLOCK,\r\n  FRAGMENT,\r\n  WITH_DIRECTIVES,\r\n  WITH_MEMO,\r\n  CREATE_VNODE,\r\n  CREATE_ELEMENT_VNODE,\r\n  CREATE_BLOCK,\r\n  CREATE_ELEMENT_BLOCK\r\n} from './runtimeHelpers'\r\nimport { PropsExpression } from './transforms/transformElement'\r\nimport { ImportItem, TransformContext } from './transform'\r\n\r\n// Vue template is a platform-agnostic superset of HTML (syntax only).\r\n// More namespaces like SVG and MathML are declared by platform specific\r\n// compilers.\r\nexport type Namespace = number\r\n\r\nexport const enum Namespaces {\r\n  HTML\r\n}\r\n\r\nexport const enum NodeTypes {\r\n  ROOT,\r\n  ELEMENT,\r\n  TEXT,\r\n  COMMENT,\r\n  SIMPLE_EXPRESSION,\r\n  INTERPOLATION,\r\n  ATTRIBUTE,\r\n  DIRECTIVE,\r\n  // containers\r\n  COMPOUND_EXPRESSION,\r\n  IF,\r\n  IF_BRANCH,\r\n  FOR,\r\n  TEXT_CALL,\r\n  // codegen\r\n  VNODE_CALL,\r\n  JS_CALL_EXPRESSION,\r\n  JS_OBJECT_EXPRESSION,\r\n  JS_PROPERTY,\r\n  JS_ARRAY_EXPRESSION,\r\n  JS_FUNCTION_EXPRESSION,\r\n  JS_CONDITIONAL_EXPRESSION,\r\n  JS_CACHE_EXPRESSION,\r\n\r\n  // ssr codegen\r\n  JS_BLOCK_STATEMENT,\r\n  JS_TEMPLATE_LITERAL,\r\n  JS_IF_STATEMENT,\r\n  JS_ASSIGNMENT_EXPRESSION,\r\n  JS_SEQUENCE_EXPRESSION,\r\n  JS_RETURN_STATEMENT\r\n}\r\n\r\nexport const enum ElementTypes {\r\n  ELEMENT,\r\n  COMPONENT,\r\n  SLOT,\r\n  TEMPLATE\r\n}\r\n\r\nexport interface Node {\r\n  type: NodeTypes\r\n  loc: SourceLocation\r\n}\r\n\r\n// The node's range. The `start` is inclusive and `end` is exclusive.\r\n// [start, end)\r\nexport interface SourceLocation {\r\n  start: Position\r\n  end: Position\r\n  source: string\r\n}\r\n\r\nexport interface Position {\r\n  offset: number // from start of file\r\n  line: number\r\n  column: number\r\n}\r\n\r\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\r\n\r\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\r\n\r\nexport type TemplateChildNode =\r\n  | ElementNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n  | TextNode\r\n  | CommentNode\r\n  | IfNode\r\n  | IfBranchNode\r\n  | ForNode\r\n  | TextCallNode\r\n\r\nexport interface RootNode extends Node {\r\n  type: NodeTypes.ROOT\r\n  children: TemplateChildNode[]\r\n  helpers: Set<symbol>\r\n  components: string[]\r\n  directives: string[]\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  cached: number\r\n  temps: number\r\n  ssrHelpers?: symbol[]\r\n  codegenNode?: TemplateChildNode | JSChildNode | BlockStatement\r\n\r\n  // v2 compat only\r\n  filters?: string[]\r\n}\r\n\r\nexport type ElementNode =\r\n  | PlainElementNode\r\n  | ComponentNode\r\n  | SlotOutletNode\r\n  | TemplateNode\r\n\r\nexport interface BaseElementNode extends Node {\r\n  type: NodeTypes.ELEMENT\r\n  ns: Namespace\r\n  tag: string\r\n  tagType: ElementTypes\r\n  isSelfClosing: boolean\r\n  props: Array<AttributeNode | DirectiveNode>\r\n  children: TemplateChildNode[]\r\n}\r\n\r\nexport interface PlainElementNode extends BaseElementNode {\r\n  tagType: ElementTypes.ELEMENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | SimpleExpressionNode // when hoisted\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: TemplateLiteral\r\n}\r\n\r\nexport interface ComponentNode extends BaseElementNode {\r\n  tagType: ElementTypes.COMPONENT\r\n  codegenNode:\r\n    | VNodeCall\r\n    | CacheExpression // when cached by v-once\r\n    | MemoExpression // when cached by v-memo\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface SlotOutletNode extends BaseElementNode {\r\n  tagType: ElementTypes.SLOT\r\n  codegenNode:\r\n    | RenderSlotCall\r\n    | CacheExpression // when cached by v-once\r\n    | undefined\r\n  ssrCodegenNode?: CallExpression\r\n}\r\n\r\nexport interface TemplateNode extends BaseElementNode {\r\n  tagType: ElementTypes.TEMPLATE\r\n  // TemplateNode is a container type that always gets compiled away\r\n  codegenNode: undefined\r\n}\r\n\r\nexport interface TextNode extends Node {\r\n  type: NodeTypes.TEXT\r\n  content: string\r\n}\r\n\r\nexport interface CommentNode extends Node {\r\n  type: NodeTypes.COMMENT\r\n  content: string\r\n}\r\n\r\nexport interface AttributeNode extends Node {\r\n  type: NodeTypes.ATTRIBUTE\r\n  name: string\r\n  value: TextNode | undefined\r\n}\r\n\r\nexport interface DirectiveNode extends Node {\r\n  type: NodeTypes.DIRECTIVE\r\n  name: string\r\n  exp: ExpressionNode | undefined\r\n  arg: ExpressionNode | undefined\r\n  modifiers: string[]\r\n  /**\r\n   * optional property to cache the expression parse result for v-for\r\n   */\r\n  parseResult?: ForParseResult\r\n}\r\n\r\n/**\r\n * Static types have several levels.\r\n * Higher levels implies lower levels. e.g. a node that can be stringified\r\n * can always be hoisted and skipped for patch.\r\n */\r\nexport const enum ConstantTypes {\r\n  NOT_CONSTANT = 0,\r\n  CAN_SKIP_PATCH,\r\n  CAN_HOIST,\r\n  CAN_STRINGIFY\r\n}\r\n\r\nexport interface SimpleExpressionNode extends Node {\r\n  type: NodeTypes.SIMPLE_EXPRESSION\r\n  content: string\r\n  isStatic: boolean\r\n  constType: ConstantTypes\r\n  /**\r\n   * Indicates this is an identifier for a hoist vnode call and points to the\r\n   * hoisted node.\r\n   */\r\n  hoisted?: JSChildNode\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface InterpolationNode extends Node {\r\n  type: NodeTypes.INTERPOLATION\r\n  content: ExpressionNode\r\n}\r\n\r\nexport interface CompoundExpressionNode extends Node {\r\n  type: NodeTypes.COMPOUND_EXPRESSION\r\n  children: (\r\n    | SimpleExpressionNode\r\n    | CompoundExpressionNode\r\n    | InterpolationNode\r\n    | TextNode\r\n    | string\r\n    | symbol\r\n  )[]\r\n\r\n  /**\r\n   * an expression parsed as the params of a function will track\r\n   * the identifiers declared inside the function body.\r\n   */\r\n  identifiers?: string[]\r\n  isHandlerKey?: boolean\r\n}\r\n\r\nexport interface IfNode extends Node {\r\n  type: NodeTypes.IF\r\n  branches: IfBranchNode[]\r\n  codegenNode?: IfConditionalExpression | CacheExpression // <div v-if v-once>\r\n}\r\n\r\nexport interface IfBranchNode extends Node {\r\n  type: NodeTypes.IF_BRANCH\r\n  condition: ExpressionNode | undefined // else\r\n  children: TemplateChildNode[]\r\n  userKey?: AttributeNode | DirectiveNode\r\n  isTemplateIf?: boolean\r\n}\r\n\r\nexport interface ForNode extends Node {\r\n  type: NodeTypes.FOR\r\n  source: ExpressionNode\r\n  valueAlias: ExpressionNode | undefined\r\n  keyAlias: ExpressionNode | undefined\r\n  objectIndexAlias: ExpressionNode | undefined\r\n  parseResult: ForParseResult\r\n  children: TemplateChildNode[]\r\n  codegenNode?: ForCodegenNode\r\n}\r\n\r\nexport interface TextCallNode extends Node {\r\n  type: NodeTypes.TEXT_CALL\r\n  content: TextNode | InterpolationNode | CompoundExpressionNode\r\n  codegenNode: CallExpression | SimpleExpressionNode // when hoisted\r\n}\r\n\r\nexport type TemplateTextChildNode =\r\n  | TextNode\r\n  | InterpolationNode\r\n  | CompoundExpressionNode\r\n\r\nexport interface VNodeCall extends Node {\r\n  type: NodeTypes.VNODE_CALL\r\n  tag: string | symbol | CallExpression\r\n  props: PropsExpression | undefined\r\n  children:\r\n    | TemplateChildNode[] // multiple children\r\n    | TemplateTextChildNode // single text child\r\n    | SlotsExpression // component slots\r\n    | ForRenderListExpression // v-for fragment call\r\n    | SimpleExpressionNode // hoisted\r\n    | undefined\r\n  patchFlag: string | undefined\r\n  dynamicProps: string | SimpleExpressionNode | undefined\r\n  directives: DirectiveArguments | undefined\r\n  isBlock: boolean\r\n  disableTracking: boolean\r\n  isComponent: boolean\r\n}\r\n\r\n// JS Node Types ---------------------------------------------------------------\r\n\r\n// We also include a number of JavaScript AST nodes for code generation.\r\n// The AST is an intentionally minimal subset just to meet the exact needs of\r\n// Vue render function generation.\r\n\r\nexport type JSChildNode =\r\n  | VNodeCall\r\n  | CallExpression\r\n  | ObjectExpression\r\n  | ArrayExpression\r\n  | ExpressionNode\r\n  | FunctionExpression\r\n  | ConditionalExpression\r\n  | CacheExpression\r\n  | AssignmentExpression\r\n  | SequenceExpression\r\n\r\nexport interface CallExpression extends Node {\r\n  type: NodeTypes.JS_CALL_EXPRESSION\r\n  callee: string | symbol\r\n  arguments: (\r\n    | string\r\n    | symbol\r\n    | JSChildNode\r\n    | SSRCodegenNode\r\n    | TemplateChildNode\r\n    | TemplateChildNode[]\r\n  )[]\r\n}\r\n\r\nexport interface ObjectExpression extends Node {\r\n  type: NodeTypes.JS_OBJECT_EXPRESSION\r\n  properties: Array<Property>\r\n}\r\n\r\nexport interface Property extends Node {\r\n  type: NodeTypes.JS_PROPERTY\r\n  key: ExpressionNode\r\n  value: JSChildNode\r\n}\r\n\r\nexport interface ArrayExpression extends Node {\r\n  type: NodeTypes.JS_ARRAY_EXPRESSION\r\n  elements: Array<string | Node>\r\n}\r\n\r\nexport interface FunctionExpression extends Node {\r\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\r\n  params: ExpressionNode | string | (ExpressionNode | string)[] | undefined\r\n  returns?: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n  body?: BlockStatement | IfStatement\r\n  newline: boolean\r\n  /**\r\n   * This flag is for codegen to determine whether it needs to generate the\r\n   * withScopeId() wrapper\r\n   */\r\n  isSlot: boolean\r\n  /**\r\n   * __COMPAT__ only, indicates a slot function that should be excluded from\r\n   * the legacy $scopedSlots instance property.\r\n   */\r\n  isNonScopedSlot?: boolean\r\n}\r\n\r\nexport interface ConditionalExpression extends Node {\r\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  test: JSChildNode\r\n  consequent: JSChildNode\r\n  alternate: JSChildNode\r\n  newline: boolean\r\n}\r\n\r\nexport interface CacheExpression extends Node {\r\n  type: NodeTypes.JS_CACHE_EXPRESSION\r\n  index: number\r\n  value: JSChildNode\r\n  isVNode: boolean\r\n}\r\n\r\nexport interface MemoExpression extends CallExpression {\r\n  callee: typeof WITH_MEMO\r\n  arguments: [ExpressionNode, MemoFactory, string, string]\r\n}\r\n\r\ninterface MemoFactory extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// SSR-specific Node Types -----------------------------------------------------\r\n\r\nexport type SSRCodegenNode =\r\n  | BlockStatement\r\n  | TemplateLiteral\r\n  | IfStatement\r\n  | AssignmentExpression\r\n  | ReturnStatement\r\n  | SequenceExpression\r\n\r\nexport interface BlockStatement extends Node {\r\n  type: NodeTypes.JS_BLOCK_STATEMENT\r\n  body: (JSChildNode | IfStatement)[]\r\n}\r\n\r\nexport interface TemplateLiteral extends Node {\r\n  type: NodeTypes.JS_TEMPLATE_LITERAL\r\n  elements: (string | JSChildNode)[]\r\n}\r\n\r\nexport interface IfStatement extends Node {\r\n  type: NodeTypes.JS_IF_STATEMENT\r\n  test: ExpressionNode\r\n  consequent: BlockStatement\r\n  alternate: IfStatement | BlockStatement | ReturnStatement | undefined\r\n}\r\n\r\nexport interface AssignmentExpression extends Node {\r\n  type: NodeTypes.JS_ASSIGNMENT_EXPRESSION\r\n  left: SimpleExpressionNode\r\n  right: JSChildNode\r\n}\r\n\r\nexport interface SequenceExpression extends Node {\r\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\r\n  expressions: JSChildNode[]\r\n}\r\n\r\nexport interface ReturnStatement extends Node {\r\n  type: NodeTypes.JS_RETURN_STATEMENT\r\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\r\n}\r\n\r\n// Codegen Node Types ----------------------------------------------------------\r\n\r\nexport interface DirectiveArguments extends ArrayExpression {\r\n  elements: DirectiveArgumentNode[]\r\n}\r\n\r\nexport interface DirectiveArgumentNode extends ArrayExpression {\r\n  elements: // dir, exp, arg, modifiers\r\n  | [string]\r\n    | [string, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode]\r\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\r\n}\r\n\r\n// renderSlot(...)\r\nexport interface RenderSlotCall extends CallExpression {\r\n  callee: typeof RENDER_SLOT\r\n  arguments: // $slots, name, props, fallback\r\n  | [string, string | ExpressionNode]\r\n    | [string, string | ExpressionNode, PropsExpression]\r\n    | [\r\n        string,\r\n        string | ExpressionNode,\r\n        PropsExpression | '{}',\r\n        TemplateChildNode[]\r\n      ]\r\n}\r\n\r\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\r\n\r\n// { foo: () => [...] }\r\nexport interface SlotsObjectExpression extends ObjectExpression {\r\n  properties: SlotsObjectProperty[]\r\n}\r\n\r\nexport interface SlotsObjectProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport interface SlotFunctionExpression extends FunctionExpression {\r\n  returns: TemplateChildNode[]\r\n}\r\n\r\n// createSlots({ ... }, [\r\n//    foo ? () => [] : undefined,\r\n//    renderList(list, i => () => [i])\r\n// ])\r\nexport interface DynamicSlotsExpression extends CallExpression {\r\n  callee: typeof CREATE_SLOTS\r\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\r\n}\r\n\r\nexport interface DynamicSlotEntries extends ArrayExpression {\r\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\r\n}\r\n\r\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\r\n  consequent: DynamicSlotNode\r\n  alternate: DynamicSlotNode | SimpleExpressionNode\r\n}\r\n\r\nexport interface ListDynamicSlotNode extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\r\n}\r\n\r\nexport interface ListDynamicSlotIterator extends FunctionExpression {\r\n  returns: DynamicSlotNode\r\n}\r\n\r\nexport interface DynamicSlotNode extends ObjectExpression {\r\n  properties: [Property, DynamicSlotFnProperty]\r\n}\r\n\r\nexport interface DynamicSlotFnProperty extends Property {\r\n  value: SlotFunctionExpression\r\n}\r\n\r\nexport type BlockCodegenNode = VNodeCall | RenderSlotCall\r\n\r\nexport interface IfConditionalExpression extends ConditionalExpression {\r\n  consequent: BlockCodegenNode | MemoExpression\r\n  alternate: BlockCodegenNode | IfConditionalExpression | MemoExpression\r\n}\r\n\r\nexport interface ForCodegenNode extends VNodeCall {\r\n  isBlock: true\r\n  tag: typeof FRAGMENT\r\n  props: undefined\r\n  children: ForRenderListExpression\r\n  patchFlag: string\r\n  disableTracking: boolean\r\n}\r\n\r\nexport interface ForRenderListExpression extends CallExpression {\r\n  callee: typeof RENDER_LIST\r\n  arguments: [ExpressionNode, ForIteratorExpression]\r\n}\r\n\r\nexport interface ForIteratorExpression extends FunctionExpression {\r\n  returns: BlockCodegenNode\r\n}\r\n\r\n// AST Utilities ---------------------------------------------------------------\r\n\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don't need a real location.\r\nexport const locStub: SourceLocation = {\r\n  source: '',\r\n  start: { line: 1, column: 1, offset: 0 },\r\n  end: { line: 1, column: 1, offset: 0 }\r\n}\r\n\r\nexport function createRoot(\r\n  children: TemplateChildNode[],\r\n  loc = locStub\r\n): RootNode {\r\n  return {\r\n    type: NodeTypes.ROOT,\r\n    children,\r\n    helpers: new Set(),\r\n    components: [],\r\n    directives: [],\r\n    hoists: [],\r\n    imports: [],\r\n    cached: 0,\r\n    temps: 0,\r\n    codegenNode: undefined,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createVNodeCall(\r\n  context: TransformContext | null,\r\n  tag: VNodeCall['tag'],\r\n  props?: VNodeCall['props'],\r\n  children?: VNodeCall['children'],\r\n  patchFlag?: VNodeCall['patchFlag'],\r\n  dynamicProps?: VNodeCall['dynamicProps'],\r\n  directives?: VNodeCall['directives'],\r\n  isBlock: VNodeCall['isBlock'] = false,\r\n  disableTracking: VNodeCall['disableTracking'] = false,\r\n  isComponent: VNodeCall['isComponent'] = false,\r\n  loc = locStub\r\n): VNodeCall {\r\n  if (context) {\r\n    if (isBlock) {\r\n      context.helper(OPEN_BLOCK)\r\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\r\n    } else {\r\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\r\n    }\r\n    if (directives) {\r\n      context.helper(WITH_DIRECTIVES)\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.VNODE_CALL,\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createArrayExpression(\r\n  elements: ArrayExpression['elements'],\r\n  loc: SourceLocation = locStub\r\n): ArrayExpression {\r\n  return {\r\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\r\n    loc,\r\n    elements\r\n  }\r\n}\r\n\r\nexport function createObjectExpression(\r\n  properties: ObjectExpression['properties'],\r\n  loc: SourceLocation = locStub\r\n): ObjectExpression {\r\n  return {\r\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\r\n    loc,\r\n    properties\r\n  }\r\n}\r\n\r\nexport function createObjectProperty(\r\n  key: Property['key'] | string,\r\n  value: Property['value']\r\n): Property {\r\n  return {\r\n    type: NodeTypes.JS_PROPERTY,\r\n    loc: locStub,\r\n    key: isString(key) ? createSimpleExpression(key, true) : key,\r\n    value\r\n  }\r\n}\r\n\r\nexport function createSimpleExpression(\r\n  content: SimpleExpressionNode['content'],\r\n  isStatic: SimpleExpressionNode['isStatic'] = false,\r\n  loc: SourceLocation = locStub,\r\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT\r\n): SimpleExpressionNode {\r\n  return {\r\n    type: NodeTypes.SIMPLE_EXPRESSION,\r\n    loc,\r\n    content,\r\n    isStatic,\r\n    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType\r\n  }\r\n}\r\n\r\nexport function createInterpolation(\r\n  content: InterpolationNode['content'] | string,\r\n  loc: SourceLocation\r\n): InterpolationNode {\r\n  return {\r\n    type: NodeTypes.INTERPOLATION,\r\n    loc,\r\n    content: isString(content)\r\n      ? createSimpleExpression(content, false, loc)\r\n      : content\r\n  }\r\n}\r\n\r\nexport function createCompoundExpression(\r\n  children: CompoundExpressionNode['children'],\r\n  loc: SourceLocation = locStub\r\n): CompoundExpressionNode {\r\n  return {\r\n    type: NodeTypes.COMPOUND_EXPRESSION,\r\n    loc,\r\n    children\r\n  }\r\n}\r\n\r\ntype InferCodegenNodeType<T> = T extends typeof RENDER_SLOT\r\n  ? RenderSlotCall\r\n  : CallExpression\r\n\r\nexport function createCallExpression<T extends CallExpression['callee']>(\r\n  callee: T,\r\n  args: CallExpression['arguments'] = [],\r\n  loc: SourceLocation = locStub\r\n): InferCodegenNodeType<T> {\r\n  return {\r\n    type: NodeTypes.JS_CALL_EXPRESSION,\r\n    loc,\r\n    callee,\r\n    arguments: args\r\n  } as InferCodegenNodeType<T>\r\n}\r\n\r\nexport function createFunctionExpression(\r\n  params: FunctionExpression['params'],\r\n  returns: FunctionExpression['returns'] = undefined,\r\n  newline: boolean = false,\r\n  isSlot: boolean = false,\r\n  loc: SourceLocation = locStub\r\n): FunctionExpression {\r\n  return {\r\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\r\n    params,\r\n    returns,\r\n    newline,\r\n    isSlot,\r\n    loc\r\n  }\r\n}\r\n\r\nexport function createConditionalExpression(\r\n  test: ConditionalExpression['test'],\r\n  consequent: ConditionalExpression['consequent'],\r\n  alternate: ConditionalExpression['alternate'],\r\n  newline = true\r\n): ConditionalExpression {\r\n  return {\r\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    newline,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createCacheExpression(\r\n  index: number,\r\n  value: JSChildNode,\r\n  isVNode: boolean = false\r\n): CacheExpression {\r\n  return {\r\n    type: NodeTypes.JS_CACHE_EXPRESSION,\r\n    index,\r\n    value,\r\n    isVNode,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createBlockStatement(\r\n  body: BlockStatement['body']\r\n): BlockStatement {\r\n  return {\r\n    type: NodeTypes.JS_BLOCK_STATEMENT,\r\n    body,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createTemplateLiteral(\r\n  elements: TemplateLiteral['elements']\r\n): TemplateLiteral {\r\n  return {\r\n    type: NodeTypes.JS_TEMPLATE_LITERAL,\r\n    elements,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createIfStatement(\r\n  test: IfStatement['test'],\r\n  consequent: IfStatement['consequent'],\r\n  alternate?: IfStatement['alternate']\r\n): IfStatement {\r\n  return {\r\n    type: NodeTypes.JS_IF_STATEMENT,\r\n    test,\r\n    consequent,\r\n    alternate,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createAssignmentExpression(\r\n  left: AssignmentExpression['left'],\r\n  right: AssignmentExpression['right']\r\n): AssignmentExpression {\r\n  return {\r\n    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,\r\n    left,\r\n    right,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createSequenceExpression(\r\n  expressions: SequenceExpression['expressions']\r\n): SequenceExpression {\r\n  return {\r\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\r\n    expressions,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function createReturnStatement(\r\n  returns: ReturnStatement['returns']\r\n): ReturnStatement {\r\n  return {\r\n    type: NodeTypes.JS_RETURN_STATEMENT,\r\n    returns,\r\n    loc: locStub\r\n  }\r\n}\r\n\r\nexport function getVNodeHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE\r\n}\r\n\r\nexport function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {\r\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK\r\n}\r\n\r\nexport function convertToBlock(\r\n  node: VNodeCall,\r\n  { helper, removeHelper, inSSR }: TransformContext\r\n) {\r\n  if (!node.isBlock) {\r\n    node.isBlock = true\r\n    removeHelper(getVNodeHelper(inSSR, node.isComponent))\r\n    helper(OPEN_BLOCK)\r\n    helper(getVNodeBlockHelper(inSSR, node.isComponent))\r\n  }\r\n}\r\n", "import {\r\n  SourceLocation,\r\n  Position,\r\n  ElementNode,\r\n  NodeTypes,\r\n  CallExpression,\r\n  createCallExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  TemplateChildNode,\r\n  RootNode,\r\n  ObjectExpression,\r\n  Property,\r\n  JSChildNode,\r\n  createObjectExpression,\r\n  SlotOutletNode,\r\n  TemplateNode,\r\n  RenderSlotCall,\r\n  ExpressionNode,\r\n  IfBranchNode,\r\n  TextNode,\r\n  InterpolationNode,\r\n  VNodeCall,\r\n  SimpleExpressionNode,\r\n  BlockCodegenNode,\r\n  MemoExpression\r\n} from './ast'\r\nimport { TransformContext } from './transform'\r\nimport {\r\n  MERGE_PROPS,\r\n  TELEPORT,\r\n  SUSPENSE,\r\n  KEEP_ALIVE,\r\n  BASE_TRANSITION,\r\n  TO_HANDLERS,\r\n  NORMALIZE_PROPS,\r\n  GUARD_REACTIVE_PROPS,\r\n  WITH_MEMO\r\n} from './runtimeHelpers'\r\nimport { isString, isObject, hyphenate, extend, NOOP } from '@vue/shared'\r\nimport { PropsExpression } from './transforms/transformElement'\r\nimport { parseExpression } from '@babel/parser'\r\nimport { Expression } from '@babel/types'\r\n\r\nexport const isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\r\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\r\n\r\nexport const isBuiltInType = (tag: string, expected: string): boolean =>\r\n  tag === expected || tag === hyphenate(expected)\r\n\r\nexport function isCoreComponent(tag: string): symbol | void {\r\n  if (isBuiltInType(tag, 'Teleport')) {\r\n    return TELEPORT\r\n  } else if (isBuiltInType(tag, 'Suspense')) {\r\n    return SUSPENSE\r\n  } else if (isBuiltInType(tag, 'KeepAlive')) {\r\n    return KEEP_ALIVE\r\n  } else if (isBuiltInType(tag, 'BaseTransition')) {\r\n    return BASE_TRANSITION\r\n  }\r\n}\r\n\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\r\nexport const isSimpleIdentifier = (name: string): boolean =>\r\n  !nonIdentifierRE.test(name)\r\n\r\nconst enum MemberExpLexState {\r\n  inMemberExp,\r\n  inBrackets,\r\n  inParens,\r\n  inString\r\n}\r\n\r\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/\r\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/\r\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g\r\n\r\n/**\r\n * Simple lexer to check if an expression is a member expression. This is\r\n * lax and only checks validity at the root level (i.e. does not validate exps\r\n * inside square brackets), but it's ok since these are only used on template\r\n * expressions and false positives are invalid expressions in the first place.\r\n */\r\nexport const isMemberExpressionBrowser = (path: string): boolean => {\r\n  // remove whitespaces around . or [ first\r\n  path = path.trim().replace(whitespaceRE, s => s.trim())\r\n\r\n  let state = MemberExpLexState.inMemberExp\r\n  let stateStack: MemberExpLexState[] = []\r\n  let currentOpenBracketCount = 0\r\n  let currentOpenParensCount = 0\r\n  let currentStringType: \"'\" | '\"' | '`' | null = null\r\n\r\n  for (let i = 0; i < path.length; i++) {\r\n    const char = path.charAt(i)\r\n    switch (state) {\r\n      case MemberExpLexState.inMemberExp:\r\n        if (char === '[') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inBrackets\r\n          currentOpenBracketCount++\r\n        } else if (char === '(') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inParens\r\n          currentOpenParensCount++\r\n        } else if (\r\n          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)\r\n        ) {\r\n          return false\r\n        }\r\n        break\r\n      case MemberExpLexState.inBrackets:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `[`) {\r\n          currentOpenBracketCount++\r\n        } else if (char === `]`) {\r\n          if (!--currentOpenBracketCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inParens:\r\n        if (char === `'` || char === `\"` || char === '`') {\r\n          stateStack.push(state)\r\n          state = MemberExpLexState.inString\r\n          currentStringType = char\r\n        } else if (char === `(`) {\r\n          currentOpenParensCount++\r\n        } else if (char === `)`) {\r\n          // if the exp ends as a call then it should not be considered valid\r\n          if (i === path.length - 1) {\r\n            return false\r\n          }\r\n          if (!--currentOpenParensCount) {\r\n            state = stateStack.pop()!\r\n          }\r\n        }\r\n        break\r\n      case MemberExpLexState.inString:\r\n        if (char === currentStringType) {\r\n          state = stateStack.pop()!\r\n          currentStringType = null\r\n        }\r\n        break\r\n    }\r\n  }\r\n  return !currentOpenBracketCount && !currentOpenParensCount\r\n}\r\n\r\nexport const isMemberExpressionNode = __BROWSER__\r\n  ? (NOOP as any as (path: string, context: TransformContext) => boolean)\r\n  : (path: string, context: TransformContext): boolean => {\r\n      try {\r\n        let ret: Expression = parseExpression(path, {\r\n          plugins: context.expressionPlugins\r\n        })\r\n        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {\r\n          ret = ret.expression\r\n        }\r\n        return (\r\n          ret.type === 'MemberExpression' ||\r\n          ret.type === 'OptionalMemberExpression' ||\r\n          (ret.type === 'Identifier' && ret.name !== 'undefined')\r\n        )\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n\r\nexport const isMemberExpression = __BROWSER__\r\n  ? isMemberExpressionBrowser\r\n  : isMemberExpressionNode\r\n\r\nexport function getInnerRange(\r\n  loc: SourceLocation,\r\n  offset: number,\r\n  length: number\r\n): SourceLocation {\r\n  __TEST__ && assert(offset <= loc.source.length)\r\n  const source = loc.source.slice(offset, offset + length)\r\n  const newLoc: SourceLocation = {\r\n    source,\r\n    start: advancePositionWithClone(loc.start, loc.source, offset),\r\n    end: loc.end\r\n  }\r\n\r\n  if (length != null) {\r\n    __TEST__ && assert(offset + length <= loc.source.length)\r\n    newLoc.end = advancePositionWithClone(\r\n      loc.start,\r\n      loc.source,\r\n      offset + length\r\n    )\r\n  }\r\n\r\n  return newLoc\r\n}\r\n\r\nexport function advancePositionWithClone(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length\r\n): Position {\r\n  return advancePositionWithMutation(\r\n    extend({}, pos),\r\n    source,\r\n    numberOfCharacters\r\n  )\r\n}\r\n\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nexport function advancePositionWithMutation(\r\n  pos: Position,\r\n  source: string,\r\n  numberOfCharacters: number = source.length\r\n): Position {\r\n  let linesCount = 0\r\n  let lastNewLinePos = -1\r\n  for (let i = 0; i < numberOfCharacters; i++) {\r\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n      linesCount++\r\n      lastNewLinePos = i\r\n    }\r\n  }\r\n\r\n  pos.offset += numberOfCharacters\r\n  pos.line += linesCount\r\n  pos.column =\r\n    lastNewLinePos === -1\r\n      ? pos.column + numberOfCharacters\r\n      : numberOfCharacters - lastNewLinePos\r\n\r\n  return pos\r\n}\r\n\r\nexport function assert(condition: boolean, msg?: string) {\r\n  /* istanbul ignore if */\r\n  if (!condition) {\r\n    throw new Error(msg || `unexpected compiler condition`)\r\n  }\r\n}\r\n\r\nexport function findDir(\r\n  node: ElementNode,\r\n  name: string | RegExp,\r\n  allowEmpty: boolean = false\r\n): DirectiveNode | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      (allowEmpty || p.exp) &&\r\n      (isString(name) ? p.name === name : name.test(p.name))\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function findProp(\r\n  node: ElementNode,\r\n  name: string,\r\n  dynamicOnly: boolean = false,\r\n  allowEmpty: boolean = false\r\n): ElementNode['props'][0] | undefined {\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (dynamicOnly) continue\r\n      if (p.name === name && (p.value || allowEmpty)) {\r\n        return p\r\n      }\r\n    } else if (\r\n      p.name === 'bind' &&\r\n      (p.exp || allowEmpty) &&\r\n      isStaticArgOf(p.arg, name)\r\n    ) {\r\n      return p\r\n    }\r\n  }\r\n}\r\n\r\nexport function isStaticArgOf(\r\n  arg: DirectiveNode['arg'],\r\n  name: string\r\n): boolean {\r\n  return !!(arg && isStaticExp(arg) && arg.content === name)\r\n}\r\n\r\nexport function hasDynamicKeyVBind(node: ElementNode): boolean {\r\n  return node.props.some(\r\n    p =>\r\n      p.type === NodeTypes.DIRECTIVE &&\r\n      p.name === 'bind' &&\r\n      (!p.arg || // v-bind=\"obj\"\r\n        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]\r\n        !p.arg.isStatic) // v-bind:[foo]\r\n  )\r\n}\r\n\r\nexport function isText(\r\n  node: TemplateChildNode\r\n): node is TextNode | InterpolationNode {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\r\n}\r\n\r\nexport function isVSlot(p: ElementNode['props'][0]): p is DirectiveNode {\r\n  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\r\n}\r\n\r\nexport function isTemplateNode(\r\n  node: RootNode | TemplateChildNode\r\n): node is TemplateNode {\r\n  return (\r\n    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\r\n  )\r\n}\r\n\r\nexport function isSlotOutlet(\r\n  node: RootNode | TemplateChildNode\r\n): node is SlotOutletNode {\r\n  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\r\n}\r\n\r\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])\r\n\r\nfunction getUnnormalizedProps(\r\n  props: PropsExpression | '{}',\r\n  callPath: CallExpression[] = []\r\n): [PropsExpression | '{}', CallExpression[]] {\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const callee = props.callee\r\n    if (!isString(callee) && propsHelperSet.has(callee)) {\r\n      return getUnnormalizedProps(\r\n        props.arguments[0] as PropsExpression,\r\n        callPath.concat(props)\r\n      )\r\n    }\r\n  }\r\n  return [props, callPath]\r\n}\r\nexport function injectProp(\r\n  node: VNodeCall | RenderSlotCall,\r\n  prop: Property,\r\n  context: TransformContext\r\n) {\r\n  let propsWithInjection: ObjectExpression | CallExpression | undefined\r\n  /**\r\n   * 1. mergeProps(...)\r\n   * 2. toHandlers(...)\r\n   * 3. normalizeProps(...)\r\n   * 4. normalizeProps(guardReactiveProps(...))\r\n   *\r\n   * we need to get the real props before normalization\r\n   */\r\n  let props =\r\n    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]\r\n  let callPath: CallExpression[] = []\r\n  let parentCall: CallExpression | undefined\r\n  if (\r\n    props &&\r\n    !isString(props) &&\r\n    props.type === NodeTypes.JS_CALL_EXPRESSION\r\n  ) {\r\n    const ret = getUnnormalizedProps(props)\r\n    props = ret[0]\r\n    callPath = ret[1]\r\n    parentCall = callPath[callPath.length - 1]\r\n  }\r\n\r\n  if (props == null || isString(props)) {\r\n    propsWithInjection = createObjectExpression([prop])\r\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n    // merged props... add ours\r\n    // only inject key to object literal if it's the first argument so that\r\n    // if doesn't override user provided keys\r\n    const first = props.arguments[0] as string | JSChildNode\r\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n      // #6631\r\n      if (!hasProp(prop, first)) {\r\n        first.properties.unshift(prop)\r\n      }\r\n    } else {\r\n      if (props.callee === TO_HANDLERS) {\r\n        // #2366\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n          createObjectExpression([prop]),\r\n          props\r\n        ])\r\n      } else {\r\n        props.arguments.unshift(createObjectExpression([prop]))\r\n      }\r\n    }\r\n    !propsWithInjection && (propsWithInjection = props)\r\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    if (!hasProp(prop, props)) {\r\n      props.properties.unshift(prop)\r\n    }\r\n    propsWithInjection = props\r\n  } else {\r\n    // single v-bind with expression, return a merged replacement\r\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n      createObjectExpression([prop]),\r\n      props\r\n    ])\r\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\r\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\r\n    // the `guardReactiveProps` will no longer be needed\r\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\r\n      parentCall = callPath[callPath.length - 2]\r\n    }\r\n  }\r\n  if (node.type === NodeTypes.VNODE_CALL) {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.props = propsWithInjection\r\n    }\r\n  } else {\r\n    if (parentCall) {\r\n      parentCall.arguments[0] = propsWithInjection\r\n    } else {\r\n      node.arguments[2] = propsWithInjection\r\n    }\r\n  }\r\n}\r\n\r\n// check existing key to avoid overriding user provided keys\r\nfunction hasProp(prop: Property, props: ObjectExpression) {\r\n  let result = false\r\n  if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const propKeyName = prop.key.content\r\n    result = props.properties.some(\r\n      p =>\r\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        p.key.content === propKeyName\r\n    )\r\n  }\r\n  return result\r\n}\r\n\r\nexport function toValidAssetId(\r\n  name: string,\r\n  type: 'component' | 'directive' | 'filter'\r\n): string {\r\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\r\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\r\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()\r\n  })}`\r\n}\r\n\r\n// Check if a node contains expressions that reference current context scope ids\r\nexport function hasScopeRef(\r\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\r\n  ids: TransformContext['identifiers']\r\n): boolean {\r\n  if (!node || Object.keys(ids).length === 0) {\r\n    return false\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i]\r\n        if (\r\n          p.type === NodeTypes.DIRECTIVE &&\r\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.FOR:\r\n      if (hasScopeRef(node.source, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.IF:\r\n      return node.branches.some(b => hasScopeRef(b, ids))\r\n    case NodeTypes.IF_BRANCH:\r\n      if (hasScopeRef(node.condition, ids)) {\r\n        return true\r\n      }\r\n      return node.children.some(c => hasScopeRef(c, ids))\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return (\r\n        !node.isStatic &&\r\n        isSimpleIdentifier(node.content) &&\r\n        !!ids[node.content]\r\n      )\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return hasScopeRef(node.content, ids)\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return false\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return false\r\n  }\r\n}\r\n\r\nexport function getMemoedVNodeCall(node: BlockCodegenNode | MemoExpression) {\r\n  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {\r\n    return node.arguments[1].returns as VNodeCall\r\n  } else {\r\n    return node\r\n  }\r\n}\r\n\r\nexport const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\r\n", "import { ErrorHandlingOptions, ParserOptions } from './options'\r\nimport { NO, isArray, makeMap, extend } from '@vue/shared'\r\nimport {\r\n  ErrorCodes,\r\n  createCompilerError,\r\n  defaultOnError,\r\n  defaultOnWarn\r\n} from './errors'\r\nimport {\r\n  assert,\r\n  advancePositionWithMutation,\r\n  advancePositionWithClone,\r\n  isCoreComponent,\r\n  isStaticArgOf\r\n} from './utils'\r\nimport {\r\n  Namespaces,\r\n  AttributeNode,\r\n  CommentNode,\r\n  DirectiveNode,\r\n  ElementNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  Position,\r\n  RootNode,\r\n  SourceLocation,\r\n  TextNode,\r\n  TemplateChildNode,\r\n  InterpolationNode,\r\n  createRoot,\r\n  ConstantTypes\r\n} from './ast'\r\nimport {\r\n  checkCompatEnabled,\r\n  CompilerCompatOptions,\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled,\r\n  warnDeprecation\r\n} from './compat/compatConfig'\r\n\r\ntype OptionalOptions =\r\n  | 'whitespace'\r\n  | 'isNativeTag'\r\n  | 'isBuiltInComponent'\r\n  | keyof CompilerCompatOptions\r\ntype MergedParserOptions = Omit<Required<ParserOptions>, OptionalOptions> &\r\n  Pick<ParserOptions, OptionalOptions>\r\ntype AttributeValue =\r\n  | {\r\n      content: string\r\n      isQuoted: boolean\r\n      loc: SourceLocation\r\n    }\r\n  | undefined\r\n\r\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g\r\nconst decodeMap: Record<string, string> = {\r\n  gt: '>',\r\n  lt: '<',\r\n  amp: '&',\r\n  apos: \"'\",\r\n  quot: '\"'\r\n}\r\n\r\nexport const defaultParserOptions: MergedParserOptions = {\r\n  delimiters: [`{{`, `}}`],\r\n  getNamespace: () => Namespaces.HTML,\r\n  getTextMode: () => TextModes.DATA,\r\n  isVoidTag: NO,\r\n  isPreTag: NO,\r\n  isCustomElement: NO,\r\n  decodeEntities: (rawText: string): string =>\r\n    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n  onError: defaultOnError,\r\n  onWarn: defaultOnWarn,\r\n  comments: __DEV__\r\n}\r\n\r\nexport const enum TextModes {\r\n  //          | Elements | Entities | End sign              | Inside of\r\n  DATA, //    | \u2714        | \u2714        | End tags of ancestors |\r\n  RCDATA, //  | \u2718        | \u2714        | End tag of the parent | <textarea>\r\n  RAWTEXT, // | \u2718        | \u2718        | End tag of the parent | <style>,<script>\r\n  CDATA,\r\n  ATTRIBUTE_VALUE\r\n}\r\n\r\nexport interface ParserContext {\r\n  options: MergedParserOptions\r\n  readonly originalSource: string\r\n  source: string\r\n  offset: number\r\n  line: number\r\n  column: number\r\n  inPre: boolean // HTML <pre> tag, preserve whitespaces\r\n  inVPre: boolean // v-pre, do not process directives and interpolations\r\n  onWarn: NonNullable<ErrorHandlingOptions['onWarn']>\r\n}\r\n\r\nexport function baseParse(\r\n  content: string,\r\n  options: ParserOptions = {}\r\n): RootNode {\r\n  const context = createParserContext(content, options)\r\n  const start = getCursor(context)\r\n  return createRoot(\r\n    parseChildren(context, TextModes.DATA, []),\r\n    getSelection(context, start)\r\n  )\r\n}\r\n\r\nfunction createParserContext(\r\n  content: string,\r\n  rawOptions: ParserOptions\r\n): ParserContext {\r\n  const options = extend({}, defaultParserOptions)\r\n\r\n  let key: keyof ParserOptions\r\n  for (key in rawOptions) {\r\n    // @ts-ignore\r\n    options[key] =\r\n      rawOptions[key] === undefined\r\n        ? defaultParserOptions[key]\r\n        : rawOptions[key]\r\n  }\r\n  return {\r\n    options,\r\n    column: 1,\r\n    line: 1,\r\n    offset: 0,\r\n    originalSource: content,\r\n    source: content,\r\n    inPre: false,\r\n    inVPre: false,\r\n    onWarn: options.onWarn\r\n  }\r\n}\r\n\r\nfunction parseChildren(\r\n  context: ParserContext,\r\n  mode: TextModes,\r\n  ancestors: ElementNode[]\r\n): TemplateChildNode[] {\r\n  const parent = last(ancestors)\r\n  const ns = parent ? parent.ns : Namespaces.HTML\r\n  const nodes: TemplateChildNode[] = []\r\n\r\n  while (!isEnd(context, mode, ancestors)) {\r\n    __TEST__ && assert(context.source.length > 0)\r\n    const s = context.source\r\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\r\n\r\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\r\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n        // '{{'\r\n        node = parseInterpolation(context, mode)\r\n      } else if (mode === TextModes.DATA && s[0] === '<') {\r\n        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n        if (s.length === 1) {\r\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\r\n        } else if (s[1] === '!') {\r\n          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n          if (startsWith(s, '<!--')) {\r\n            node = parseComment(context)\r\n          } else if (startsWith(s, '<!DOCTYPE')) {\r\n            // Ignore DOCTYPE by a limitation.\r\n            node = parseBogusComment(context)\r\n          } else if (startsWith(s, '<![CDATA[')) {\r\n            if (ns !== Namespaces.HTML) {\r\n              node = parseCDATA(context, ancestors)\r\n            } else {\r\n              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\r\n              node = parseBogusComment(context)\r\n            }\r\n          } else {\r\n            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\r\n            node = parseBogusComment(context)\r\n          }\r\n        } else if (s[1] === '/') {\r\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n          if (s.length === 2) {\r\n            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\r\n          } else if (s[2] === '>') {\r\n            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\r\n            advanceBy(context, 3)\r\n            continue\r\n          } else if (/[a-z]/i.test(s[2])) {\r\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\r\n            parseTag(context, TagType.End, parent)\r\n            continue\r\n          } else {\r\n            emitError(\r\n              context,\r\n              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,\r\n              2\r\n            )\r\n            node = parseBogusComment(context)\r\n          }\r\n        } else if (/[a-z]/i.test(s[1])) {\r\n          node = parseElement(context, ancestors)\r\n\r\n          // 2.x <template> with no directive compat\r\n          if (\r\n            __COMPAT__ &&\r\n            isCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n              context\r\n            ) &&\r\n            node &&\r\n            node.tag === 'template' &&\r\n            !node.props.some(\r\n              p =>\r\n                p.type === NodeTypes.DIRECTIVE &&\r\n                isSpecialTemplateDirective(p.name)\r\n            )\r\n          ) {\r\n            __DEV__ &&\r\n              warnDeprecation(\r\n                CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\r\n                context,\r\n                node.loc\r\n              )\r\n            node = node.children\r\n          }\r\n        } else if (s[1] === '?') {\r\n          emitError(\r\n            context,\r\n            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\r\n            1\r\n          )\r\n          node = parseBogusComment(context)\r\n        } else {\r\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\r\n        }\r\n      }\r\n    }\r\n    if (!node) {\r\n      node = parseText(context, mode)\r\n    }\r\n\r\n    if (isArray(node)) {\r\n      for (let i = 0; i < node.length; i++) {\r\n        pushNode(nodes, node[i])\r\n      }\r\n    } else {\r\n      pushNode(nodes, node)\r\n    }\r\n  }\r\n\r\n  // Whitespace handling strategy like v2\r\n  let removedWhitespace = false\r\n  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {\r\n    const shouldCondense = context.options.whitespace !== 'preserve'\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const node = nodes[i]\r\n      if (node.type === NodeTypes.TEXT) {\r\n        if (!context.inPre) {\r\n          if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n            const prev = nodes[i - 1]\r\n            const next = nodes[i + 1]\r\n            // Remove if:\r\n            // - the whitespace is the first or last node, or:\r\n            // - (condense mode) the whitespace is between twos comments, or:\r\n            // - (condense mode) the whitespace is between comment and element, or:\r\n            // - (condense mode) the whitespace is between two elements AND contains newline\r\n            if (\r\n              !prev ||\r\n              !next ||\r\n              (shouldCondense &&\r\n                ((prev.type === NodeTypes.COMMENT &&\r\n                  next.type === NodeTypes.COMMENT) ||\r\n                  (prev.type === NodeTypes.COMMENT &&\r\n                    next.type === NodeTypes.ELEMENT) ||\r\n                  (prev.type === NodeTypes.ELEMENT &&\r\n                    next.type === NodeTypes.COMMENT) ||\r\n                  (prev.type === NodeTypes.ELEMENT &&\r\n                    next.type === NodeTypes.ELEMENT &&\r\n                    /[\\r\\n]/.test(node.content))))\r\n            ) {\r\n              removedWhitespace = true\r\n              nodes[i] = null as any\r\n            } else {\r\n              // Otherwise, the whitespace is condensed into a single space\r\n              node.content = ' '\r\n            }\r\n          } else if (shouldCondense) {\r\n            // in condense mode, consecutive whitespaces in text are condensed\r\n            // down to a single space.\r\n            node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ')\r\n          }\r\n        } else {\r\n          // #6410 normalize windows newlines in <pre>:\r\n          // in SSR, browsers normalize server-rendered \\r\\n into a single \\n\r\n          // in the DOM\r\n          node.content = node.content.replace(/\\r\\n/g, '\\n')\r\n        }\r\n      }\r\n      // Remove comment nodes if desired by configuration.\r\n      else if (node.type === NodeTypes.COMMENT && !context.options.comments) {\r\n        removedWhitespace = true\r\n        nodes[i] = null as any\r\n      }\r\n    }\r\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n      // remove leading newline per html spec\r\n      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n      const first = nodes[0]\r\n      if (first && first.type === NodeTypes.TEXT) {\r\n        first.content = first.content.replace(/^\\r?\\n/, '')\r\n      }\r\n    }\r\n  }\r\n\r\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\r\n}\r\n\r\nfunction pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {\r\n  if (node.type === NodeTypes.TEXT) {\r\n    const prev = last(nodes)\r\n    // Merge if both this and the previous node are text and those are\r\n    // consecutive. This happens for cases like \"a < b\".\r\n    if (\r\n      prev &&\r\n      prev.type === NodeTypes.TEXT &&\r\n      prev.loc.end.offset === node.loc.start.offset\r\n    ) {\r\n      prev.content += node.content\r\n      prev.loc.end = node.loc.end\r\n      prev.loc.source += node.loc.source\r\n      return\r\n    }\r\n  }\r\n\r\n  nodes.push(node)\r\n}\r\n\r\nfunction parseCDATA(\r\n  context: ParserContext,\r\n  ancestors: ElementNode[]\r\n): TemplateChildNode[] {\r\n  __TEST__ &&\r\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\r\n  __TEST__ && assert(startsWith(context.source, '<![CDATA['))\r\n\r\n  advanceBy(context, 9)\r\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\r\n  if (context.source.length === 0) {\r\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\r\n  } else {\r\n    __TEST__ && assert(startsWith(context.source, ']]>'))\r\n    advanceBy(context, 3)\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\nfunction parseComment(context: ParserContext): CommentNode {\r\n  __TEST__ && assert(startsWith(context.source, '<!--'))\r\n\r\n  const start = getCursor(context)\r\n  let content: string\r\n\r\n  // Regular comment.\r\n  const match = /--(\\!)?>/.exec(context.source)\r\n  if (!match) {\r\n    content = context.source.slice(4)\r\n    advanceBy(context, context.source.length)\r\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\r\n  } else {\r\n    if (match.index <= 3) {\r\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\r\n    }\r\n    if (match[1]) {\r\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\r\n    }\r\n    content = context.source.slice(4, match.index)\r\n\r\n    // Advancing with reporting nested comments.\r\n    const s = context.source.slice(0, match.index)\r\n    let prevIndex = 1,\r\n      nestedIndex = 0\r\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n      advanceBy(context, nestedIndex - prevIndex + 1)\r\n      if (nestedIndex + 4 < s.length) {\r\n        emitError(context, ErrorCodes.NESTED_COMMENT)\r\n      }\r\n      prevIndex = nestedIndex + 1\r\n    }\r\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.COMMENT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\r\n  __TEST__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\r\n\r\n  const start = getCursor(context)\r\n  const contentStart = context.source[1] === '?' ? 1 : 2\r\n  let content: string\r\n\r\n  const closeIndex = context.source.indexOf('>')\r\n  if (closeIndex === -1) {\r\n    content = context.source.slice(contentStart)\r\n    advanceBy(context, context.source.length)\r\n  } else {\r\n    content = context.source.slice(contentStart, closeIndex)\r\n    advanceBy(context, closeIndex + 1)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.COMMENT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseElement(\r\n  context: ParserContext,\r\n  ancestors: ElementNode[]\r\n): ElementNode | undefined {\r\n  __TEST__ && assert(/^<[a-z]/i.test(context.source))\r\n\r\n  // Start tag.\r\n  const wasInPre = context.inPre\r\n  const wasInVPre = context.inVPre\r\n  const parent = last(ancestors)\r\n  const element = parseTag(context, TagType.Start, parent)\r\n  const isPreBoundary = context.inPre && !wasInPre\r\n  const isVPreBoundary = context.inVPre && !wasInVPre\r\n\r\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n    // #4030 self-closing <pre> tag\r\n    if (isPreBoundary) {\r\n      context.inPre = false\r\n    }\r\n    if (isVPreBoundary) {\r\n      context.inVPre = false\r\n    }\r\n    return element\r\n  }\r\n\r\n  // Children.\r\n  ancestors.push(element)\r\n  const mode = context.options.getTextMode(element, parent)\r\n  const children = parseChildren(context, mode, ancestors)\r\n  ancestors.pop()\r\n\r\n  // 2.x inline-template compat\r\n  if (__COMPAT__) {\r\n    const inlineTemplateProp = element.props.find(\r\n      p => p.type === NodeTypes.ATTRIBUTE && p.name === 'inline-template'\r\n    ) as AttributeNode\r\n    if (\r\n      inlineTemplateProp &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE,\r\n        context,\r\n        inlineTemplateProp.loc\r\n      )\r\n    ) {\r\n      const loc = getSelection(context, element.loc.end)\r\n      inlineTemplateProp.value = {\r\n        type: NodeTypes.TEXT,\r\n        content: loc.source,\r\n        loc\r\n      }\r\n    }\r\n  }\r\n\r\n  element.children = children\r\n\r\n  // End tag.\r\n  if (startsWithEndTagOpen(context.source, element.tag)) {\r\n    parseTag(context, TagType.End, parent)\r\n  } else {\r\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\r\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n      const first = children[0]\r\n      if (first && startsWith(first.loc.source, '<!--')) {\r\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\r\n      }\r\n    }\r\n  }\r\n\r\n  element.loc = getSelection(context, element.loc.start)\r\n\r\n  if (isPreBoundary) {\r\n    context.inPre = false\r\n  }\r\n  if (isVPreBoundary) {\r\n    context.inVPre = false\r\n  }\r\n  return element\r\n}\r\n\r\nconst enum TagType {\r\n  Start,\r\n  End\r\n}\r\n\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ makeMap(\r\n  `if,else,else-if,for,slot`\r\n)\r\n\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType.Start,\r\n  parent: ElementNode | undefined\r\n): ElementNode\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType.End,\r\n  parent: ElementNode | undefined\r\n): void\r\nfunction parseTag(\r\n  context: ParserContext,\r\n  type: TagType,\r\n  parent: ElementNode | undefined\r\n): ElementNode | undefined {\r\n  __TEST__ && assert(/^<\\/?[a-z]/i.test(context.source))\r\n  __TEST__ &&\r\n    assert(\r\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\r\n    )\r\n\r\n  // Tag open.\r\n  const start = getCursor(context)\r\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\r\n  const tag = match[1]\r\n  const ns = context.options.getNamespace(tag, parent)\r\n\r\n  advanceBy(context, match[0].length)\r\n  advanceSpaces(context)\r\n\r\n  // save current state in case we need to re-parse attributes with v-pre\r\n  const cursor = getCursor(context)\r\n  const currentSource = context.source\r\n\r\n  // check <pre> tag\r\n  if (context.options.isPreTag(tag)) {\r\n    context.inPre = true\r\n  }\r\n\r\n  // Attributes.\r\n  let props = parseAttributes(context, type)\r\n\r\n  // check v-pre\r\n  if (\r\n    type === TagType.Start &&\r\n    !context.inVPre &&\r\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\r\n  ) {\r\n    context.inVPre = true\r\n    // reset context\r\n    extend(context, cursor)\r\n    context.source = currentSource\r\n    // re-parse attrs and filter out v-pre itself\r\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\r\n  }\r\n\r\n  // Tag close.\r\n  let isSelfClosing = false\r\n  if (context.source.length === 0) {\r\n    emitError(context, ErrorCodes.EOF_IN_TAG)\r\n  } else {\r\n    isSelfClosing = startsWith(context.source, '/>')\r\n    if (type === TagType.End && isSelfClosing) {\r\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\r\n    }\r\n    advanceBy(context, isSelfClosing ? 2 : 1)\r\n  }\r\n\r\n  if (type === TagType.End) {\r\n    return\r\n  }\r\n\r\n  // 2.x deprecation checks\r\n  if (\r\n    __COMPAT__ &&\r\n    __DEV__ &&\r\n    isCompatEnabled(\r\n      CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n      context\r\n    )\r\n  ) {\r\n    let hasIf = false\r\n    let hasFor = false\r\n    for (let i = 0; i < props.length; i++) {\r\n      const p = props[i]\r\n      if (p.type === NodeTypes.DIRECTIVE) {\r\n        if (p.name === 'if') {\r\n          hasIf = true\r\n        } else if (p.name === 'for') {\r\n          hasFor = true\r\n        }\r\n      }\r\n      if (hasIf && hasFor) {\r\n        warnDeprecation(\r\n          CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\r\n          context,\r\n          getSelection(context, start)\r\n        )\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  let tagType = ElementTypes.ELEMENT\r\n  if (!context.inVPre) {\r\n    if (tag === 'slot') {\r\n      tagType = ElementTypes.SLOT\r\n    } else if (tag === 'template') {\r\n      if (\r\n        props.some(\r\n          p =>\r\n            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)\r\n        )\r\n      ) {\r\n        tagType = ElementTypes.TEMPLATE\r\n      }\r\n    } else if (isComponent(tag, props, context)) {\r\n      tagType = ElementTypes.COMPONENT\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.ELEMENT,\r\n    ns,\r\n    tag,\r\n    tagType,\r\n    props,\r\n    isSelfClosing,\r\n    children: [],\r\n    loc: getSelection(context, start),\r\n    codegenNode: undefined // to be created during transform phase\r\n  }\r\n}\r\n\r\nfunction isComponent(\r\n  tag: string,\r\n  props: (AttributeNode | DirectiveNode)[],\r\n  context: ParserContext\r\n) {\r\n  const options = context.options\r\n  if (options.isCustomElement(tag)) {\r\n    return false\r\n  }\r\n  if (\r\n    tag === 'component' ||\r\n    /^[A-Z]/.test(tag) ||\r\n    isCoreComponent(tag) ||\r\n    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n    (options.isNativeTag && !options.isNativeTag(tag))\r\n  ) {\r\n    return true\r\n  }\r\n  // at this point the tag should be a native tag, but check for potential \"is\"\r\n  // casting\r\n  for (let i = 0; i < props.length; i++) {\r\n    const p = props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.name === 'is' && p.value) {\r\n        if (p.value.content.startsWith('vue:')) {\r\n          return true\r\n        } else if (\r\n          __COMPAT__ &&\r\n          checkCompatEnabled(\r\n            CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n            context,\r\n            p.loc\r\n          )\r\n        ) {\r\n          return true\r\n        }\r\n      }\r\n    } else {\r\n      // directive\r\n      // v-is (TODO: remove in 3.4)\r\n      if (p.name === 'is') {\r\n        return true\r\n      } else if (\r\n        // :is on plain element - only treat as component in compat mode\r\n        p.name === 'bind' &&\r\n        isStaticArgOf(p.arg, 'is') &&\r\n        __COMPAT__ &&\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n          context,\r\n          p.loc\r\n        )\r\n      ) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction parseAttributes(\r\n  context: ParserContext,\r\n  type: TagType\r\n): (AttributeNode | DirectiveNode)[] {\r\n  const props = []\r\n  const attributeNames = new Set<string>()\r\n  while (\r\n    context.source.length > 0 &&\r\n    !startsWith(context.source, '>') &&\r\n    !startsWith(context.source, '/>')\r\n  ) {\r\n    if (startsWith(context.source, '/')) {\r\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\r\n      advanceBy(context, 1)\r\n      advanceSpaces(context)\r\n      continue\r\n    }\r\n    if (type === TagType.End) {\r\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\r\n    }\r\n\r\n    const attr = parseAttribute(context, attributeNames)\r\n\r\n    // Trim whitespace between class\r\n    // https://github.com/vuejs/core/issues/4251\r\n    if (\r\n      attr.type === NodeTypes.ATTRIBUTE &&\r\n      attr.value &&\r\n      attr.name === 'class'\r\n    ) {\r\n      attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim()\r\n    }\r\n\r\n    if (type === TagType.Start) {\r\n      props.push(attr)\r\n    }\r\n\r\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\r\n    }\r\n    advanceSpaces(context)\r\n  }\r\n  return props\r\n}\r\n\r\nfunction parseAttribute(\r\n  context: ParserContext,\r\n  nameSet: Set<string>\r\n): AttributeNode | DirectiveNode {\r\n  __TEST__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\r\n\r\n  // Name.\r\n  const start = getCursor(context)\r\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\r\n  const name = match[0]\r\n\r\n  if (nameSet.has(name)) {\r\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\r\n  }\r\n  nameSet.add(name)\r\n\r\n  if (name[0] === '=') {\r\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\r\n  }\r\n  {\r\n    const pattern = /[\"'<]/g\r\n    let m: RegExpExecArray | null\r\n    while ((m = pattern.exec(name))) {\r\n      emitError(\r\n        context,\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\r\n        m.index\r\n      )\r\n    }\r\n  }\r\n\r\n  advanceBy(context, name.length)\r\n\r\n  // Value\r\n  let value: AttributeValue = undefined\r\n\r\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n    advanceSpaces(context)\r\n    advanceBy(context, 1)\r\n    advanceSpaces(context)\r\n    value = parseAttributeValue(context)\r\n    if (!value) {\r\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\r\n    }\r\n  }\r\n  const loc = getSelection(context, start)\r\n\r\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\r\n    const match =\r\n      /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\r\n        name\r\n      )!\r\n\r\n    let isPropShorthand = startsWith(name, '.')\r\n    let dirName =\r\n      match[1] ||\r\n      (isPropShorthand || startsWith(name, ':')\r\n        ? 'bind'\r\n        : startsWith(name, '@')\r\n          ? 'on'\r\n          : 'slot')\r\n    let arg: ExpressionNode | undefined\r\n\r\n    if (match[2]) {\r\n      const isSlot = dirName === 'slot'\r\n      const startOffset = name.lastIndexOf(\r\n        match[2],\r\n        name.length - (match[3]?.length || 0)\r\n      )\r\n      const loc = getSelection(\r\n        context,\r\n        getNewPosition(context, start, startOffset),\r\n        getNewPosition(\r\n          context,\r\n          start,\r\n          startOffset + match[2].length + ((isSlot && match[3]) || '').length\r\n        )\r\n      )\r\n      let content = match[2]\r\n      let isStatic = true\r\n\r\n      if (content.startsWith('[')) {\r\n        isStatic = false\r\n\r\n        if (!content.endsWith(']')) {\r\n          emitError(\r\n            context,\r\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\r\n          )\r\n          content = content.slice(1)\r\n        } else {\r\n          content = content.slice(1, content.length - 1)\r\n        }\r\n      } else if (isSlot) {\r\n        // #1241 special case for v-slot: vuetify relies extensively on slot\r\n        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\r\n        // supports such usage so we are keeping it consistent with 2.x.\r\n        content += match[3] || ''\r\n      }\r\n\r\n      arg = {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic\r\n          ? ConstantTypes.CAN_STRINGIFY\r\n          : ConstantTypes.NOT_CONSTANT,\r\n        loc\r\n      }\r\n    }\r\n\r\n    if (value && value.isQuoted) {\r\n      const valueLoc = value.loc\r\n      valueLoc.start.offset++\r\n      valueLoc.start.column++\r\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\r\n      valueLoc.source = valueLoc.source.slice(1, -1)\r\n    }\r\n\r\n    const modifiers = match[3] ? match[3].slice(1).split('.') : []\r\n    if (isPropShorthand) modifiers.push('prop')\r\n\r\n    // 2.x compat v-bind:foo.sync -> v-model:foo\r\n    if (__COMPAT__ && dirName === 'bind' && arg) {\r\n      if (\r\n        modifiers.includes('sync') &&\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_V_BIND_SYNC,\r\n          context,\r\n          loc,\r\n          arg.loc.source\r\n        )\r\n      ) {\r\n        dirName = 'model'\r\n        modifiers.splice(modifiers.indexOf('sync'), 1)\r\n      }\r\n\r\n      if (__DEV__ && modifiers.includes('prop')) {\r\n        checkCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_V_BIND_PROP,\r\n          context,\r\n          loc\r\n        )\r\n      }\r\n    }\r\n\r\n    return {\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: dirName,\r\n      exp: value && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: value.content,\r\n        isStatic: false,\r\n        // Treat as non-constant by default. This can be potentially set to\r\n        // other values by `transformExpression` to make it eligible for hoisting.\r\n        constType: ConstantTypes.NOT_CONSTANT,\r\n        loc: value.loc\r\n      },\r\n      arg,\r\n      modifiers,\r\n      loc\r\n    }\r\n  }\r\n\r\n  // missing directive name or illegal directive name\r\n  if (!context.inVPre && startsWith(name, 'v-')) {\r\n    emitError(context, ErrorCodes.X_MISSING_DIRECTIVE_NAME)\r\n  }\r\n\r\n  return {\r\n    type: NodeTypes.ATTRIBUTE,\r\n    name,\r\n    value: value && {\r\n      type: NodeTypes.TEXT,\r\n      content: value.content,\r\n      loc: value.loc\r\n    },\r\n    loc\r\n  }\r\n}\r\n\r\nfunction parseAttributeValue(context: ParserContext): AttributeValue {\r\n  const start = getCursor(context)\r\n  let content: string\r\n\r\n  const quote = context.source[0]\r\n  const isQuoted = quote === `\"` || quote === `'`\r\n  if (isQuoted) {\r\n    // Quoted value.\r\n    advanceBy(context, 1)\r\n\r\n    const endIndex = context.source.indexOf(quote)\r\n    if (endIndex === -1) {\r\n      content = parseTextData(\r\n        context,\r\n        context.source.length,\r\n        TextModes.ATTRIBUTE_VALUE\r\n      )\r\n    } else {\r\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\r\n      advanceBy(context, 1)\r\n    }\r\n  } else {\r\n    // Unquoted\r\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\r\n    if (!match) {\r\n      return undefined\r\n    }\r\n    const unexpectedChars = /[\"'<=`]/g\r\n    let m: RegExpExecArray | null\r\n    while ((m = unexpectedChars.exec(match[0]))) {\r\n      emitError(\r\n        context,\r\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\r\n        m.index\r\n      )\r\n    }\r\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\r\n  }\r\n\r\n  return { content, isQuoted, loc: getSelection(context, start) }\r\n}\r\n\r\nfunction parseInterpolation(\r\n  context: ParserContext,\r\n  mode: TextModes\r\n): InterpolationNode | undefined {\r\n  const [open, close] = context.options.delimiters\r\n  __TEST__ && assert(startsWith(context.source, open))\r\n\r\n  const closeIndex = context.source.indexOf(close, open.length)\r\n  if (closeIndex === -1) {\r\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\r\n    return undefined\r\n  }\r\n\r\n  const start = getCursor(context)\r\n  advanceBy(context, open.length)\r\n  const innerStart = getCursor(context)\r\n  const innerEnd = getCursor(context)\r\n  const rawContentLength = closeIndex - open.length\r\n  const rawContent = context.source.slice(0, rawContentLength)\r\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\r\n  const content = preTrimContent.trim()\r\n  const startOffset = preTrimContent.indexOf(content)\r\n  if (startOffset > 0) {\r\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\r\n  }\r\n  const endOffset =\r\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\r\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\r\n  advanceBy(context, close.length)\r\n\r\n  return {\r\n    type: NodeTypes.INTERPOLATION,\r\n    content: {\r\n      type: NodeTypes.SIMPLE_EXPRESSION,\r\n      isStatic: false,\r\n      // Set `isConstant` to false by default and will decide in transformExpression\r\n      constType: ConstantTypes.NOT_CONSTANT,\r\n      content,\r\n      loc: getSelection(context, innerStart, innerEnd)\r\n    },\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\r\n  __TEST__ && assert(context.source.length > 0)\r\n\r\n  const endTokens =\r\n    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]\r\n\r\n  let endIndex = context.source.length\r\n  for (let i = 0; i < endTokens.length; i++) {\r\n    const index = context.source.indexOf(endTokens[i], 1)\r\n    if (index !== -1 && endIndex > index) {\r\n      endIndex = index\r\n    }\r\n  }\r\n\r\n  __TEST__ && assert(endIndex > 0)\r\n\r\n  const start = getCursor(context)\r\n  const content = parseTextData(context, endIndex, mode)\r\n\r\n  return {\r\n    type: NodeTypes.TEXT,\r\n    content,\r\n    loc: getSelection(context, start)\r\n  }\r\n}\r\n\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(\r\n  context: ParserContext,\r\n  length: number,\r\n  mode: TextModes\r\n): string {\r\n  const rawText = context.source.slice(0, length)\r\n  advanceBy(context, length)\r\n  if (\r\n    mode === TextModes.RAWTEXT ||\r\n    mode === TextModes.CDATA ||\r\n    !rawText.includes('&')\r\n  ) {\r\n    return rawText\r\n  } else {\r\n    // DATA or RCDATA containing \"&\". Entity decoding is required.\r\n    return context.options.decodeEntities(\r\n      rawText,\r\n      mode === TextModes.ATTRIBUTE_VALUE\r\n    )\r\n  }\r\n}\r\n\r\nfunction getCursor(context: ParserContext): Position {\r\n  const { column, line, offset } = context\r\n  return { column, line, offset }\r\n}\r\n\r\nfunction getSelection(\r\n  context: ParserContext,\r\n  start: Position,\r\n  end?: Position\r\n): SourceLocation {\r\n  end = end || getCursor(context)\r\n  return {\r\n    start,\r\n    end,\r\n    source: context.originalSource.slice(start.offset, end.offset)\r\n  }\r\n}\r\n\r\nfunction last<T>(xs: T[]): T | undefined {\r\n  return xs[xs.length - 1]\r\n}\r\n\r\nfunction startsWith(source: string, searchString: string): boolean {\r\n  return source.startsWith(searchString)\r\n}\r\n\r\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\r\n  const { source } = context\r\n  __TEST__ && assert(numberOfCharacters <= source.length)\r\n  advancePositionWithMutation(context, source, numberOfCharacters)\r\n  context.source = source.slice(numberOfCharacters)\r\n}\r\n\r\nfunction advanceSpaces(context: ParserContext): void {\r\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\r\n  if (match) {\r\n    advanceBy(context, match[0].length)\r\n  }\r\n}\r\n\r\nfunction getNewPosition(\r\n  context: ParserContext,\r\n  start: Position,\r\n  numberOfCharacters: number\r\n): Position {\r\n  return advancePositionWithClone(\r\n    start,\r\n    context.originalSource.slice(start.offset, numberOfCharacters),\r\n    numberOfCharacters\r\n  )\r\n}\r\n\r\nfunction emitError(\r\n  context: ParserContext,\r\n  code: ErrorCodes,\r\n  offset?: number,\r\n  loc: Position = getCursor(context)\r\n): void {\r\n  if (offset) {\r\n    loc.offset += offset\r\n    loc.column += offset\r\n  }\r\n  context.options.onError(\r\n    createCompilerError(code, {\r\n      start: loc,\r\n      end: loc,\r\n      source: ''\r\n    })\r\n  )\r\n}\r\n\r\nfunction isEnd(\r\n  context: ParserContext,\r\n  mode: TextModes,\r\n  ancestors: ElementNode[]\r\n): boolean {\r\n  const s = context.source\r\n\r\n  switch (mode) {\r\n    case TextModes.DATA:\r\n      if (startsWith(s, '</')) {\r\n        // TODO: probably bad performance\r\n        for (let i = ancestors.length - 1; i >= 0; --i) {\r\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n            return true\r\n          }\r\n        }\r\n      }\r\n      break\r\n\r\n    case TextModes.RCDATA:\r\n    case TextModes.RAWTEXT: {\r\n      const parent = last(ancestors)\r\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n        return true\r\n      }\r\n      break\r\n    }\r\n\r\n    case TextModes.CDATA:\r\n      if (startsWith(s, ']]>')) {\r\n        return true\r\n      }\r\n      break\r\n  }\r\n\r\n  return !s\r\n}\r\n\r\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\r\n  return (\r\n    startsWith(source, '</') &&\r\n    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\r\n    /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>')\r\n  )\r\n}\r\n", "import {\r\n  ConstantTypes,\r\n  RootNode,\r\n  NodeTypes,\r\n  TemplateChildNode,\r\n  SimpleExpressionNode,\r\n  ElementTypes,\r\n  PlainElementNode,\r\n  ComponentNode,\r\n  TemplateNode,\r\n  VNodeCall,\r\n  ParentNode,\r\n  JSChildNode,\r\n  CallExpression,\r\n  createArrayExpression,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper\r\n} from '../ast'\r\nimport { TransformContext } from '../transform'\r\nimport { PatchFlags, isString, isSymbol, isArray } from '@vue/shared'\r\nimport { isSlotOutlet } from '../utils'\r\nimport {\r\n  OPEN_BLOCK,\r\n  GUARD_REACTIVE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_PROPS,\r\n  NORMALIZE_STYLE\r\n} from '../runtimeHelpers'\r\n\r\nexport function hoistStatic(root: RootNode, context: TransformContext) {\r\n  walk(\r\n    root,\r\n    context,\r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0])\r\n  )\r\n}\r\n\r\nexport function isSingleElementRoot(\r\n  root: RootNode,\r\n  child: TemplateChildNode\r\n): child is PlainElementNode | ComponentNode | TemplateNode {\r\n  const { children } = root\r\n  return (\r\n    children.length === 1 &&\r\n    child.type === NodeTypes.ELEMENT &&\r\n    !isSlotOutlet(child)\r\n  )\r\n}\r\n\r\nfunction walk(\r\n  node: ParentNode,\r\n  context: TransformContext,\r\n  doNotHoistNode: boolean = false\r\n) {\r\n  const { children } = node\r\n  const originalCount = children.length\r\n  let hoistedCount = 0\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    // only plain elements & text calls are eligible for hoisting.\r\n    if (\r\n      child.type === NodeTypes.ELEMENT &&\r\n      child.tagType === ElementTypes.ELEMENT\r\n    ) {\r\n      const constantType = doNotHoistNode\r\n        ? ConstantTypes.NOT_CONSTANT\r\n        : getConstantType(child, context)\r\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\r\n        if (constantType >= ConstantTypes.CAN_HOIST) {\r\n          ;(child.codegenNode as VNodeCall).patchFlag =\r\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\r\n          child.codegenNode = context.hoist(child.codegenNode!)\r\n          hoistedCount++\r\n          continue\r\n        }\r\n      } else {\r\n        // node may contain dynamic children, but its props may be eligible for\r\n        // hoisting.\r\n        const codegenNode = child.codegenNode!\r\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n          const flag = getPatchFlag(codegenNode)\r\n          if (\r\n            (!flag ||\r\n              flag === PatchFlags.NEED_PATCH ||\r\n              flag === PatchFlags.TEXT) &&\r\n            getGeneratedPropsConstantType(child, context) >=\r\n              ConstantTypes.CAN_HOIST\r\n          ) {\r\n            const props = getNodeProps(child)\r\n            if (props) {\r\n              codegenNode.props = context.hoist(props)\r\n            }\r\n          }\r\n          if (codegenNode.dynamicProps) {\r\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // walk further\r\n    if (child.type === NodeTypes.ELEMENT) {\r\n      const isComponent = child.tagType === ElementTypes.COMPONENT\r\n      if (isComponent) {\r\n        context.scopes.vSlot++\r\n      }\r\n      walk(child, context)\r\n      if (isComponent) {\r\n        context.scopes.vSlot--\r\n      }\r\n    } else if (child.type === NodeTypes.FOR) {\r\n      // Do not hoist v-for single child because it has to be a block\r\n      walk(child, context, child.children.length === 1)\r\n    } else if (child.type === NodeTypes.IF) {\r\n      for (let i = 0; i < child.branches.length; i++) {\r\n        // Do not hoist v-if single child because it has to be a block\r\n        walk(\r\n          child.branches[i],\r\n          context,\r\n          child.branches[i].children.length === 1\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  if (hoistedCount && context.transformHoist) {\r\n    context.transformHoist(children, context, node)\r\n  }\r\n\r\n  // all children were hoisted - the entire children array is hoistable.\r\n  if (\r\n    hoistedCount &&\r\n    hoistedCount === originalCount &&\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    node.codegenNode &&\r\n    node.codegenNode.type === NodeTypes.VNODE_CALL &&\r\n    isArray(node.codegenNode.children)\r\n  ) {\r\n    const hoisted = context.hoist(\r\n      createArrayExpression(node.codegenNode.children)\r\n    )\r\n    // #6978, #7138, #7114\r\n    // a hoisted children array inside v-for can caused HMR errors since\r\n    // it might be mutated when mounting the v-for list\r\n    if (context.hmr) {\r\n      hoisted.content = `[...${hoisted.content}]`\r\n    }\r\n    node.codegenNode.children = hoisted\r\n  }\r\n}\r\n\r\nexport function getConstantType(\r\n  node: TemplateChildNode | SimpleExpressionNode,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  const { constantCache } = context\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n      if (node.tagType !== ElementTypes.ELEMENT) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const cached = constantCache.get(node)\r\n      if (cached !== undefined) {\r\n        return cached\r\n      }\r\n      const codegenNode = node.codegenNode!\r\n      if (codegenNode.type !== NodeTypes.VNODE_CALL) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (\r\n        codegenNode.isBlock &&\r\n        node.tag !== 'svg' &&\r\n        node.tag !== 'foreignObject'\r\n      ) {\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n      const flag = getPatchFlag(codegenNode)\r\n      if (!flag) {\r\n        let returnType = ConstantTypes.CAN_STRINGIFY\r\n\r\n        // Element itself has no patch flag. However we still need to check:\r\n\r\n        // 1. Even for a node with no patch flag, it is possible for it to contain\r\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n        // injected keys or cached event handlers. Therefore we need to always\r\n        // check the codegenNode's props to be sure.\r\n        const generatedPropsType = getGeneratedPropsConstantType(node, context)\r\n        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {\r\n          constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n          return ConstantTypes.NOT_CONSTANT\r\n        }\r\n        if (generatedPropsType < returnType) {\r\n          returnType = generatedPropsType\r\n        }\r\n\r\n        // 2. its children.\r\n        for (let i = 0; i < node.children.length; i++) {\r\n          const childType = getConstantType(node.children[i], context)\r\n          if (childType === ConstantTypes.NOT_CONSTANT) {\r\n            constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n            return ConstantTypes.NOT_CONSTANT\r\n          }\r\n          if (childType < returnType) {\r\n            returnType = childType\r\n          }\r\n        }\r\n\r\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n        // type, check if any of the props can cause the type to be lowered\r\n        // we can skip can_patch because it's guaranteed by the absence of a\r\n        // patchFlag.\r\n        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {\r\n              const expType = getConstantType(p.exp, context)\r\n              if (expType === ConstantTypes.NOT_CONSTANT) {\r\n                constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n                return ConstantTypes.NOT_CONSTANT\r\n              }\r\n              if (expType < returnType) {\r\n                returnType = expType\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // only svg/foreignObject could be block here, however if they are\r\n        // static then they don't need to be blocks since there will be no\r\n        // nested updates.\r\n        if (codegenNode.isBlock) {\r\n          // except set custom directives.\r\n          for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i]\r\n            if (p.type === NodeTypes.DIRECTIVE) {\r\n              constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n              return ConstantTypes.NOT_CONSTANT\r\n            }\r\n          }\r\n\r\n          context.removeHelper(OPEN_BLOCK)\r\n          context.removeHelper(\r\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\r\n          )\r\n          codegenNode.isBlock = false\r\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))\r\n        }\r\n\r\n        constantCache.set(node, returnType)\r\n        return returnType\r\n      } else {\r\n        constantCache.set(node, ConstantTypes.NOT_CONSTANT)\r\n        return ConstantTypes.NOT_CONSTANT\r\n      }\r\n    case NodeTypes.TEXT:\r\n    case NodeTypes.COMMENT:\r\n      return ConstantTypes.CAN_STRINGIFY\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.IF_BRANCH:\r\n      return ConstantTypes.NOT_CONSTANT\r\n    case NodeTypes.INTERPOLATION:\r\n    case NodeTypes.TEXT_CALL:\r\n      return getConstantType(node.content, context)\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      return node.constType\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      let returnType = ConstantTypes.CAN_STRINGIFY\r\n      for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i]\r\n        if (isString(child) || isSymbol(child)) {\r\n          continue\r\n        }\r\n        const childType = getConstantType(child, context)\r\n        if (childType === ConstantTypes.NOT_CONSTANT) {\r\n          return ConstantTypes.NOT_CONSTANT\r\n        } else if (childType < returnType) {\r\n          returnType = childType\r\n        }\r\n      }\r\n      return returnType\r\n    default:\r\n      if (__DEV__) {\r\n        const exhaustiveCheck: never = node\r\n        exhaustiveCheck\r\n      }\r\n      return ConstantTypes.NOT_CONSTANT\r\n  }\r\n}\r\n\r\nconst allowHoistedHelperSet = new Set([\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_STYLE,\r\n  NORMALIZE_PROPS,\r\n  GUARD_REACTIVE_PROPS\r\n])\r\n\r\nfunction getConstantTypeOfHelperCall(\r\n  value: CallExpression,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  if (\r\n    value.type === NodeTypes.JS_CALL_EXPRESSION &&\r\n    !isString(value.callee) &&\r\n    allowHoistedHelperSet.has(value.callee)\r\n  ) {\r\n    const arg = value.arguments[0] as JSChildNode\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      return getConstantType(arg, context)\r\n    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\r\n      return getConstantTypeOfHelperCall(arg, context)\r\n    }\r\n  }\r\n  return ConstantTypes.NOT_CONSTANT\r\n}\r\n\r\nfunction getGeneratedPropsConstantType(\r\n  node: PlainElementNode,\r\n  context: TransformContext\r\n): ConstantTypes {\r\n  let returnType = ConstantTypes.CAN_STRINGIFY\r\n  const props = getNodeProps(node)\r\n  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n    const { properties } = props\r\n    for (let i = 0; i < properties.length; i++) {\r\n      const { key, value } = properties[i]\r\n      const keyType = getConstantType(key, context)\r\n      if (keyType === ConstantTypes.NOT_CONSTANT) {\r\n        return keyType\r\n      }\r\n      if (keyType < returnType) {\r\n        returnType = keyType\r\n      }\r\n      let valueType: ConstantTypes\r\n      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n        valueType = getConstantType(value, context)\r\n      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n        // some helper calls can be hoisted,\r\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\r\n        // in this case we need to respect the ConstantType of the helper's arguments\r\n        valueType = getConstantTypeOfHelperCall(value, context)\r\n      } else {\r\n        valueType = ConstantTypes.NOT_CONSTANT\r\n      }\r\n      if (valueType === ConstantTypes.NOT_CONSTANT) {\r\n        return valueType\r\n      }\r\n      if (valueType < returnType) {\r\n        returnType = valueType\r\n      }\r\n    }\r\n  }\r\n  return returnType\r\n}\r\n\r\nfunction getNodeProps(node: PlainElementNode) {\r\n  const codegenNode = node.codegenNode!\r\n  if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n    return codegenNode.props\r\n  }\r\n}\r\n\r\nfunction getPatchFlag(node: VNodeCall): number | undefined {\r\n  const flag = node.patchFlag\r\n  return flag ? parseInt(flag, 10) : undefined\r\n}\r\n", "import { TransformOptions } from './options'\r\nimport {\r\n  RootNode,\r\n  NodeTypes,\r\n  ParentNode,\r\n  TemplateChildNode,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  Property,\r\n  ExpressionNode,\r\n  createSimpleExpression,\r\n  JSChildNode,\r\n  SimpleExpressionNode,\r\n  ElementTypes,\r\n  CacheExpression,\r\n  createCacheExpression,\r\n  TemplateLiteral,\r\n  createVNodeCall,\r\n  ConstantTypes,\r\n  ArrayExpression,\r\n  convertToBlock\r\n} from './ast'\r\nimport {\r\n  isString,\r\n  isArray,\r\n  NOOP,\r\n  PatchFlags,\r\n  PatchFlagNames,\r\n  EMPTY_OBJ,\r\n  capitalize,\r\n  camelize\r\n} from '@vue/shared'\r\nimport { defaultOnError, defaultOnWarn } from './errors'\r\nimport {\r\n  TO_DISPLAY_STRING,\r\n  FRAGMENT,\r\n  helperNameMap,\r\n  CREATE_COMMENT\r\n} from './runtimeHelpers'\r\nimport { isVSlot } from './utils'\r\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\r\nimport { CompilerCompatOptions } from './compat/compatConfig'\r\n\r\n// There are two types of transforms:\r\n//\r\n// - NodeTransform:\r\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\r\n//   replace or remove the node being processed.\r\nexport type NodeTransform = (\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext\r\n) => void | (() => void) | (() => void)[]\r\n\r\n// - DirectiveTransform:\r\n//   Transforms that handles a single directive attribute on an element.\r\n//   It translates the raw directive into actual props for the VNode.\r\nexport type DirectiveTransform = (\r\n  dir: DirectiveNode,\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  // a platform specific compiler can import the base transform and augment\r\n  // it by passing in this optional argument.\r\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\r\n) => DirectiveTransformResult\r\n\r\nexport interface DirectiveTransformResult {\r\n  props: Property[]\r\n  needRuntime?: boolean | symbol\r\n  ssrTagParts?: TemplateLiteral['elements']\r\n}\r\n\r\n// A structural directive transform is technically also a NodeTransform;\r\n// Only v-if and v-for fall into this category.\r\nexport type StructuralDirectiveTransform = (\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext\r\n) => void | (() => void)\r\n\r\nexport interface ImportItem {\r\n  exp: string | ExpressionNode\r\n  path: string\r\n}\r\n\r\nexport interface TransformContext\r\n  extends Required<\r\n      Omit<TransformOptions, 'filename' | keyof CompilerCompatOptions>\r\n    >,\r\n    CompilerCompatOptions {\r\n  selfName: string | null\r\n  root: RootNode\r\n  helpers: Map<symbol, number>\r\n  components: Set<string>\r\n  directives: Set<string>\r\n  hoists: (JSChildNode | null)[]\r\n  imports: ImportItem[]\r\n  temps: number\r\n  cached: number\r\n  identifiers: { [name: string]: number | undefined }\r\n  scopes: {\r\n    vFor: number\r\n    vSlot: number\r\n    vPre: number\r\n    vOnce: number\r\n  }\r\n  parent: ParentNode | null\r\n  childIndex: number\r\n  currentNode: RootNode | TemplateChildNode | null\r\n  inVOnce: boolean\r\n  helper<T extends symbol>(name: T): T\r\n  removeHelper<T extends symbol>(name: T): void\r\n  helperString(name: symbol): string\r\n  replaceNode(node: TemplateChildNode): void\r\n  removeNode(node?: TemplateChildNode): void\r\n  onNodeRemoved(): void\r\n  addIdentifiers(exp: ExpressionNode | string): void\r\n  removeIdentifiers(exp: ExpressionNode | string): void\r\n  hoist(exp: string | JSChildNode | ArrayExpression): SimpleExpressionNode\r\n  cache<T extends JSChildNode>(exp: T, isVNode?: boolean): CacheExpression | T\r\n  constantCache: WeakMap<TemplateChildNode, ConstantTypes>\r\n\r\n  // 2.x Compat only\r\n  filters?: Set<string>\r\n}\r\n\r\nexport function createTransformContext(\r\n  root: RootNode,\r\n  {\r\n    filename = '',\r\n    prefixIdentifiers = false,\r\n    hoistStatic = false,\r\n    hmr = false,\r\n    cacheHandlers = false,\r\n    nodeTransforms = [],\r\n    directiveTransforms = {},\r\n    transformHoist = null,\r\n    isBuiltInComponent = NOOP,\r\n    isCustomElement = NOOP,\r\n    expressionPlugins = [],\r\n    scopeId = null,\r\n    slotted = true,\r\n    ssr = false,\r\n    inSSR = false,\r\n    ssrCssVars = ``,\r\n    bindingMetadata = EMPTY_OBJ,\r\n    inline = false,\r\n    isTS = false,\r\n    onError = defaultOnError,\r\n    onWarn = defaultOnWarn,\r\n    compatConfig\r\n  }: TransformOptions\r\n): TransformContext {\r\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/)\r\n  const context: TransformContext = {\r\n    // options\r\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\r\n    prefixIdentifiers,\r\n    hoistStatic,\r\n    hmr,\r\n    cacheHandlers,\r\n    nodeTransforms,\r\n    directiveTransforms,\r\n    transformHoist,\r\n    isBuiltInComponent,\r\n    isCustomElement,\r\n    expressionPlugins,\r\n    scopeId,\r\n    slotted,\r\n    ssr,\r\n    inSSR,\r\n    ssrCssVars,\r\n    bindingMetadata,\r\n    inline,\r\n    isTS,\r\n    onError,\r\n    onWarn,\r\n    compatConfig,\r\n\r\n    // state\r\n    root,\r\n    helpers: new Map(),\r\n    components: new Set(),\r\n    directives: new Set(),\r\n    hoists: [],\r\n    imports: [],\r\n    constantCache: new WeakMap(),\r\n    temps: 0,\r\n    cached: 0,\r\n    identifiers: Object.create(null),\r\n    scopes: {\r\n      vFor: 0,\r\n      vSlot: 0,\r\n      vPre: 0,\r\n      vOnce: 0\r\n    },\r\n    parent: null,\r\n    currentNode: root,\r\n    childIndex: 0,\r\n    inVOnce: false,\r\n\r\n    // methods\r\n    helper(name) {\r\n      const count = context.helpers.get(name) || 0\r\n      context.helpers.set(name, count + 1)\r\n      return name\r\n    },\r\n    removeHelper(name) {\r\n      const count = context.helpers.get(name)\r\n      if (count) {\r\n        const currentCount = count - 1\r\n        if (!currentCount) {\r\n          context.helpers.delete(name)\r\n        } else {\r\n          context.helpers.set(name, currentCount)\r\n        }\r\n      }\r\n    },\r\n    helperString(name) {\r\n      return `_${helperNameMap[context.helper(name)]}`\r\n    },\r\n    replaceNode(node) {\r\n      /* istanbul ignore if */\r\n      if (__DEV__) {\r\n        if (!context.currentNode) {\r\n          throw new Error(`Node being replaced is already removed.`)\r\n        }\r\n        if (!context.parent) {\r\n          throw new Error(`Cannot replace root node.`)\r\n        }\r\n      }\r\n      context.parent!.children[context.childIndex] = context.currentNode = node\r\n    },\r\n    removeNode(node) {\r\n      if (__DEV__ && !context.parent) {\r\n        throw new Error(`Cannot remove root node.`)\r\n      }\r\n      const list = context.parent!.children\r\n      const removalIndex = node\r\n        ? list.indexOf(node)\r\n        : context.currentNode\r\n          ? context.childIndex\r\n          : -1\r\n      /* istanbul ignore if */\r\n      if (__DEV__ && removalIndex < 0) {\r\n        throw new Error(`node being removed is not a child of current parent`)\r\n      }\r\n      if (!node || node === context.currentNode) {\r\n        // current node removed\r\n        context.currentNode = null\r\n        context.onNodeRemoved()\r\n      } else {\r\n        // sibling node removed\r\n        if (context.childIndex > removalIndex) {\r\n          context.childIndex--\r\n          context.onNodeRemoved()\r\n        }\r\n      }\r\n      context.parent!.children.splice(removalIndex, 1)\r\n    },\r\n    onNodeRemoved: () => {},\r\n    addIdentifiers(exp) {\r\n      // identifier tracking only happens in non-browser builds.\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          addId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(addId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          addId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    removeIdentifiers(exp) {\r\n      if (!__BROWSER__) {\r\n        if (isString(exp)) {\r\n          removeId(exp)\r\n        } else if (exp.identifiers) {\r\n          exp.identifiers.forEach(removeId)\r\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          removeId(exp.content)\r\n        }\r\n      }\r\n    },\r\n    hoist(exp) {\r\n      if (isString(exp)) exp = createSimpleExpression(exp)\r\n      context.hoists.push(exp)\r\n      const identifier = createSimpleExpression(\r\n        `_hoisted_${context.hoists.length}`,\r\n        false,\r\n        exp.loc,\r\n        ConstantTypes.CAN_HOIST\r\n      )\r\n      identifier.hoisted = exp\r\n      return identifier\r\n    },\r\n    cache(exp, isVNode = false) {\r\n      return createCacheExpression(context.cached++, exp, isVNode)\r\n    }\r\n  }\r\n\r\n  if (__COMPAT__) {\r\n    context.filters = new Set()\r\n  }\r\n\r\n  function addId(id: string) {\r\n    const { identifiers } = context\r\n    if (identifiers[id] === undefined) {\r\n      identifiers[id] = 0\r\n    }\r\n    identifiers[id]!++\r\n  }\r\n\r\n  function removeId(id: string) {\r\n    context.identifiers[id]!--\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function transform(root: RootNode, options: TransformOptions) {\r\n  const context = createTransformContext(root, options)\r\n  traverseNode(root, context)\r\n  if (options.hoistStatic) {\r\n    hoistStatic(root, context)\r\n  }\r\n  if (!options.ssr) {\r\n    createRootCodegen(root, context)\r\n  }\r\n  // finalize meta information\r\n  root.helpers = new Set([...context.helpers.keys()])\r\n  root.components = [...context.components]\r\n  root.directives = [...context.directives]\r\n  root.imports = context.imports\r\n  root.hoists = context.hoists\r\n  root.temps = context.temps\r\n  root.cached = context.cached\r\n\r\n  if (__COMPAT__) {\r\n    root.filters = [...context.filters!]\r\n  }\r\n}\r\n\r\nfunction createRootCodegen(root: RootNode, context: TransformContext) {\r\n  const { helper } = context\r\n  const { children } = root\r\n  if (children.length === 1) {\r\n    const child = children[0]\r\n    // if the single child is an element, turn it into a block.\r\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n      // single element root is never hoisted so codegenNode will never be\r\n      // SimpleExpressionNode\r\n      const codegenNode = child.codegenNode\r\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        convertToBlock(codegenNode, context)\r\n      }\r\n      root.codegenNode = codegenNode\r\n    } else {\r\n      // - single <slot/>, IfNode, ForNode: already blocks.\r\n      // - single text node: always patched.\r\n      // root codegen falls through via genNode()\r\n      root.codegenNode = child\r\n    }\r\n  } else if (children.length > 1) {\r\n    // root has multiple nodes - return a fragment block.\r\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n    // check if the fragment actually contains a single valid child with\r\n    // the rest being comments\r\n    if (\r\n      __DEV__ &&\r\n      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n    ) {\r\n      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n      patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n    }\r\n    root.codegenNode = createVNodeCall(\r\n      context,\r\n      helper(FRAGMENT),\r\n      undefined,\r\n      root.children,\r\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n      undefined,\r\n      undefined,\r\n      true,\r\n      undefined,\r\n      false /* isComponent */\r\n    )\r\n  } else {\r\n    // no children = noop. codegen will return null.\r\n  }\r\n}\r\n\r\nexport function traverseChildren(\r\n  parent: ParentNode,\r\n  context: TransformContext\r\n) {\r\n  let i = 0\r\n  const nodeRemoved = () => {\r\n    i--\r\n  }\r\n  for (; i < parent.children.length; i++) {\r\n    const child = parent.children[i]\r\n    if (isString(child)) continue\r\n    context.parent = parent\r\n    context.childIndex = i\r\n    context.onNodeRemoved = nodeRemoved\r\n    traverseNode(child, context)\r\n  }\r\n}\r\n\r\nexport function traverseNode(\r\n  node: RootNode | TemplateChildNode,\r\n  context: TransformContext\r\n) {\r\n  context.currentNode = node\r\n  // apply transform plugins\r\n  const { nodeTransforms } = context\r\n  const exitFns = []\r\n  for (let i = 0; i < nodeTransforms.length; i++) {\r\n    const onExit = nodeTransforms[i](node, context)\r\n    if (onExit) {\r\n      if (isArray(onExit)) {\r\n        exitFns.push(...onExit)\r\n      } else {\r\n        exitFns.push(onExit)\r\n      }\r\n    }\r\n    if (!context.currentNode) {\r\n      // node was removed\r\n      return\r\n    } else {\r\n      // node may have been replaced\r\n      node = context.currentNode\r\n    }\r\n  }\r\n\r\n  switch (node.type) {\r\n    case NodeTypes.COMMENT:\r\n      if (!context.ssr) {\r\n        // inject import for the Comment symbol, which is needed for creating\r\n        // comment nodes with `createVNode`\r\n        context.helper(CREATE_COMMENT)\r\n      }\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      // no need to traverse, but we need to inject toString helper\r\n      if (!context.ssr) {\r\n        context.helper(TO_DISPLAY_STRING)\r\n      }\r\n      break\r\n\r\n    // for container types, further traverse downwards\r\n    case NodeTypes.IF:\r\n      for (let i = 0; i < node.branches.length; i++) {\r\n        traverseNode(node.branches[i], context)\r\n      }\r\n      break\r\n    case NodeTypes.IF_BRANCH:\r\n    case NodeTypes.FOR:\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.ROOT:\r\n      traverseChildren(node, context)\r\n      break\r\n  }\r\n\r\n  // exit transforms\r\n  context.currentNode = node\r\n  let i = exitFns.length\r\n  while (i--) {\r\n    exitFns[i]()\r\n  }\r\n}\r\n\r\nexport function createStructuralDirectiveTransform(\r\n  name: string | RegExp,\r\n  fn: StructuralDirectiveTransform\r\n): NodeTransform {\r\n  const matches = isString(name)\r\n    ? (n: string) => n === name\r\n    : (n: string) => name.test(n)\r\n\r\n  return (node, context) => {\r\n    if (node.type === NodeTypes.ELEMENT) {\r\n      const { props } = node\r\n      // structural directive transforms are not concerned with slots\r\n      // as they are handled separately in vSlot.ts\r\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\r\n        return\r\n      }\r\n      const exitFns = []\r\n      for (let i = 0; i < props.length; i++) {\r\n        const prop = props[i]\r\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\r\n          // structural directives are removed to avoid infinite recursion\r\n          // also we remove them *before* applying so that it can further\r\n          // traverse itself in case it moves the node around\r\n          props.splice(i, 1)\r\n          i--\r\n          const onExit = fn(node, prop, context)\r\n          if (onExit) exitFns.push(onExit)\r\n        }\r\n      }\r\n      return exitFns\r\n    }\r\n  }\r\n}\r\n", "import { CodegenOptions } from './options'\r\nimport {\r\n  RootNode,\r\n  TemplateChildNode,\r\n  TextNode,\r\n  CommentNode,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  JSChildNode,\r\n  CallExpression,\r\n  ArrayExpression,\r\n  ObjectExpression,\r\n  Position,\r\n  InterpolationNode,\r\n  CompoundExpressionNode,\r\n  SimpleExpressionNode,\r\n  FunctionExpression,\r\n  ConditionalExpression,\r\n  CacheExpression,\r\n  locStub,\r\n  SSRCodegenNode,\r\n  TemplateLiteral,\r\n  IfStatement,\r\n  AssignmentExpression,\r\n  ReturnStatement,\r\n  VNodeCall,\r\n  SequenceExpression,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper\r\n} from './ast'\r\nimport { SourceMapGenerator, RawSourceMap } from 'source-map-js'\r\nimport {\r\n  advancePositionWithMutation,\r\n  assert,\r\n  isSimpleIdentifier,\r\n  toValidAssetId\r\n} from './utils'\r\nimport { isString, isArray, isSymbol } from '@vue/shared'\r\nimport {\r\n  helperNameMap,\r\n  TO_DISPLAY_STRING,\r\n  CREATE_VNODE,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DIRECTIVE,\r\n  SET_BLOCK_TRACKING,\r\n  CREATE_COMMENT,\r\n  CREATE_TEXT,\r\n  PUSH_SCOPE_ID,\r\n  POP_SCOPE_ID,\r\n  WITH_DIRECTIVES,\r\n  CREATE_ELEMENT_VNODE,\r\n  OPEN_BLOCK,\r\n  CREATE_STATIC,\r\n  WITH_CTX,\r\n  RESOLVE_FILTER\r\n} from './runtimeHelpers'\r\nimport { ImportItem } from './transform'\r\n\r\nconst PURE_ANNOTATION = `/*#__PURE__*/`\r\n\r\nconst aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`\r\n\r\ntype CodegenNode = TemplateChildNode | JSChildNode | SSRCodegenNode\r\n\r\nexport interface CodegenResult {\r\n  code: string\r\n  preamble: string\r\n  ast: RootNode\r\n  map?: RawSourceMap\r\n}\r\n\r\nexport interface CodegenContext\r\n  extends Omit<Required<CodegenOptions>, 'bindingMetadata' | 'inline'> {\r\n  source: string\r\n  code: string\r\n  line: number\r\n  column: number\r\n  offset: number\r\n  indentLevel: number\r\n  pure: boolean\r\n  map?: SourceMapGenerator\r\n  helper(key: symbol): string\r\n  push(code: string, node?: CodegenNode): void\r\n  indent(): void\r\n  deindent(withoutNewLine?: boolean): void\r\n  newline(): void\r\n}\r\n\r\nfunction createCodegenContext(\r\n  ast: RootNode,\r\n  {\r\n    mode = 'function',\r\n    prefixIdentifiers = mode === 'module',\r\n    sourceMap = false,\r\n    filename = `template.vue.html`,\r\n    scopeId = null,\r\n    optimizeImports = false,\r\n    runtimeGlobalName = `Vue`,\r\n    runtimeModuleName = `vue`,\r\n    ssrRuntimeModuleName = 'vue/server-renderer',\r\n    ssr = false,\r\n    isTS = false,\r\n    inSSR = false\r\n  }: CodegenOptions\r\n): CodegenContext {\r\n  const context: CodegenContext = {\r\n    mode,\r\n    prefixIdentifiers,\r\n    sourceMap,\r\n    filename,\r\n    scopeId,\r\n    optimizeImports,\r\n    runtimeGlobalName,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName,\r\n    ssr,\r\n    isTS,\r\n    inSSR,\r\n    source: ast.loc.source,\r\n    code: ``,\r\n    column: 1,\r\n    line: 1,\r\n    offset: 0,\r\n    indentLevel: 0,\r\n    pure: false,\r\n    map: undefined,\r\n    helper(key) {\r\n      return `_${helperNameMap[key]}`\r\n    },\r\n    push(code, node) {\r\n      context.code += code\r\n      if (!__BROWSER__ && context.map) {\r\n        if (node) {\r\n          let name\r\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\r\n            const content = node.content.replace(/^_ctx\\./, '')\r\n            if (content !== node.content && isSimpleIdentifier(content)) {\r\n              name = content\r\n            }\r\n          }\r\n          addMapping(node.loc.start, name)\r\n        }\r\n        advancePositionWithMutation(context, code)\r\n        if (node && node.loc !== locStub) {\r\n          addMapping(node.loc.end)\r\n        }\r\n      }\r\n    },\r\n    indent() {\r\n      newline(++context.indentLevel)\r\n    },\r\n    deindent(withoutNewLine = false) {\r\n      if (withoutNewLine) {\r\n        --context.indentLevel\r\n      } else {\r\n        newline(--context.indentLevel)\r\n      }\r\n    },\r\n    newline() {\r\n      newline(context.indentLevel)\r\n    }\r\n  }\r\n\r\n  function newline(n: number) {\r\n    context.push('\\n' + `  `.repeat(n))\r\n  }\r\n\r\n  function addMapping(loc: Position, name?: string) {\r\n    context.map!.addMapping({\r\n      name,\r\n      source: context.filename,\r\n      original: {\r\n        line: loc.line,\r\n        column: loc.column - 1 // source-map column is 0 based\r\n      },\r\n      generated: {\r\n        line: context.line,\r\n        column: context.column - 1\r\n      }\r\n    })\r\n  }\r\n\r\n  if (!__BROWSER__ && sourceMap) {\r\n    // lazy require source-map implementation, only in non-browser builds\r\n    context.map = new SourceMapGenerator()\r\n    context.map!.setSourceContent(filename, context.source)\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport function generate(\r\n  ast: RootNode,\r\n  options: CodegenOptions & {\r\n    onContextCreated?: (context: CodegenContext) => void\r\n  } = {}\r\n): CodegenResult {\r\n  const context = createCodegenContext(ast, options)\r\n  if (options.onContextCreated) options.onContextCreated(context)\r\n  const {\r\n    mode,\r\n    push,\r\n    prefixIdentifiers,\r\n    indent,\r\n    deindent,\r\n    newline,\r\n    scopeId,\r\n    ssr\r\n  } = context\r\n\r\n  const helpers = Array.from(ast.helpers)\r\n  const hasHelpers = helpers.length > 0\r\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\r\n  const isSetupInlined = !__BROWSER__ && !!options.inline\r\n\r\n  // preambles\r\n  // in setup() inline mode, the preamble is generated in a sub context\r\n  // and returned separately.\r\n  const preambleContext = isSetupInlined\r\n    ? createCodegenContext(ast, options)\r\n    : context\r\n  if (!__BROWSER__ && mode === 'module') {\r\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\r\n  } else {\r\n    genFunctionPreamble(ast, preambleContext)\r\n  }\r\n  // enter render function\r\n  const functionName = ssr ? `ssrRender` : `render`\r\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\r\n  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {\r\n    // binding optimization args\r\n    args.push('$props', '$setup', '$data', '$options')\r\n  }\r\n  const signature =\r\n    !__BROWSER__ && options.isTS\r\n      ? args.map(arg => `${arg}: any`).join(',')\r\n      : args.join(', ')\r\n\r\n  if (isSetupInlined) {\r\n    push(`(${signature}) => {`)\r\n  } else {\r\n    push(`function ${functionName}(${signature}) {`)\r\n  }\r\n  indent()\r\n\r\n  if (useWithBlock) {\r\n    push(`with (_ctx) {`)\r\n    indent()\r\n    // function mode const declarations should be inside with block\r\n    // also they should be renamed to avoid collision with user properties\r\n    if (hasHelpers) {\r\n      push(`const { ${helpers.map(aliasHelper).join(', ')} } = _Vue`)\r\n      push(`\\n`)\r\n      newline()\r\n    }\r\n  }\r\n\r\n  // generate asset resolution statements\r\n  if (ast.components.length) {\r\n    genAssets(ast.components, 'component', context)\r\n    if (ast.directives.length || ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (ast.directives.length) {\r\n    genAssets(ast.directives, 'directive', context)\r\n    if (ast.temps > 0) {\r\n      newline()\r\n    }\r\n  }\r\n  if (__COMPAT__ && ast.filters && ast.filters.length) {\r\n    newline()\r\n    genAssets(ast.filters, 'filter', context)\r\n    newline()\r\n  }\r\n\r\n  if (ast.temps > 0) {\r\n    push(`let `)\r\n    for (let i = 0; i < ast.temps; i++) {\r\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\r\n    }\r\n  }\r\n  if (ast.components.length || ast.directives.length || ast.temps) {\r\n    push(`\\n`)\r\n    newline()\r\n  }\r\n\r\n  // generate the VNode tree expression\r\n  if (!ssr) {\r\n    push(`return `)\r\n  }\r\n  if (ast.codegenNode) {\r\n    genNode(ast.codegenNode, context)\r\n  } else {\r\n    push(`null`)\r\n  }\r\n\r\n  if (useWithBlock) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n\r\n  deindent()\r\n  push(`}`)\r\n\r\n  return {\r\n    ast,\r\n    code: context.code,\r\n    preamble: isSetupInlined ? preambleContext.code : ``,\r\n    // SourceMapGenerator does have toJSON() method but it's not in the types\r\n    map: context.map ? (context.map as any).toJSON() : undefined\r\n  }\r\n}\r\n\r\nfunction genFunctionPreamble(ast: RootNode, context: CodegenContext) {\r\n  const {\r\n    ssr,\r\n    prefixIdentifiers,\r\n    push,\r\n    newline,\r\n    runtimeModuleName,\r\n    runtimeGlobalName,\r\n    ssrRuntimeModuleName\r\n  } = context\r\n  const VueBinding =\r\n    !__BROWSER__ && ssr\r\n      ? `require(${JSON.stringify(runtimeModuleName)})`\r\n      : runtimeGlobalName\r\n  // Generate const declaration for helpers\r\n  // In prefix mode, we place the const declaration at top so it's done\r\n  // only once; But if we not prefixing, we place the declaration inside the\r\n  // with block so it doesn't incur the `in` check cost for every helper access.\r\n  const helpers = Array.from(ast.helpers)\r\n  if (helpers.length > 0) {\r\n    if (!__BROWSER__ && prefixIdentifiers) {\r\n      push(`const { ${helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`)\r\n    } else {\r\n      // \"with\" mode.\r\n      // save Vue in a separate variable to avoid collision\r\n      push(`const _Vue = ${VueBinding}\\n`)\r\n      // in \"with\" mode, helpers are declared inside the with block to avoid\r\n      // has check cost, but hoists are lifted out of the function - we need\r\n      // to provide the helper here.\r\n      if (ast.hoists.length) {\r\n        const staticHelpers = [\r\n          CREATE_VNODE,\r\n          CREATE_ELEMENT_VNODE,\r\n          CREATE_COMMENT,\r\n          CREATE_TEXT,\r\n          CREATE_STATIC\r\n        ]\r\n          .filter(helper => helpers.includes(helper))\r\n          .map(aliasHelper)\r\n          .join(', ')\r\n        push(`const { ${staticHelpers} } = _Vue\\n`)\r\n      }\r\n    }\r\n  }\r\n  // generate variables for ssr helpers\r\n  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    // ssr guarantees prefixIdentifier: true\r\n    push(\r\n      `const { ${ast.ssrHelpers\r\n        .map(aliasHelper)\r\n        .join(', ')} } = require(\"${ssrRuntimeModuleName}\")\\n`\r\n    )\r\n  }\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n  push(`return `)\r\n}\r\n\r\nfunction genModulePreamble(\r\n  ast: RootNode,\r\n  context: CodegenContext,\r\n  genScopeId: boolean,\r\n  inline?: boolean\r\n) {\r\n  const {\r\n    push,\r\n    newline,\r\n    optimizeImports,\r\n    runtimeModuleName,\r\n    ssrRuntimeModuleName\r\n  } = context\r\n\r\n  if (genScopeId && ast.hoists.length) {\r\n    ast.helpers.add(PUSH_SCOPE_ID)\r\n    ast.helpers.add(POP_SCOPE_ID)\r\n  }\r\n\r\n  // generate import statements for helpers\r\n  if (ast.helpers.size) {\r\n    const helpers = Array.from(ast.helpers)\r\n    if (optimizeImports) {\r\n      // when bundled with webpack with code-split, calling an import binding\r\n      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\r\n      // incurring both payload size increase and potential perf overhead.\r\n      // therefore we assign the imports to variables (which is a constant ~50b\r\n      // cost per-component instead of scaling with template size)\r\n      push(\r\n        `import { ${helpers\r\n          .map(s => helperNameMap[s])\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\r\n      )\r\n      push(\r\n        `\\n// Binding optimization for webpack code-split\\nconst ${helpers\r\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\r\n          .join(', ')}\\n`\r\n      )\r\n    } else {\r\n      push(\r\n        `import { ${helpers\r\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\r\n      )\r\n    }\r\n  }\r\n\r\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\r\n    push(\r\n      `import { ${ast.ssrHelpers\r\n        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n        .join(', ')} } from \"${ssrRuntimeModuleName}\"\\n`\r\n    )\r\n  }\r\n\r\n  if (ast.imports.length) {\r\n    genImports(ast.imports, context)\r\n    newline()\r\n  }\r\n\r\n  genHoists(ast.hoists, context)\r\n  newline()\r\n\r\n  if (!inline) {\r\n    push(`export `)\r\n  }\r\n}\r\n\r\nfunction genAssets(\r\n  assets: string[],\r\n  type: 'component' | 'directive' | 'filter',\r\n  { helper, push, newline, isTS }: CodegenContext\r\n) {\r\n  const resolver = helper(\r\n    __COMPAT__ && type === 'filter'\r\n      ? RESOLVE_FILTER\r\n      : type === 'component'\r\n        ? RESOLVE_COMPONENT\r\n        : RESOLVE_DIRECTIVE\r\n  )\r\n  for (let i = 0; i < assets.length; i++) {\r\n    let id = assets[i]\r\n    // potential component implicit self-reference inferred from SFC filename\r\n    const maybeSelfReference = id.endsWith('__self')\r\n    if (maybeSelfReference) {\r\n      id = id.slice(0, -6)\r\n    }\r\n    push(\r\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${\r\n        maybeSelfReference ? `, true` : ``\r\n      })${isTS ? `!` : ``}`\r\n    )\r\n    if (i < assets.length - 1) {\r\n      newline()\r\n    }\r\n  }\r\n}\r\n\r\nfunction genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {\r\n  if (!hoists.length) {\r\n    return\r\n  }\r\n  context.pure = true\r\n  const { push, newline, helper, scopeId, mode } = context\r\n  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'\r\n  newline()\r\n\r\n  // generate inlined withScopeId helper\r\n  if (genScopeId) {\r\n    push(\r\n      `const _withScopeId = n => (${helper(\r\n        PUSH_SCOPE_ID\r\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`\r\n    )\r\n    newline()\r\n  }\r\n\r\n  for (let i = 0; i < hoists.length; i++) {\r\n    const exp = hoists[i]\r\n    if (exp) {\r\n      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL\r\n      push(\r\n        `const _hoisted_${i + 1} = ${\r\n          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``\r\n        }`\r\n      )\r\n      genNode(exp, context)\r\n      if (needScopeIdWrapper) {\r\n        push(`)`)\r\n      }\r\n      newline()\r\n    }\r\n  }\r\n\r\n  context.pure = false\r\n}\r\n\r\nfunction genImports(importsOptions: ImportItem[], context: CodegenContext) {\r\n  if (!importsOptions.length) {\r\n    return\r\n  }\r\n  importsOptions.forEach(imports => {\r\n    context.push(`import `)\r\n    genNode(imports.exp, context)\r\n    context.push(` from '${imports.path}'`)\r\n    context.newline()\r\n  })\r\n}\r\n\r\nfunction isText(n: string | CodegenNode) {\r\n  return (\r\n    isString(n) ||\r\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n    n.type === NodeTypes.TEXT ||\r\n    n.type === NodeTypes.INTERPOLATION ||\r\n    n.type === NodeTypes.COMPOUND_EXPRESSION\r\n  )\r\n}\r\n\r\nfunction genNodeListAsArray(\r\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext\r\n) {\r\n  const multilines =\r\n    nodes.length > 3 ||\r\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\r\n  context.push(`[`)\r\n  multilines && context.indent()\r\n  genNodeList(nodes, context, multilines)\r\n  multilines && context.deindent()\r\n  context.push(`]`)\r\n}\r\n\r\nfunction genNodeList(\r\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\r\n  context: CodegenContext,\r\n  multilines: boolean = false,\r\n  comma: boolean = true\r\n) {\r\n  const { push, newline } = context\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const node = nodes[i]\r\n    if (isString(node)) {\r\n      push(node)\r\n    } else if (isArray(node)) {\r\n      genNodeListAsArray(node, context)\r\n    } else {\r\n      genNode(node, context)\r\n    }\r\n    if (i < nodes.length - 1) {\r\n      if (multilines) {\r\n        comma && push(',')\r\n        newline()\r\n      } else {\r\n        comma && push(', ')\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\r\n  if (isString(node)) {\r\n    context.push(node)\r\n    return\r\n  }\r\n  if (isSymbol(node)) {\r\n    context.push(context.helper(node))\r\n    return\r\n  }\r\n  switch (node.type) {\r\n    case NodeTypes.ELEMENT:\r\n    case NodeTypes.IF:\r\n    case NodeTypes.FOR:\r\n      __DEV__ &&\r\n        assert(\r\n          node.codegenNode != null,\r\n          `Codegen node is missing for element/if/for node. ` +\r\n            `Apply appropriate transforms first.`\r\n        )\r\n      genNode(node.codegenNode!, context)\r\n      break\r\n    case NodeTypes.TEXT:\r\n      genText(node, context)\r\n      break\r\n    case NodeTypes.SIMPLE_EXPRESSION:\r\n      genExpression(node, context)\r\n      break\r\n    case NodeTypes.INTERPOLATION:\r\n      genInterpolation(node, context)\r\n      break\r\n    case NodeTypes.TEXT_CALL:\r\n      genNode(node.codegenNode, context)\r\n      break\r\n    case NodeTypes.COMPOUND_EXPRESSION:\r\n      genCompoundExpression(node, context)\r\n      break\r\n    case NodeTypes.COMMENT:\r\n      genComment(node, context)\r\n      break\r\n    case NodeTypes.VNODE_CALL:\r\n      genVNodeCall(node, context)\r\n      break\r\n\r\n    case NodeTypes.JS_CALL_EXPRESSION:\r\n      genCallExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_OBJECT_EXPRESSION:\r\n      genObjectExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_ARRAY_EXPRESSION:\r\n      genArrayExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\r\n      genFunctionExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\r\n      genConditionalExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_CACHE_EXPRESSION:\r\n      genCacheExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_BLOCK_STATEMENT:\r\n      genNodeList(node.body, context, true, false)\r\n      break\r\n\r\n    // SSR only types\r\n    case NodeTypes.JS_TEMPLATE_LITERAL:\r\n      !__BROWSER__ && genTemplateLiteral(node, context)\r\n      break\r\n    case NodeTypes.JS_IF_STATEMENT:\r\n      !__BROWSER__ && genIfStatement(node, context)\r\n      break\r\n    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:\r\n      !__BROWSER__ && genAssignmentExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\r\n      !__BROWSER__ && genSequenceExpression(node, context)\r\n      break\r\n    case NodeTypes.JS_RETURN_STATEMENT:\r\n      !__BROWSER__ && genReturnStatement(node, context)\r\n      break\r\n\r\n    /* istanbul ignore next */\r\n    case NodeTypes.IF_BRANCH:\r\n      // noop\r\n      break\r\n    default:\r\n      if (__DEV__) {\r\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\r\n        // make sure we exhaust all possible types\r\n        const exhaustiveCheck: never = node\r\n        return exhaustiveCheck\r\n      }\r\n  }\r\n}\r\n\r\nfunction genText(\r\n  node: TextNode | SimpleExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  context.push(JSON.stringify(node.content), node)\r\n}\r\n\r\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\r\n  const { content, isStatic } = node\r\n  context.push(isStatic ? JSON.stringify(content) : content, node)\r\n}\r\n\r\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) push(PURE_ANNOTATION)\r\n  push(`${helper(TO_DISPLAY_STRING)}(`)\r\n  genNode(node.content, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genCompoundExpression(\r\n  node: CompoundExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  for (let i = 0; i < node.children!.length; i++) {\r\n    const child = node.children![i]\r\n    if (isString(child)) {\r\n      context.push(child)\r\n    } else {\r\n      genNode(child, context)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genExpressionAsPropertyKey(\r\n  node: ExpressionNode,\r\n  context: CodegenContext\r\n) {\r\n  const { push } = context\r\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n    push(`[`)\r\n    genCompoundExpression(node, context)\r\n    push(`]`)\r\n  } else if (node.isStatic) {\r\n    // only quote keys if necessary\r\n    const text = isSimpleIdentifier(node.content)\r\n      ? node.content\r\n      : JSON.stringify(node.content)\r\n    push(text, node)\r\n  } else {\r\n    push(`[${node.content}]`, node)\r\n  }\r\n}\r\n\r\nfunction genComment(node: CommentNode, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)\r\n}\r\n\r\nfunction genVNodeCall(node: VNodeCall, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const {\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isBlock,\r\n    disableTracking,\r\n    isComponent\r\n  } = node\r\n  if (directives) {\r\n    push(helper(WITH_DIRECTIVES) + `(`)\r\n  }\r\n  if (isBlock) {\r\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\r\n  }\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  const callHelper: symbol = isBlock\r\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\r\n    : getVNodeHelper(context.inSSR, isComponent)\r\n  push(helper(callHelper) + `(`, node)\r\n  genNodeList(\r\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\r\n    context\r\n  )\r\n  push(`)`)\r\n  if (isBlock) {\r\n    push(`)`)\r\n  }\r\n  if (directives) {\r\n    push(`, `)\r\n    genNode(directives, context)\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genNullableArgs(args: any[]): CallExpression['arguments'] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i] != null) break\r\n  }\r\n  return args.slice(0, i + 1).map(arg => arg || `null`)\r\n}\r\n\r\n// JavaScript\r\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\r\n  const { push, helper, pure } = context\r\n  const callee = isString(node.callee) ? node.callee : helper(node.callee)\r\n  if (pure) {\r\n    push(PURE_ANNOTATION)\r\n  }\r\n  push(callee + `(`, node)\r\n  genNodeList(node.arguments, context)\r\n  push(`)`)\r\n}\r\n\r\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\r\n  const { push, indent, deindent, newline } = context\r\n  const { properties } = node\r\n  if (!properties.length) {\r\n    push(`{}`, node)\r\n    return\r\n  }\r\n  const multilines =\r\n    properties.length > 1 ||\r\n    ((!__BROWSER__ || __DEV__) &&\r\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\r\n  push(multilines ? `{` : `{ `)\r\n  multilines && indent()\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const { key, value } = properties[i]\r\n    // key\r\n    genExpressionAsPropertyKey(key, context)\r\n    push(`: `)\r\n    // value\r\n    genNode(value, context)\r\n    if (i < properties.length - 1) {\r\n      // will only reach this if it's multilines\r\n      push(`,`)\r\n      newline()\r\n    }\r\n  }\r\n  multilines && deindent()\r\n  push(multilines ? `}` : ` }`)\r\n}\r\n\r\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\r\n  genNodeListAsArray(node.elements as CodegenNode[], context)\r\n}\r\n\r\nfunction genFunctionExpression(\r\n  node: FunctionExpression,\r\n  context: CodegenContext\r\n) {\r\n  const { push, indent, deindent } = context\r\n  const { params, returns, body, newline, isSlot } = node\r\n  if (isSlot) {\r\n    // wrap slot functions with owner context\r\n    push(`_${helperNameMap[WITH_CTX]}(`)\r\n  }\r\n  push(`(`, node)\r\n  if (isArray(params)) {\r\n    genNodeList(params, context)\r\n  } else if (params) {\r\n    genNode(params, context)\r\n  }\r\n  push(`) => `)\r\n  if (newline || body) {\r\n    push(`{`)\r\n    indent()\r\n  }\r\n  if (returns) {\r\n    if (newline) {\r\n      push(`return `)\r\n    }\r\n    if (isArray(returns)) {\r\n      genNodeListAsArray(returns, context)\r\n    } else {\r\n      genNode(returns, context)\r\n    }\r\n  } else if (body) {\r\n    genNode(body, context)\r\n  }\r\n  if (newline || body) {\r\n    deindent()\r\n    push(`}`)\r\n  }\r\n  if (isSlot) {\r\n    if (__COMPAT__ && node.isNonScopedSlot) {\r\n      push(`, undefined, true`)\r\n    }\r\n    push(`)`)\r\n  }\r\n}\r\n\r\nfunction genConditionalExpression(\r\n  node: ConditionalExpression,\r\n  context: CodegenContext\r\n) {\r\n  const { test, consequent, alternate, newline: needNewline } = node\r\n  const { push, indent, deindent, newline } = context\r\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    const needsParens = !isSimpleIdentifier(test.content)\r\n    needsParens && push(`(`)\r\n    genExpression(test, context)\r\n    needsParens && push(`)`)\r\n  } else {\r\n    push(`(`)\r\n    genNode(test, context)\r\n    push(`)`)\r\n  }\r\n  needNewline && indent()\r\n  context.indentLevel++\r\n  needNewline || push(` `)\r\n  push(`? `)\r\n  genNode(consequent, context)\r\n  context.indentLevel--\r\n  needNewline && newline()\r\n  needNewline || push(` `)\r\n  push(`: `)\r\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n  if (!isNested) {\r\n    context.indentLevel++\r\n  }\r\n  genNode(alternate, context)\r\n  if (!isNested) {\r\n    context.indentLevel--\r\n  }\r\n  needNewline && deindent(true /* without newline */)\r\n}\r\n\r\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\r\n  const { push, helper, indent, deindent, newline } = context\r\n  push(`_cache[${node.index}] || (`)\r\n  if (node.isVNode) {\r\n    indent()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)\r\n    newline()\r\n  }\r\n  push(`_cache[${node.index}] = `)\r\n  genNode(node.value, context)\r\n  if (node.isVNode) {\r\n    push(`,`)\r\n    newline()\r\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`)\r\n    newline()\r\n    push(`_cache[${node.index}]`)\r\n    deindent()\r\n  }\r\n  push(`)`)\r\n}\r\n\r\nfunction genTemplateLiteral(node: TemplateLiteral, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  push('`')\r\n  const l = node.elements.length\r\n  const multilines = l > 3\r\n  for (let i = 0; i < l; i++) {\r\n    const e = node.elements[i]\r\n    if (isString(e)) {\r\n      push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'))\r\n    } else {\r\n      push('${')\r\n      if (multilines) indent()\r\n      genNode(e, context)\r\n      if (multilines) deindent()\r\n      push('}')\r\n    }\r\n  }\r\n  push('`')\r\n}\r\n\r\nfunction genIfStatement(node: IfStatement, context: CodegenContext) {\r\n  const { push, indent, deindent } = context\r\n  const { test, consequent, alternate } = node\r\n  push(`if (`)\r\n  genNode(test, context)\r\n  push(`) {`)\r\n  indent()\r\n  genNode(consequent, context)\r\n  deindent()\r\n  push(`}`)\r\n  if (alternate) {\r\n    push(` else `)\r\n    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {\r\n      genIfStatement(alternate, context)\r\n    } else {\r\n      push(`{`)\r\n      indent()\r\n      genNode(alternate, context)\r\n      deindent()\r\n      push(`}`)\r\n    }\r\n  }\r\n}\r\n\r\nfunction genAssignmentExpression(\r\n  node: AssignmentExpression,\r\n  context: CodegenContext\r\n) {\r\n  genNode(node.left, context)\r\n  context.push(` = `)\r\n  genNode(node.right, context)\r\n}\r\n\r\nfunction genSequenceExpression(\r\n  node: SequenceExpression,\r\n  context: CodegenContext\r\n) {\r\n  context.push(`(`)\r\n  genNodeList(node.expressions, context)\r\n  context.push(`)`)\r\n}\r\n\r\nfunction genReturnStatement(\r\n  { returns }: ReturnStatement,\r\n  context: CodegenContext\r\n) {\r\n  context.push(`return `)\r\n  if (isArray(returns)) {\r\n    genNodeListAsArray(returns, context)\r\n  } else {\r\n    genNode(returns, context)\r\n  }\r\n}\r\n", "// @ts-check\n/** @typedef { import('estree').BaseNode} BaseNode */\n\n/** @typedef {{\n\tskip: () => void;\n\tremove: () => void;\n\treplace: (node: BaseNode) => void;\n}} WalkerContext */\n\nclass WalkerBase {\n\tconstructor() {\n\t\t/** @type {boolean} */\n\t\tthis.should_skip = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.should_remove = false;\n\n\t\t/** @type {BaseNode | null} */\n\t\tthis.replacement = null;\n\n\t\t/** @type {WalkerContext} */\n\t\tthis.context = {\n\t\t\tskip: () => (this.should_skip = true),\n\t\t\tremove: () => (this.should_remove = true),\n\t\t\treplace: (node) => (this.replacement = node)\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param {any} parent\n\t * @param {string} prop\n\t * @param {number} index\n\t * @param {BaseNode} node\n\t */\n\treplace(parent, prop, index, node) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop][index] = node;\n\t\t\t} else {\n\t\t\t\tparent[prop] = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {any} parent\n\t * @param {string} prop\n\t * @param {number} index\n\t */\n\tremove(parent, prop, index) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t} else {\n\t\t\t\tdelete parent[prop];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./walker.js').WalkerContext} WalkerContext */\n\n/** @typedef {(\n *    this: WalkerContext,\n *    node: BaseNode,\n *    parent: BaseNode,\n *    key: string,\n *    index: number\n * ) => void} SyncHandler */\n\nclass SyncWalker extends WalkerBase {\n\t/**\n\t *\n\t * @param {SyncHandler} enter\n\t * @param {SyncHandler} leave\n\t */\n\tconstructor(enter, leave) {\n\t\tsuper();\n\n\t\t/** @type {SyncHandler} */\n\t\tthis.enter = enter;\n\n\t\t/** @type {SyncHandler} */\n\t\tthis.leave = leave;\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} node\n\t * @param {BaseNode} parent\n\t * @param {string} [prop]\n\t * @param {number} [index]\n\t * @returns {BaseNode}\n\t */\n\tvisit(node, parent, prop, index) {\n\t\tif (node) {\n\t\t\tif (this.enter) {\n\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tthis.should_skip = false;\n\t\t\t\tthis.should_remove = false;\n\t\t\t\tthis.replacement = null;\n\n\t\t\t\tthis.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = node[key];\n\n\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\tif (!this.visit(value[i], node, key, i)) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\tthis.visit(value, node, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.leave) {\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tthis.replacement = null;\n\t\t\t\tthis.should_remove = false;\n\n\t\t\t\tthis.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.replacement = _replacement;\n\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./walker').WalkerContext} WalkerContext */\n\n/** @typedef {(\n *    this: WalkerContext,\n *    node: BaseNode,\n *    parent: BaseNode,\n *    key: string,\n *    index: number\n * ) => Promise<void>} AsyncHandler */\n\nclass AsyncWalker extends WalkerBase {\n\t/**\n\t *\n\t * @param {AsyncHandler} enter\n\t * @param {AsyncHandler} leave\n\t */\n\tconstructor(enter, leave) {\n\t\tsuper();\n\n\t\t/** @type {AsyncHandler} */\n\t\tthis.enter = enter;\n\n\t\t/** @type {AsyncHandler} */\n\t\tthis.leave = leave;\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} node\n\t * @param {BaseNode} parent\n\t * @param {string} [prop]\n\t * @param {number} [index]\n\t * @returns {Promise<BaseNode>}\n\t */\n\tasync visit(node, parent, prop, index) {\n\t\tif (node) {\n\t\t\tif (this.enter) {\n\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tthis.should_skip = false;\n\t\t\t\tthis.should_remove = false;\n\t\t\t\tthis.replacement = null;\n\n\t\t\t\tawait this.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = node[key];\n\n\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\tif (!(await this.visit(value[i], node, key, i))) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\tawait this.visit(value, node, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.leave) {\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tthis.replacement = null;\n\t\t\t\tthis.should_remove = false;\n\n\t\t\t\tawait this.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.replacement = _replacement;\n\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./sync.js').SyncHandler} SyncHandler */\n/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */\n\n/**\n *\n * @param {BaseNode} ast\n * @param {{\n *   enter?: SyncHandler\n *   leave?: SyncHandler\n * }} walker\n * @returns {BaseNode}\n */\nfunction walk(ast, { enter, leave }) {\n\tconst instance = new SyncWalker(enter, leave);\n\treturn instance.visit(ast, null);\n}\n\n/**\n *\n * @param {BaseNode} ast\n * @param {{\n *   enter?: AsyncHandler\n *   leave?: AsyncHandler\n * }} walker\n * @returns {Promise<BaseNode>}\n */\nasync function asyncWalk(ast, { enter, leave }) {\n\tconst instance = new AsyncWalker(enter, leave);\n\treturn await instance.visit(ast, null);\n}\n\nexport { asyncWalk, walk };\n", "// should only use types from @babel/types\r\n// do not import runtime methods\r\nimport type {\r\n  Identifier,\r\n  Node,\r\n  Function,\r\n  ObjectProperty,\r\n  BlockStatement,\r\n  Program\r\n} from '@babel/types'\r\nimport { walk } from 'estree-walker'\r\n\r\nexport function walkIdentifiers(\r\n  root: Node,\r\n  onIdentifier: (\r\n    node: Identifier,\r\n    parent: Node,\r\n    parentStack: Node[],\r\n    isReference: boolean,\r\n    isLocal: boolean\r\n  ) => void,\r\n  includeAll = false,\r\n  parentStack: Node[] = [],\r\n  knownIds: Record<string, number> = Object.create(null)\r\n) {\r\n  if (__BROWSER__) {\r\n    return\r\n  }\r\n\r\n  const rootExp =\r\n    root.type === 'Program' &&\r\n    root.body[0].type === 'ExpressionStatement' &&\r\n    root.body[0].expression\r\n\r\n  walk(root, {\r\n    enter(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.push(parent)\r\n      if (\r\n        parent &&\r\n        parent.type.startsWith('TS') &&\r\n        !TS_NODE_TYPES.includes(parent.type)\r\n      ) {\r\n        return this.skip()\r\n      }\r\n      if (node.type === 'Identifier') {\r\n        const isLocal = !!knownIds[node.name]\r\n        const isRefed = isReferencedIdentifier(node, parent!, parentStack)\r\n        if (includeAll || (isRefed && !isLocal)) {\r\n          onIdentifier(node, parent!, parentStack, isRefed, isLocal)\r\n        }\r\n      } else if (\r\n        node.type === 'ObjectProperty' &&\r\n        parent!.type === 'ObjectPattern'\r\n      ) {\r\n        // mark property in destructure pattern\r\n        ;(node as any).inPattern = true\r\n      } else if (isFunctionType(node)) {\r\n        // walk function expressions and add its arguments to known identifiers\r\n        // so that we don't prefix them\r\n        walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds))\r\n      } else if (node.type === 'BlockStatement') {\r\n        // #3445 record block-level local variables\r\n        walkBlockDeclarations(node, id =>\r\n          markScopeIdentifier(node, id, knownIds)\r\n        )\r\n      }\r\n    },\r\n    leave(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\r\n      parent && parentStack.pop()\r\n      if (node !== rootExp && node.scopeIds) {\r\n        for (const id of node.scopeIds) {\r\n          knownIds[id]--\r\n          if (knownIds[id] === 0) {\r\n            delete knownIds[id]\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport function isReferencedIdentifier(\r\n  id: Identifier,\r\n  parent: Node | null,\r\n  parentStack: Node[]\r\n) {\r\n  if (__BROWSER__) {\r\n    return false\r\n  }\r\n\r\n  if (!parent) {\r\n    return true\r\n  }\r\n\r\n  // is a special keyword but parsed as identifier\r\n  if (id.name === 'arguments') {\r\n    return false\r\n  }\r\n\r\n  if (isReferenced(id, parent)) {\r\n    return true\r\n  }\r\n\r\n  // babel's isReferenced check returns false for ids being assigned to, so we\r\n  // need to cover those cases here\r\n  switch (parent.type) {\r\n    case 'AssignmentExpression':\r\n    case 'AssignmentPattern':\r\n      return true\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return isInDestructureAssignment(parent, parentStack)\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function isInDestructureAssignment(\r\n  parent: Node,\r\n  parentStack: Node[]\r\n): boolean {\r\n  if (\r\n    parent &&\r\n    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')\r\n  ) {\r\n    let i = parentStack.length\r\n    while (i--) {\r\n      const p = parentStack[i]\r\n      if (p.type === 'AssignmentExpression') {\r\n        return true\r\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n        break\r\n      }\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nexport function walkFunctionParams(\r\n  node: Function,\r\n  onIdent: (id: Identifier) => void\r\n) {\r\n  for (const p of node.params) {\r\n    for (const id of extractIdentifiers(p)) {\r\n      onIdent(id)\r\n    }\r\n  }\r\n}\r\n\r\nexport function walkBlockDeclarations(\r\n  block: BlockStatement | Program,\r\n  onIdent: (node: Identifier) => void\r\n) {\r\n  for (const stmt of block.body) {\r\n    if (stmt.type === 'VariableDeclaration') {\r\n      if (stmt.declare) continue\r\n      for (const decl of stmt.declarations) {\r\n        for (const id of extractIdentifiers(decl.id)) {\r\n          onIdent(id)\r\n        }\r\n      }\r\n    } else if (\r\n      stmt.type === 'FunctionDeclaration' ||\r\n      stmt.type === 'ClassDeclaration'\r\n    ) {\r\n      if (stmt.declare || !stmt.id) continue\r\n      onIdent(stmt.id)\r\n    } else if (\r\n      stmt.type === 'ForOfStatement' ||\r\n      stmt.type === 'ForInStatement' ||\r\n      stmt.type === 'ForStatement'\r\n    ) {\r\n      const variable = stmt.type === 'ForStatement' ? stmt.init : stmt.left\r\n      if (variable && variable.type === 'VariableDeclaration') {\r\n        for (const decl of variable.declarations) {\r\n          for (const id of extractIdentifiers(decl.id)) {\r\n            onIdent(id)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function extractIdentifiers(\r\n  param: Node,\r\n  nodes: Identifier[] = []\r\n): Identifier[] {\r\n  switch (param.type) {\r\n    case 'Identifier':\r\n      nodes.push(param)\r\n      break\r\n\r\n    case 'MemberExpression':\r\n      let object: any = param\r\n      while (object.type === 'MemberExpression') {\r\n        object = object.object\r\n      }\r\n      nodes.push(object)\r\n      break\r\n\r\n    case 'ObjectPattern':\r\n      for (const prop of param.properties) {\r\n        if (prop.type === 'RestElement') {\r\n          extractIdentifiers(prop.argument, nodes)\r\n        } else {\r\n          extractIdentifiers(prop.value, nodes)\r\n        }\r\n      }\r\n      break\r\n\r\n    case 'ArrayPattern':\r\n      param.elements.forEach(element => {\r\n        if (element) extractIdentifiers(element, nodes)\r\n      })\r\n      break\r\n\r\n    case 'RestElement':\r\n      extractIdentifiers(param.argument, nodes)\r\n      break\r\n\r\n    case 'AssignmentPattern':\r\n      extractIdentifiers(param.left, nodes)\r\n      break\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\nfunction markScopeIdentifier(\r\n  node: Node & { scopeIds?: Set<string> },\r\n  child: Identifier,\r\n  knownIds: Record<string, number>\r\n) {\r\n  const { name } = child\r\n  if (node.scopeIds && node.scopeIds.has(name)) {\r\n    return\r\n  }\r\n  if (name in knownIds) {\r\n    knownIds[name]++\r\n  } else {\r\n    knownIds[name] = 1\r\n  }\r\n  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\r\n}\r\n\r\nexport const isFunctionType = (node: Node): node is Function => {\r\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)\r\n}\r\n\r\nexport const isStaticProperty = (node: Node): node is ObjectProperty =>\r\n  node &&\r\n  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n  !node.computed\r\n\r\nexport const isStaticPropertyKey = (node: Node, parent: Node) =>\r\n  isStaticProperty(parent) && parent.key === node\r\n\r\n/**\r\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\r\n * To avoid runtime dependency on @babel/types (which includes process references)\r\n * This file should not change very often in babel but we may need to keep it\r\n * up-to-date from time to time.\r\n *\r\n * https://github.com/babel/babel/blob/main/LICENSE\r\n *\r\n */\r\nfunction isReferenced(node: Node, parent: Node, grandparent?: Node): boolean {\r\n  switch (parent.type) {\r\n    // yes: PARENT[NODE]\r\n    // yes: NODE.child\r\n    // no: parent.NODE\r\n    case 'MemberExpression':\r\n    case 'OptionalMemberExpression':\r\n      if (parent.property === node) {\r\n        return !!parent.computed\r\n      }\r\n      return parent.object === node\r\n\r\n    case 'JSXMemberExpression':\r\n      return parent.object === node\r\n    // no: let NODE = init;\r\n    // yes: let id = NODE;\r\n    case 'VariableDeclarator':\r\n      return parent.init === node\r\n\r\n    // yes: () => NODE\r\n    // no: (NODE) => {}\r\n    case 'ArrowFunctionExpression':\r\n      return parent.body === node\r\n\r\n    // no: class { #NODE; }\r\n    // no: class { get #NODE() {} }\r\n    // no: class { #NODE() {} }\r\n    // no: class { fn() { return this.#NODE; } }\r\n    case 'PrivateName':\r\n      return false\r\n\r\n    // no: class { NODE() {} }\r\n    // yes: class { [NODE]() {} }\r\n    // no: class { foo(NODE) {} }\r\n    case 'ClassMethod':\r\n    case 'ClassPrivateMethod':\r\n    case 'ObjectMethod':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return false\r\n\r\n    // yes: { [NODE]: \"\" }\r\n    // no: { NODE: \"\" }\r\n    // depends: { NODE }\r\n    // depends: { key: NODE }\r\n    case 'ObjectProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      // parent.value === node\r\n      return !grandparent || grandparent.type !== 'ObjectPattern'\r\n    // no: class { NODE = value; }\r\n    // yes: class { [NODE] = value; }\r\n    // yes: class { key = NODE; }\r\n    case 'ClassProperty':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n      return true\r\n    case 'ClassPrivateProperty':\r\n      return parent.key !== node\r\n\r\n    // no: class NODE {}\r\n    // yes: class Foo extends NODE {}\r\n    case 'ClassDeclaration':\r\n    case 'ClassExpression':\r\n      return parent.superClass === node\r\n\r\n    // yes: left = NODE;\r\n    // no: NODE = right;\r\n    case 'AssignmentExpression':\r\n      return parent.right === node\r\n\r\n    // no: [NODE = foo] = [];\r\n    // yes: [foo = NODE] = [];\r\n    case 'AssignmentPattern':\r\n      return parent.right === node\r\n\r\n    // no: NODE: for (;;) {}\r\n    case 'LabeledStatement':\r\n      return false\r\n\r\n    // no: try {} catch (NODE) {}\r\n    case 'CatchClause':\r\n      return false\r\n\r\n    // no: function foo(...NODE) {}\r\n    case 'RestElement':\r\n      return false\r\n\r\n    case 'BreakStatement':\r\n    case 'ContinueStatement':\r\n      return false\r\n\r\n    // no: function NODE() {}\r\n    // no: function foo(NODE) {}\r\n    case 'FunctionDeclaration':\r\n    case 'FunctionExpression':\r\n      return false\r\n\r\n    // no: export NODE from \"foo\";\r\n    // no: export * as NODE from \"foo\";\r\n    case 'ExportNamespaceSpecifier':\r\n    case 'ExportDefaultSpecifier':\r\n      return false\r\n\r\n    // no: export { foo as NODE };\r\n    // yes: export { NODE as foo };\r\n    // no: export { NODE as foo } from \"foo\";\r\n    case 'ExportSpecifier':\r\n      // @ts-expect-error\r\n      if (grandparent?.source) {\r\n        return false\r\n      }\r\n      return parent.local === node\r\n\r\n    // no: import NODE from \"foo\";\r\n    // no: import * as NODE from \"foo\";\r\n    // no: import { NODE as foo } from \"foo\";\r\n    // no: import { foo as NODE } from \"foo\";\r\n    // no: import NODE from \"bar\";\r\n    case 'ImportDefaultSpecifier':\r\n    case 'ImportNamespaceSpecifier':\r\n    case 'ImportSpecifier':\r\n      return false\r\n\r\n    // no: import \"foo\" assert { NODE: \"json\" }\r\n    case 'ImportAttribute':\r\n      return false\r\n\r\n    // no: <div NODE=\"foo\" />\r\n    case 'JSXAttribute':\r\n      return false\r\n\r\n    // no: [NODE] = [];\r\n    // no: ({ NODE }) = [];\r\n    case 'ObjectPattern':\r\n    case 'ArrayPattern':\r\n      return false\r\n\r\n    // no: new.NODE\r\n    // no: NODE.target\r\n    case 'MetaProperty':\r\n      return false\r\n\r\n    // yes: type X = { someProperty: NODE }\r\n    // no: type X = { NODE: OtherType }\r\n    case 'ObjectTypeProperty':\r\n      return parent.key !== node\r\n\r\n    // yes: enum X { Foo = NODE }\r\n    // no: enum X { NODE }\r\n    case 'TSEnumMember':\r\n      return parent.id !== node\r\n\r\n    // yes: { [NODE]: value }\r\n    // no: { NODE: value }\r\n    case 'TSPropertySignature':\r\n      if (parent.key === node) {\r\n        return !!parent.computed\r\n      }\r\n\r\n      return true\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport const TS_NODE_TYPES = [\r\n  'TSAsExpression', // foo as number\r\n  'TSTypeAssertion', // (<number>foo)\r\n  'TSNonNullExpression', // foo!\r\n  'TSInstantiationExpression', // foo<string>\r\n  'TSSatisfiesExpression' // foo satisfies T\r\n]\r\n", "import { SimpleExpressionNode } from './ast'\r\nimport { TransformContext } from './transform'\r\nimport { createCompilerError, ErrorCodes } from './errors'\r\n\r\n// these keywords should not appear inside expressions, but operators like\r\n// 'typeof', 'instanceof', and 'in' are allowed\r\nconst prohibitedKeywordRE = new RegExp(\r\n  '\\\\b' +\r\n    (\r\n      'arguments,await,break,case,catch,class,const,continue,debugger,default,' +\r\n      'delete,do,else,export,extends,finally,for,function,if,import,let,new,' +\r\n      'return,super,switch,throw,try,var,void,while,with,yield'\r\n    )\r\n      .split(',')\r\n      .join('\\\\b|\\\\b') +\r\n    '\\\\b'\r\n)\r\n\r\n// strip strings in expressions\r\nconst stripStringRE =\r\n  /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g\r\n\r\n/**\r\n * Validate a non-prefixed expression.\r\n * This is only called when using the in-browser runtime compiler since it\r\n * doesn't prefix expressions.\r\n */\r\nexport function validateBrowserExpression(\r\n  node: SimpleExpressionNode,\r\n  context: TransformContext,\r\n  asParams = false,\r\n  asRawStatements = false\r\n) {\r\n  const exp = node.content\r\n\r\n  // empty expressions are validated per-directive since some directives\r\n  // do allow empty expressions.\r\n  if (!exp.trim()) {\r\n    return\r\n  }\r\n\r\n  try {\r\n    new Function(\r\n      asRawStatements\r\n        ? ` ${exp} `\r\n        : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`\r\n    )\r\n  } catch (e: any) {\r\n    let message = e.message\r\n    const keywordMatch = exp\r\n      .replace(stripStringRE, '')\r\n      .match(prohibitedKeywordRE)\r\n    if (keywordMatch) {\r\n      message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`\r\n    }\r\n    context.onError(\r\n      createCompilerError(\r\n        ErrorCodes.X_INVALID_EXPRESSION,\r\n        node.loc,\r\n        undefined,\r\n        message\r\n      )\r\n    )\r\n  }\r\n}\r\n", "// - Parse expressions in templates into compound expressions so that each\r\n//   identifier gets more accurate source-map locations.\r\n//\r\n// - Prefix identifiers with `_ctx.` or `$xxx` (for known binding types) so that\r\n//   they are accessed from the right source\r\n//\r\n// - This transform is only applied in non-browser builds because it relies on\r\n//   an additional JavaScript parser. In the browser, there is no source-map\r\n//   support and the code is wrapped in `with (this) { ... }`.\r\nimport { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  createSimpleExpression,\r\n  ExpressionNode,\r\n  SimpleExpressionNode,\r\n  CompoundExpressionNode,\r\n  createCompoundExpression,\r\n  ConstantTypes\r\n} from '../ast'\r\nimport {\r\n  isInDestructureAssignment,\r\n  isStaticProperty,\r\n  isStaticPropertyKey,\r\n  walkIdentifiers\r\n} from '../babelUtils'\r\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils'\r\nimport {\r\n  isGloballyAllowed,\r\n  makeMap,\r\n  hasOwn,\r\n  isString,\r\n  genPropsAccessExp\r\n} from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  Node,\r\n  Identifier,\r\n  AssignmentExpression,\r\n  UpdateExpression\r\n} from '@babel/types'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { parse } from '@babel/parser'\r\nimport { IS_REF, UNREF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\n\r\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\r\n\r\n// a heuristic safeguard to bail constant expressions on presence of\r\n// likely function invocation and member access\r\nconst constantBailRE = /\\w\\s*\\(|\\.[^\\d]/\r\n\r\nexport const transformExpression: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.INTERPOLATION) {\r\n    node.content = processExpression(\r\n      node.content as SimpleExpressionNode,\r\n      context\r\n    )\r\n  } else if (node.type === NodeTypes.ELEMENT) {\r\n    // handle directives on element\r\n    for (let i = 0; i < node.props.length; i++) {\r\n      const dir = node.props[i]\r\n      // do not process for v-on & v-for since they are special handled\r\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\r\n        const exp = dir.exp\r\n        const arg = dir.arg\r\n        // do not process exp if this is v-on:arg - we need special handling\r\n        // for wrapping inline statements.\r\n        if (\r\n          exp &&\r\n          exp.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n          !(dir.name === 'on' && arg)\r\n        ) {\r\n          dir.exp = processExpression(\r\n            exp,\r\n            context,\r\n            // slot args must be processed as function params\r\n            dir.name === 'slot'\r\n          )\r\n        }\r\n        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {\r\n          dir.arg = processExpression(arg, context)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface PrefixMeta {\r\n  prefix?: string\r\n  isConstant: boolean\r\n  start: number\r\n  end: number\r\n  scopeIds?: Set<string>\r\n}\r\n\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !__BROWSER__ check so that it can be\r\n// tree-shaken from the browser build.\r\nexport function processExpression(\r\n  node: SimpleExpressionNode,\r\n  context: TransformContext,\r\n  // some expressions like v-slot props & v-for aliases should be parsed as\r\n  // function params\r\n  asParams = false,\r\n  // v-on handler values may contain multiple statements\r\n  asRawStatements = false,\r\n  localVars: Record<string, number> = Object.create(context.identifiers)\r\n): ExpressionNode {\r\n  if (__BROWSER__) {\r\n    if (__DEV__) {\r\n      // simple in-browser validation (same logic in 2.x)\r\n      validateBrowserExpression(node, context, asParams, asRawStatements)\r\n    }\r\n    return node\r\n  }\r\n\r\n  if (!context.prefixIdentifiers || !node.content.trim()) {\r\n    return node\r\n  }\r\n\r\n  const { inline, bindingMetadata } = context\r\n  const rewriteIdentifier = (raw: string, parent?: Node, id?: Identifier) => {\r\n    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]\r\n    if (inline) {\r\n      // x = y\r\n      const isAssignmentLVal =\r\n        parent && parent.type === 'AssignmentExpression' && parent.left === id\r\n      // x++\r\n      const isUpdateArg =\r\n        parent && parent.type === 'UpdateExpression' && parent.argument === id\r\n      // ({ x } = y)\r\n      const isDestructureAssignment =\r\n        parent && isInDestructureAssignment(parent, parentStack)\r\n\r\n      if (\r\n        isConst(type) ||\r\n        type === BindingTypes.SETUP_REACTIVE_CONST ||\r\n        localVars[raw]\r\n      ) {\r\n        return raw\r\n      } else if (type === BindingTypes.SETUP_REF) {\r\n        return `${raw}.value`\r\n      } else if (type === BindingTypes.SETUP_MAYBE_REF) {\r\n        // const binding that may or may not be ref\r\n        // if it's not a ref, then assignments don't make sense -\r\n        // so we ignore the non-ref assignment case and generate code\r\n        // that assumes the value to be a ref for more efficiency\r\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment\r\n          ? `${raw}.value`\r\n          : `${context.helperString(UNREF)}(${raw})`\r\n      } else if (type === BindingTypes.SETUP_LET) {\r\n        if (isAssignmentLVal) {\r\n          // let binding.\r\n          // this is a bit more tricky as we need to cover the case where\r\n          // let is a local non-ref value, and we need to replicate the\r\n          // right hand side value.\r\n          // x = y --> isRef(x) ? x.value = y : x = y\r\n          const { right: rVal, operator } = parent as AssignmentExpression\r\n          const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)\r\n          const rExpString = stringifyExpression(\r\n            processExpression(\r\n              createSimpleExpression(rExp, false),\r\n              context,\r\n              false,\r\n              false,\r\n              knownIds\r\n            )\r\n          )\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${raw}.value ${operator} ${rExpString} : ${raw}`\r\n        } else if (isUpdateArg) {\r\n          // make id replace parent in the code range so the raw update operator\r\n          // is removed\r\n          id!.start = parent!.start\r\n          id!.end = parent!.end\r\n          const { prefix: isPrefix, operator } = parent as UpdateExpression\r\n          const prefix = isPrefix ? operator : ``\r\n          const postfix = isPrefix ? `` : operator\r\n          // let binding.\r\n          // x++ --> isRef(a) ? a.value++ : a++\r\n          return `${context.helperString(IS_REF)}(${raw})${\r\n            context.isTS ? ` //@ts-ignore\\n` : ``\r\n          } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`\r\n        } else if (isDestructureAssignment) {\r\n          // TODO\r\n          // let binding in a destructure assignment - it's very tricky to\r\n          // handle both possible cases here without altering the original\r\n          // structure of the code, so we just assume it's not a ref here\r\n          // for now\r\n          return raw\r\n        } else {\r\n          return `${context.helperString(UNREF)}(${raw})`\r\n        }\r\n      } else if (type === BindingTypes.PROPS) {\r\n        // use __props which is generated by compileScript so in ts mode\r\n        // it gets correct type\r\n        return genPropsAccessExp(raw)\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        // prop with a different local alias (from defineProps() destructure)\r\n        return genPropsAccessExp(bindingMetadata.__propsAliases![raw])\r\n      }\r\n    } else {\r\n      if (\r\n        (type && type.startsWith('setup')) ||\r\n        type === BindingTypes.LITERAL_CONST\r\n      ) {\r\n        // setup bindings in non-inline mode\r\n        return `$setup.${raw}`\r\n      } else if (type === BindingTypes.PROPS_ALIASED) {\r\n        return `$props['${bindingMetadata.__propsAliases![raw]}']`\r\n      } else if (type) {\r\n        return `$${type}.${raw}`\r\n      }\r\n    }\r\n\r\n    // fallback to ctx\r\n    return `_ctx.${raw}`\r\n  }\r\n\r\n  // fast path if expression is a simple identifier.\r\n  const rawExp = node.content\r\n  // bail constant on parens (function invocation) and dot (member access)\r\n  const bailConstant = constantBailRE.test(rawExp)\r\n\r\n  if (isSimpleIdentifier(rawExp)) {\r\n    const isScopeVarReference = context.identifiers[rawExp]\r\n    const isAllowedGlobal = isGloballyAllowed(rawExp)\r\n    const isLiteral = isLiteralWhitelisted(rawExp)\r\n    if (\r\n      !asParams &&\r\n      !isScopeVarReference &&\r\n      !isLiteral &&\r\n      (!isAllowedGlobal || bindingMetadata[rawExp])\r\n    ) {\r\n      // const bindings exposed from setup can be skipped for patching but\r\n      // cannot be hoisted to module scope\r\n      if (isConst(bindingMetadata[rawExp])) {\r\n        node.constType = ConstantTypes.CAN_SKIP_PATCH\r\n      }\r\n      node.content = rewriteIdentifier(rawExp)\r\n    } else if (!isScopeVarReference) {\r\n      if (isLiteral) {\r\n        node.constType = ConstantTypes.CAN_STRINGIFY\r\n      } else {\r\n        node.constType = ConstantTypes.CAN_HOIST\r\n      }\r\n    }\r\n    return node\r\n  }\r\n\r\n  let ast: any\r\n  // exp needs to be parsed differently:\r\n  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\r\n  //    exp, but make sure to pad with spaces for consistent ranges\r\n  // 2. Expressions: wrap with parens (for e.g. object expressions)\r\n  // 3. Function arguments (v-for, v-slot): place in a function argument position\r\n  const source = asRawStatements\r\n    ? ` ${rawExp} `\r\n    : `(${rawExp})${asParams ? `=>{}` : ``}`\r\n  try {\r\n    ast = parse(source, {\r\n      plugins: context.expressionPlugins\r\n    }).program\r\n  } catch (e: any) {\r\n    context.onError(\r\n      createCompilerError(\r\n        ErrorCodes.X_INVALID_EXPRESSION,\r\n        node.loc,\r\n        undefined,\r\n        e.message\r\n      )\r\n    )\r\n    return node\r\n  }\r\n\r\n  type QualifiedId = Identifier & PrefixMeta\r\n  const ids: QualifiedId[] = []\r\n  const parentStack: Node[] = []\r\n  const knownIds: Record<string, number> = Object.create(context.identifiers)\r\n\r\n  walkIdentifiers(\r\n    ast,\r\n    (node, parent, _, isReferenced, isLocal) => {\r\n      if (isStaticPropertyKey(node, parent!)) {\r\n        return\r\n      }\r\n      // v2 wrapped filter call\r\n      if (__COMPAT__ && node.name.startsWith('_filter_')) {\r\n        return\r\n      }\r\n\r\n      const needPrefix = isReferenced && canPrefix(node)\r\n      if (needPrefix && !isLocal) {\r\n        if (isStaticProperty(parent!) && parent.shorthand) {\r\n          // property shorthand like { foo }, we need to add the key since\r\n          // we rewrite the value\r\n          ;(node as QualifiedId).prefix = `${node.name}: `\r\n        }\r\n        node.name = rewriteIdentifier(node.name, parent, node)\r\n        ids.push(node as QualifiedId)\r\n      } else {\r\n        // The identifier is considered constant unless it's pointing to a\r\n        // local scope variable (a v-for alias, or a v-slot prop)\r\n        if (!(needPrefix && isLocal) && !bailConstant) {\r\n          ;(node as QualifiedId).isConstant = true\r\n        }\r\n        // also generate sub-expressions for other identifiers for better\r\n        // source map support. (except for property keys which are static)\r\n        ids.push(node as QualifiedId)\r\n      }\r\n    },\r\n    true, // invoke on ALL identifiers\r\n    parentStack,\r\n    knownIds\r\n  )\r\n\r\n  // We break up the compound expression into an array of strings and sub\r\n  // expressions (for identifiers that have been prefixed). In codegen, if\r\n  // an ExpressionNode has the `.children` property, it will be used instead of\r\n  // `.content`.\r\n  const children: CompoundExpressionNode['children'] = []\r\n  ids.sort((a, b) => a.start - b.start)\r\n  ids.forEach((id, i) => {\r\n    // range is offset by -1 due to the wrapping parens when parsed\r\n    const start = id.start - 1\r\n    const end = id.end - 1\r\n    const last = ids[i - 1]\r\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\r\n    if (leadingText.length || id.prefix) {\r\n      children.push(leadingText + (id.prefix || ``))\r\n    }\r\n    const source = rawExp.slice(start, end)\r\n    children.push(\r\n      createSimpleExpression(\r\n        id.name,\r\n        false,\r\n        {\r\n          source,\r\n          start: advancePositionWithClone(node.loc.start, source, start),\r\n          end: advancePositionWithClone(node.loc.start, source, end)\r\n        },\r\n        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT\r\n      )\r\n    )\r\n    if (i === ids.length - 1 && end < rawExp.length) {\r\n      children.push(rawExp.slice(end))\r\n    }\r\n  })\r\n\r\n  let ret\r\n  if (children.length) {\r\n    ret = createCompoundExpression(children, node.loc)\r\n  } else {\r\n    ret = node\r\n    ret.constType = bailConstant\r\n      ? ConstantTypes.NOT_CONSTANT\r\n      : ConstantTypes.CAN_STRINGIFY\r\n  }\r\n  ret.identifiers = Object.keys(knownIds)\r\n  return ret\r\n}\r\n\r\nfunction canPrefix(id: Identifier) {\r\n  // skip whitelisted globals\r\n  if (isGloballyAllowed(id.name)) {\r\n    return false\r\n  }\r\n  // special case for webpack compilation\r\n  if (id.name === 'require') {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nexport function stringifyExpression(exp: ExpressionNode | string): string {\r\n  if (isString(exp)) {\r\n    return exp\r\n  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    return exp.content\r\n  } else {\r\n    return (exp.children as (ExpressionNode | string)[])\r\n      .map(stringifyExpression)\r\n      .join('')\r\n  }\r\n}\r\n\r\nfunction isConst(type: unknown) {\r\n  return (\r\n    type === BindingTypes.SETUP_CONST || type === BindingTypes.LITERAL_CONST\r\n  )\r\n}\r\n", "import {\r\n  createStructuralDirectiveTransform,\r\n  TransformContext,\r\n  traverseNode\r\n} from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ElementTypes,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  IfBranchNode,\r\n  SimpleExpressionNode,\r\n  createCallExpression,\r\n  createConditionalExpression,\r\n  createSimpleExpression,\r\n  createObjectProperty,\r\n  createObjectExpression,\r\n  IfConditionalExpression,\r\n  BlockCodegenNode,\r\n  IfNode,\r\n  createVNodeCall,\r\n  AttributeNode,\r\n  locStub,\r\n  CacheExpression,\r\n  ConstantTypes,\r\n  MemoExpression,\r\n  convertToBlock\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { FRAGMENT, CREATE_COMMENT } from '../runtimeHelpers'\r\nimport {\r\n  injectProp,\r\n  findDir,\r\n  findProp,\r\n  isBuiltInType,\r\n  getMemoedVNodeCall\r\n} from '../utils'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\n\r\nexport const transformIf = createStructuralDirectiveTransform(\r\n  /^(if|else|else-if)$/,\r\n  (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n      // #1587: We need to dynamically increment the key based on the current\r\n      // node's sibling nodes, since chained v-if/else branches are\r\n      // rendered at the same depth\r\n      const siblings = context.parent!.children\r\n      let i = siblings.indexOf(ifNode)\r\n      let key = 0\r\n      while (i-- >= 0) {\r\n        const sibling = siblings[i]\r\n        if (sibling && sibling.type === NodeTypes.IF) {\r\n          key += sibling.branches.length\r\n        }\r\n      }\r\n\r\n      // Exit callback. Complete the codegenNode when all children have been\r\n      // transformed.\r\n      return () => {\r\n        if (isRoot) {\r\n          ifNode.codegenNode = createCodegenNodeForBranch(\r\n            branch,\r\n            key,\r\n            context\r\n          ) as IfConditionalExpression\r\n        } else {\r\n          // attach this branch's codegen node to the v-if root.\r\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\r\n          parentCondition.alternate = createCodegenNodeForBranch(\r\n            branch,\r\n            key + ifNode.branches.length - 1,\r\n            context\r\n          )\r\n        }\r\n      }\r\n    })\r\n  }\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processIf(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (\r\n    node: IfNode,\r\n    branch: IfBranchNode,\r\n    isRoot: boolean\r\n  ) => (() => void) | undefined\r\n) {\r\n  if (\r\n    dir.name !== 'else' &&\r\n    (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\r\n  ) {\r\n    const loc = dir.exp ? dir.exp.loc : node.loc\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\r\n    )\r\n    dir.exp = createSimpleExpression(`true`, false, loc)\r\n  }\r\n\r\n  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\r\n    // dir.exp can only be simple expression because vIf transform is applied\r\n    // before expression transform.\r\n    dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (__DEV__ && __BROWSER__ && dir.exp) {\r\n    validateBrowserExpression(dir.exp as SimpleExpressionNode, context)\r\n  }\r\n\r\n  if (dir.name === 'if') {\r\n    const branch = createIfBranch(node, dir)\r\n    const ifNode: IfNode = {\r\n      type: NodeTypes.IF,\r\n      loc: node.loc,\r\n      branches: [branch]\r\n    }\r\n    context.replaceNode(ifNode)\r\n    if (processCodegen) {\r\n      return processCodegen(ifNode, branch, true)\r\n    }\r\n  } else {\r\n    // locate the adjacent v-if\r\n    const siblings = context.parent!.children\r\n    const comments = []\r\n    let i = siblings.indexOf(node)\r\n    while (i-- >= -1) {\r\n      const sibling = siblings[i]\r\n      if (sibling && sibling.type === NodeTypes.COMMENT) {\r\n        context.removeNode(sibling)\r\n        __DEV__ && comments.unshift(sibling)\r\n        continue\r\n      }\r\n\r\n      if (\r\n        sibling &&\r\n        sibling.type === NodeTypes.TEXT &&\r\n        !sibling.content.trim().length\r\n      ) {\r\n        context.removeNode(sibling)\r\n        continue\r\n      }\r\n\r\n      if (sibling && sibling.type === NodeTypes.IF) {\r\n        // Check if v-else was followed by v-else-if\r\n        if (\r\n          dir.name === 'else-if' &&\r\n          sibling.branches[sibling.branches.length - 1].condition === undefined\r\n        ) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\r\n          )\r\n        }\r\n\r\n        // move the node to the if node's branches\r\n        context.removeNode()\r\n        const branch = createIfBranch(node, dir)\r\n        if (\r\n          __DEV__ &&\r\n          comments.length &&\r\n          // #3619 ignore comments if the v-if is direct child of <transition>\r\n          !(\r\n            context.parent &&\r\n            context.parent.type === NodeTypes.ELEMENT &&\r\n            isBuiltInType(context.parent.tag, 'transition')\r\n          )\r\n        ) {\r\n          branch.children = [...comments, ...branch.children]\r\n        }\r\n\r\n        // check if user is forcing same key on different branches\r\n        if (__DEV__ || !__BROWSER__) {\r\n          const key = branch.userKey\r\n          if (key) {\r\n            sibling.branches.forEach(({ userKey }) => {\r\n              if (isSameKey(userKey, key)) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_IF_SAME_KEY,\r\n                    branch.userKey!.loc\r\n                  )\r\n                )\r\n              }\r\n            })\r\n          }\r\n        }\r\n\r\n        sibling.branches.push(branch)\r\n        const onExit = processCodegen && processCodegen(sibling, branch, false)\r\n        // since the branch was removed, it will not be traversed.\r\n        // make sure to traverse here.\r\n        traverseNode(branch, context)\r\n        // call on exit\r\n        if (onExit) onExit()\r\n        // make sure to reset currentNode after traversal to indicate this\r\n        // node has been removed.\r\n        context.currentNode = null\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\r\n        )\r\n      }\r\n      break\r\n    }\r\n  }\r\n}\r\n\r\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\r\n  const isTemplateIf = node.tagType === ElementTypes.TEMPLATE\r\n  return {\r\n    type: NodeTypes.IF_BRANCH,\r\n    loc: node.loc,\r\n    condition: dir.name === 'else' ? undefined : dir.exp,\r\n    children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\r\n    userKey: findProp(node, `key`),\r\n    isTemplateIf\r\n  }\r\n}\r\n\r\nfunction createCodegenNodeForBranch(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext\r\n): IfConditionalExpression | BlockCodegenNode | MemoExpression {\r\n  if (branch.condition) {\r\n    return createConditionalExpression(\r\n      branch.condition,\r\n      createChildrenCodegenNode(branch, keyIndex, context),\r\n      // make sure to pass in asBlock: true so that the comment node call\r\n      // closes the current block.\r\n      createCallExpression(context.helper(CREATE_COMMENT), [\r\n        __DEV__ ? '\"v-if\"' : '\"\"',\r\n        'true'\r\n      ])\r\n    ) as IfConditionalExpression\r\n  } else {\r\n    return createChildrenCodegenNode(branch, keyIndex, context)\r\n  }\r\n}\r\n\r\nfunction createChildrenCodegenNode(\r\n  branch: IfBranchNode,\r\n  keyIndex: number,\r\n  context: TransformContext\r\n): BlockCodegenNode | MemoExpression {\r\n  const { helper } = context\r\n  const keyProperty = createObjectProperty(\r\n    `key`,\r\n    createSimpleExpression(\r\n      `${keyIndex}`,\r\n      false,\r\n      locStub,\r\n      ConstantTypes.CAN_HOIST\r\n    )\r\n  )\r\n  const { children } = branch\r\n  const firstChild = children[0]\r\n  const needFragmentWrapper =\r\n    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT\r\n  if (needFragmentWrapper) {\r\n    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {\r\n      // optimize away nested fragments when child is a ForNode\r\n      const vnodeCall = firstChild.codegenNode!\r\n      injectProp(vnodeCall, keyProperty, context)\r\n      return vnodeCall\r\n    } else {\r\n      let patchFlag = PatchFlags.STABLE_FRAGMENT\r\n      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\r\n      // check if the fragment actually contains a single valid child with\r\n      // the rest being comments\r\n      if (\r\n        __DEV__ &&\r\n        !branch.isTemplateIf &&\r\n        children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\r\n      ) {\r\n        patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\r\n        patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\r\n      }\r\n\r\n      return createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        createObjectExpression([keyProperty]),\r\n        children,\r\n        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true,\r\n        false,\r\n        false /* isComponent */,\r\n        branch.loc\r\n      )\r\n    }\r\n  } else {\r\n    const ret = (firstChild as ElementNode).codegenNode as\r\n      | BlockCodegenNode\r\n      | MemoExpression\r\n    const vnodeCall = getMemoedVNodeCall(ret)\r\n    // Change createVNode to createBlock.\r\n    if (vnodeCall.type === NodeTypes.VNODE_CALL) {\r\n      convertToBlock(vnodeCall, context)\r\n    }\r\n    // inject branch key\r\n    injectProp(vnodeCall, keyProperty, context)\r\n    return ret\r\n  }\r\n}\r\n\r\nfunction isSameKey(\r\n  a: AttributeNode | DirectiveNode | undefined,\r\n  b: AttributeNode | DirectiveNode\r\n): boolean {\r\n  if (!a || a.type !== b.type) {\r\n    return false\r\n  }\r\n  if (a.type === NodeTypes.ATTRIBUTE) {\r\n    if (a.value!.content !== (b as AttributeNode).value!.content) {\r\n      return false\r\n    }\r\n  } else {\r\n    // directive\r\n    const exp = a.exp!\r\n    const branchExp = (b as DirectiveNode).exp!\r\n    if (exp.type !== branchExp.type) {\r\n      return false\r\n    }\r\n    if (\r\n      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n      exp.isStatic !== (branchExp as SimpleExpressionNode).isStatic ||\r\n      exp.content !== (branchExp as SimpleExpressionNode).content\r\n    ) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction getParentCondition(\r\n  node: IfConditionalExpression | CacheExpression\r\n): IfConditionalExpression {\r\n  while (true) {\r\n    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\r\n        node = node.alternate\r\n      } else {\r\n        return node\r\n      }\r\n    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {\r\n      node = node.value as IfConditionalExpression\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  createStructuralDirectiveTransform,\r\n  TransformContext\r\n} from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ExpressionNode,\r\n  createSimpleExpression,\r\n  SourceLocation,\r\n  SimpleExpressionNode,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  ForCodegenNode,\r\n  RenderSlotCall,\r\n  SlotOutletNode,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  ForNode,\r\n  PlainElementNode,\r\n  createVNodeCall,\r\n  VNodeCall,\r\n  ForRenderListExpression,\r\n  BlockCodegenNode,\r\n  ForIteratorExpression,\r\n  ConstantTypes,\r\n  createBlockStatement,\r\n  createCompoundExpression,\r\n  getVNodeBlockHelper,\r\n  getVNodeHelper\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  getInnerRange,\r\n  findProp,\r\n  isTemplateNode,\r\n  isSlotOutlet,\r\n  injectProp,\r\n  findDir,\r\n  forAliasRE\r\n} from '../utils'\r\nimport {\r\n  RENDER_LIST,\r\n  OPEN_BLOCK,\r\n  FRAGMENT,\r\n  IS_MEMO_SAME\r\n} from '../runtimeHelpers'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\n\r\nexport const transformFor = createStructuralDirectiveTransform(\r\n  'for',\r\n  (node, dir, context) => {\r\n    const { helper, removeHelper } = context\r\n    return processFor(node, dir, context, forNode => {\r\n      // create the loop render function expression now, and add the\r\n      // iterator on exit after all children have been traversed\r\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n        forNode.source\r\n      ]) as ForRenderListExpression\r\n      const isTemplate = isTemplateNode(node)\r\n      const memo = findDir(node, 'memo')\r\n      const keyProp = findProp(node, `key`)\r\n      const keyExp =\r\n        keyProp &&\r\n        (keyProp.type === NodeTypes.ATTRIBUTE\r\n          ? createSimpleExpression(keyProp.value!.content, true)\r\n          : keyProp.exp!)\r\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp!) : null\r\n\r\n      if (!__BROWSER__ && isTemplate) {\r\n        // #2085 / #5288 process :key and v-memo expressions need to be\r\n        // processed on `<template v-for>`. In this case the node is discarded\r\n        // and never traversed so its binding expressions won't be processed\r\n        // by the normal transforms.\r\n        if (memo) {\r\n          memo.exp = processExpression(\r\n            memo.exp! as SimpleExpressionNode,\r\n            context\r\n          )\r\n        }\r\n        if (keyProperty && keyProp!.type !== NodeTypes.ATTRIBUTE) {\r\n          keyProperty.value = processExpression(\r\n            keyProperty.value as SimpleExpressionNode,\r\n            context\r\n          )\r\n        }\r\n      }\r\n\r\n      const isStableFragment =\r\n        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        forNode.source.constType > ConstantTypes.NOT_CONSTANT\r\n      const fragmentFlag = isStableFragment\r\n        ? PatchFlags.STABLE_FRAGMENT\r\n        : keyProp\r\n          ? PatchFlags.KEYED_FRAGMENT\r\n          : PatchFlags.UNKEYED_FRAGMENT\r\n\r\n      forNode.codegenNode = createVNodeCall(\r\n        context,\r\n        helper(FRAGMENT),\r\n        undefined,\r\n        renderExp,\r\n        fragmentFlag +\r\n          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),\r\n        undefined,\r\n        undefined,\r\n        true /* isBlock */,\r\n        !isStableFragment /* disableTracking */,\r\n        false /* isComponent */,\r\n        node.loc\r\n      ) as ForCodegenNode\r\n\r\n      return () => {\r\n        // finish the codegen now that all children have been traversed\r\n        let childBlock: BlockCodegenNode\r\n        const { children } = forNode\r\n\r\n        // check <template v-for> key placement\r\n        if ((__DEV__ || !__BROWSER__) && isTemplate) {\r\n          node.children.some(c => {\r\n            if (c.type === NodeTypes.ELEMENT) {\r\n              const key = findProp(c, 'key')\r\n              if (key) {\r\n                context.onError(\r\n                  createCompilerError(\r\n                    ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT,\r\n                    key.loc\r\n                  )\r\n                )\r\n                return true\r\n              }\r\n            }\r\n          })\r\n        }\r\n\r\n        const needFragmentWrapper =\r\n          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT\r\n        const slotOutlet = isSlotOutlet(node)\r\n          ? node\r\n          : isTemplate &&\r\n              node.children.length === 1 &&\r\n              isSlotOutlet(node.children[0])\r\n            ? (node.children[0] as SlotOutletNode) // api-extractor somehow fails to infer this\r\n            : null\r\n\r\n        if (slotOutlet) {\r\n          // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n          childBlock = slotOutlet.codegenNode as RenderSlotCall\r\n          if (isTemplate && keyProperty) {\r\n            // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n            // we need to inject the key to the renderSlot() call.\r\n            // the props for renderSlot is passed as the 3rd argument.\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n        } else if (needFragmentWrapper) {\r\n          // <template v-for=\"...\"> with text or multi-elements\r\n          // should generate a fragment block for each loop\r\n          childBlock = createVNodeCall(\r\n            context,\r\n            helper(FRAGMENT),\r\n            keyProperty ? createObjectExpression([keyProperty]) : undefined,\r\n            node.children,\r\n            PatchFlags.STABLE_FRAGMENT +\r\n              (__DEV__\r\n                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`\r\n                : ``),\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            undefined,\r\n            false /* isComponent */\r\n          )\r\n        } else {\r\n          // Normal element v-for. Directly use the child's codegenNode\r\n          // but mark it as a block.\r\n          childBlock = (children[0] as PlainElementNode)\r\n            .codegenNode as VNodeCall\r\n          if (isTemplate && keyProperty) {\r\n            injectProp(childBlock, keyProperty, context)\r\n          }\r\n          if (childBlock.isBlock !== !isStableFragment) {\r\n            if (childBlock.isBlock) {\r\n              // switch from block to vnode\r\n              removeHelper(OPEN_BLOCK)\r\n              removeHelper(\r\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\r\n              )\r\n            } else {\r\n              // switch from vnode to block\r\n              removeHelper(\r\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\r\n              )\r\n            }\r\n          }\r\n          childBlock.isBlock = !isStableFragment\r\n          if (childBlock.isBlock) {\r\n            helper(OPEN_BLOCK)\r\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))\r\n          } else {\r\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))\r\n          }\r\n        }\r\n\r\n        if (memo) {\r\n          const loop = createFunctionExpression(\r\n            createForLoopParams(forNode.parseResult, [\r\n              createSimpleExpression(`_cached`)\r\n            ])\r\n          )\r\n          loop.body = createBlockStatement([\r\n            createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),\r\n            createCompoundExpression([\r\n              `if (_cached`,\r\n              ...(keyExp ? [` && _cached.key === `, keyExp] : []),\r\n              ` && ${context.helperString(\r\n                IS_MEMO_SAME\r\n              )}(_cached, _memo)) return _cached`\r\n            ]),\r\n            createCompoundExpression([`const _item = `, childBlock as any]),\r\n            createSimpleExpression(`_item.memo = _memo`),\r\n            createSimpleExpression(`return _item`)\r\n          ])\r\n          renderExp.arguments.push(\r\n            loop as ForIteratorExpression,\r\n            createSimpleExpression(`_cache`),\r\n            createSimpleExpression(String(context.cached++))\r\n          )\r\n        } else {\r\n          renderExp.arguments.push(\r\n            createFunctionExpression(\r\n              createForLoopParams(forNode.parseResult),\r\n              childBlock,\r\n              true /* force newline */\r\n            ) as ForIteratorExpression\r\n          )\r\n        }\r\n      }\r\n    })\r\n  }\r\n)\r\n\r\n// target-agnostic transform used for both Client and SSR\r\nexport function processFor(\r\n  node: ElementNode,\r\n  dir: DirectiveNode,\r\n  context: TransformContext,\r\n  processCodegen?: (forNode: ForNode) => (() => void) | undefined\r\n) {\r\n  if (!dir.exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\r\n    )\r\n    return\r\n  }\r\n\r\n  const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp as SimpleExpressionNode,\r\n    context\r\n  )\r\n\r\n  if (!parseResult) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\r\n    )\r\n    return\r\n  }\r\n\r\n  const { addIdentifiers, removeIdentifiers, scopes } = context\r\n  const { source, value, key, index } = parseResult\r\n\r\n  const forNode: ForNode = {\r\n    type: NodeTypes.FOR,\r\n    loc: dir.loc,\r\n    source,\r\n    valueAlias: value,\r\n    keyAlias: key,\r\n    objectIndexAlias: index,\r\n    parseResult,\r\n    children: isTemplateNode(node) ? node.children : [node]\r\n  }\r\n\r\n  context.replaceNode(forNode)\r\n\r\n  // bookkeeping\r\n  scopes.vFor++\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    // scope management\r\n    // inject identifiers to context\r\n    value && addIdentifiers(value)\r\n    key && addIdentifiers(key)\r\n    index && addIdentifiers(index)\r\n  }\r\n\r\n  const onExit = processCodegen && processCodegen(forNode)\r\n\r\n  return () => {\r\n    scopes.vFor--\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      value && removeIdentifiers(value)\r\n      key && removeIdentifiers(key)\r\n      index && removeIdentifiers(index)\r\n    }\r\n    if (onExit) onExit()\r\n  }\r\n}\r\n\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\r\nconst stripParensRE = /^\\(|\\)$/g\r\n\r\nexport interface ForParseResult {\r\n  source: ExpressionNode\r\n  value: ExpressionNode | undefined\r\n  key: ExpressionNode | undefined\r\n  index: ExpressionNode | undefined\r\n}\r\n\r\nexport function parseForExpression(\r\n  input: SimpleExpressionNode,\r\n  context: TransformContext\r\n): ForParseResult | undefined {\r\n  const loc = input.loc\r\n  const exp = input.content\r\n  const inMatch = exp.match(forAliasRE)\r\n  if (!inMatch) return\r\n\r\n  const [, LHS, RHS] = inMatch\r\n\r\n  const result: ForParseResult = {\r\n    source: createAliasExpression(\r\n      loc,\r\n      RHS.trim(),\r\n      exp.indexOf(RHS, LHS.length)\r\n    ),\r\n    value: undefined,\r\n    key: undefined,\r\n    index: undefined\r\n  }\r\n  if (!__BROWSER__ && context.prefixIdentifiers) {\r\n    result.source = processExpression(\r\n      result.source as SimpleExpressionNode,\r\n      context\r\n    )\r\n  }\r\n  if (__DEV__ && __BROWSER__) {\r\n    validateBrowserExpression(result.source as SimpleExpressionNode, context)\r\n  }\r\n\r\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim()\r\n  const trimmedOffset = LHS.indexOf(valueContent)\r\n\r\n  const iteratorMatch = valueContent.match(forIteratorRE)\r\n  if (iteratorMatch) {\r\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\r\n\r\n    const keyContent = iteratorMatch[1].trim()\r\n    let keyOffset: number | undefined\r\n    if (keyContent) {\r\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\r\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\r\n      if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        result.key = processExpression(result.key, context, true)\r\n      }\r\n      if (__DEV__ && __BROWSER__) {\r\n        validateBrowserExpression(\r\n          result.key as SimpleExpressionNode,\r\n          context,\r\n          true\r\n        )\r\n      }\r\n    }\r\n\r\n    if (iteratorMatch[2]) {\r\n      const indexContent = iteratorMatch[2].trim()\r\n\r\n      if (indexContent) {\r\n        result.index = createAliasExpression(\r\n          loc,\r\n          indexContent,\r\n          exp.indexOf(\r\n            indexContent,\r\n            result.key\r\n              ? keyOffset! + keyContent.length\r\n              : trimmedOffset + valueContent.length\r\n          )\r\n        )\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n          result.index = processExpression(result.index, context, true)\r\n        }\r\n        if (__DEV__ && __BROWSER__) {\r\n          validateBrowserExpression(\r\n            result.index as SimpleExpressionNode,\r\n            context,\r\n            true\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (valueContent) {\r\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      result.value = processExpression(result.value, context, true)\r\n    }\r\n    if (__DEV__ && __BROWSER__) {\r\n      validateBrowserExpression(\r\n        result.value as SimpleExpressionNode,\r\n        context,\r\n        true\r\n      )\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nfunction createAliasExpression(\r\n  range: SourceLocation,\r\n  content: string,\r\n  offset: number\r\n): SimpleExpressionNode {\r\n  return createSimpleExpression(\r\n    content,\r\n    false,\r\n    getInnerRange(range, offset, content.length)\r\n  )\r\n}\r\n\r\nexport function createForLoopParams(\r\n  { value, key, index }: ForParseResult,\r\n  memoArgs: ExpressionNode[] = []\r\n): ExpressionNode[] {\r\n  return createParamsList([value, key, index, ...memoArgs])\r\n}\r\n\r\nfunction createParamsList(\r\n  args: (ExpressionNode | undefined)[]\r\n): ExpressionNode[] {\r\n  let i = args.length\r\n  while (i--) {\r\n    if (args[i]) break\r\n  }\r\n  return args\r\n    .slice(0, i + 1)\r\n    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))\r\n}\r\n", "import {\r\n  ElementNode,\r\n  ObjectExpression,\r\n  createObjectExpression,\r\n  NodeTypes,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createFunctionExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  Property,\r\n  TemplateChildNode,\r\n  SourceLocation,\r\n  createConditionalExpression,\r\n  ConditionalExpression,\r\n  SimpleExpressionNode,\r\n  FunctionExpression,\r\n  CallExpression,\r\n  createCallExpression,\r\n  createArrayExpression,\r\n  SlotsExpression\r\n} from '../ast'\r\nimport { TransformContext, NodeTransform } from '../transform'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  findDir,\r\n  isTemplateNode,\r\n  assert,\r\n  isVSlot,\r\n  hasScopeRef,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers'\r\nimport { parseForExpression, createForLoopParams } from './vFor'\r\nimport { SlotFlags, slotFlagsText } from '@vue/shared'\r\n\r\nconst defaultFallback = createSimpleExpression(`undefined`, false)\r\n\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nexport const trackSlotScopes: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    (node.tagType === ElementTypes.COMPONENT ||\r\n      node.tagType === ElementTypes.TEMPLATE)\r\n  ) {\r\n    // We are only checking non-empty v-slot here\r\n    // since we only care about slots that introduce scope variables.\r\n    const vSlot = findDir(node, 'slot')\r\n    if (vSlot) {\r\n      const slotProps = vSlot.exp\r\n      if (!__BROWSER__ && context.prefixIdentifiers) {\r\n        slotProps && context.addIdentifiers(slotProps)\r\n      }\r\n      context.scopes.vSlot++\r\n      return () => {\r\n        if (!__BROWSER__ && context.prefixIdentifiers) {\r\n          slotProps && context.removeIdentifiers(slotProps)\r\n        }\r\n        context.scopes.vSlot--\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\r\n  let vFor\r\n  if (\r\n    isTemplateNode(node) &&\r\n    node.props.some(isVSlot) &&\r\n    (vFor = findDir(node, 'for'))\r\n  ) {\r\n    const result = (vFor.parseResult = parseForExpression(\r\n      vFor.exp as SimpleExpressionNode,\r\n      context\r\n    ))\r\n    if (result) {\r\n      const { value, key, index } = result\r\n      const { addIdentifiers, removeIdentifiers } = context\r\n      value && addIdentifiers(value)\r\n      key && addIdentifiers(key)\r\n      index && addIdentifiers(index)\r\n\r\n      return () => {\r\n        value && removeIdentifiers(value)\r\n        key && removeIdentifiers(key)\r\n        index && removeIdentifiers(index)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport type SlotFnBuilder = (\r\n  slotProps: ExpressionNode | undefined,\r\n  vForExp: ExpressionNode | undefined,\r\n  slotChildren: TemplateChildNode[],\r\n  loc: SourceLocation\r\n) => FunctionExpression\r\n\r\nconst buildClientSlotFn: SlotFnBuilder = (props, _vForExp, children, loc) =>\r\n  createFunctionExpression(\r\n    props,\r\n    children,\r\n    false /* newline */,\r\n    true /* isSlot */,\r\n    children.length ? children[0].loc : loc\r\n  )\r\n\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nexport function buildSlots(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  buildSlotFn: SlotFnBuilder = buildClientSlotFn\r\n): {\r\n  slots: SlotsExpression\r\n  hasDynamicSlots: boolean\r\n} {\r\n  context.helper(WITH_CTX)\r\n\r\n  const { children, loc } = node\r\n  const slotsProperties: Property[] = []\r\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\r\n\r\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n  // since it likely uses a scope variable.\r\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\r\n  // with `prefixIdentifiers: true`, this can be further optimized to make\r\n  // it dynamic only when the slot actually uses the scope variables.\r\n  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\r\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\r\n  }\r\n\r\n  // 1. Check for slot with slotProps on component itself.\r\n  //    <Comp v-slot=\"{ prop }\"/>\r\n  const onComponentSlot = findDir(node, 'slot', true)\r\n  if (onComponentSlot) {\r\n    const { arg, exp } = onComponentSlot\r\n    if (arg && !isStaticExp(arg)) {\r\n      hasDynamicSlots = true\r\n    }\r\n    slotsProperties.push(\r\n      createObjectProperty(\r\n        arg || createSimpleExpression('default', true),\r\n        buildSlotFn(exp, undefined, children, loc)\r\n      )\r\n    )\r\n  }\r\n\r\n  // 2. Iterate through children and check for template slots\r\n  //    <template v-slot:foo=\"{ prop }\">\r\n  let hasTemplateSlots = false\r\n  let hasNamedDefaultSlot = false\r\n  const implicitDefaultChildren: TemplateChildNode[] = []\r\n  const seenSlotNames = new Set<string>()\r\n  let conditionalBranchIndex = 0\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const slotElement = children[i]\r\n    let slotDir\r\n\r\n    if (\r\n      !isTemplateNode(slotElement) ||\r\n      !(slotDir = findDir(slotElement, 'slot', true))\r\n    ) {\r\n      // not a <template v-slot>, skip.\r\n      if (slotElement.type !== NodeTypes.COMMENT) {\r\n        implicitDefaultChildren.push(slotElement)\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (onComponentSlot) {\r\n      // already has on-component slot - this is incorrect usage.\r\n      context.onError(\r\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\r\n      )\r\n      break\r\n    }\r\n\r\n    hasTemplateSlots = true\r\n    const { children: slotChildren, loc: slotLoc } = slotElement\r\n    const {\r\n      arg: slotName = createSimpleExpression(`default`, true),\r\n      exp: slotProps,\r\n      loc: dirLoc\r\n    } = slotDir\r\n\r\n    // check if name is dynamic.\r\n    let staticSlotName: string | undefined\r\n    if (isStaticExp(slotName)) {\r\n      staticSlotName = slotName ? slotName.content : `default`\r\n    } else {\r\n      hasDynamicSlots = true\r\n    }\r\n\r\n    const vFor = findDir(slotElement, 'for')\r\n    const slotFunction = buildSlotFn(\r\n      slotProps,\r\n      vFor?.exp,\r\n      slotChildren,\r\n      slotLoc\r\n    )\r\n\r\n    // check if this slot is conditional (v-if/v-for)\r\n    let vIf: DirectiveNode | undefined\r\n    let vElse: DirectiveNode | undefined\r\n    if ((vIf = findDir(slotElement, 'if'))) {\r\n      hasDynamicSlots = true\r\n      dynamicSlots.push(\r\n        createConditionalExpression(\r\n          vIf.exp!,\r\n          buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++),\r\n          defaultFallback\r\n        )\r\n      )\r\n    } else if (\r\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\r\n    ) {\r\n      // find adjacent v-if\r\n      let j = i\r\n      let prev\r\n      while (j--) {\r\n        prev = children[j]\r\n        if (prev.type !== NodeTypes.COMMENT) {\r\n          break\r\n        }\r\n      }\r\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n        // remove node\r\n        children.splice(i, 1)\r\n        i--\r\n        __TEST__ && assert(dynamicSlots.length > 0)\r\n        // attach this slot to previous conditional\r\n        let conditional = dynamicSlots[\r\n          dynamicSlots.length - 1\r\n        ] as ConditionalExpression\r\n        while (\r\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\r\n        ) {\r\n          conditional = conditional.alternate\r\n        }\r\n        conditional.alternate = vElse.exp\r\n          ? createConditionalExpression(\r\n              vElse.exp,\r\n              buildDynamicSlot(\r\n                slotName,\r\n                slotFunction,\r\n                conditionalBranchIndex++\r\n              ),\r\n              defaultFallback\r\n            )\r\n          : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++)\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\r\n        )\r\n      }\r\n    } else if (vFor) {\r\n      hasDynamicSlots = true\r\n      const parseResult =\r\n        vFor.parseResult ||\r\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\r\n      if (parseResult) {\r\n        // Render the dynamic slots as an array and add it to the createSlot()\r\n        // args. The runtime knows how to handle it appropriately.\r\n        dynamicSlots.push(\r\n          createCallExpression(context.helper(RENDER_LIST), [\r\n            parseResult.source,\r\n            createFunctionExpression(\r\n              createForLoopParams(parseResult),\r\n              buildDynamicSlot(slotName, slotFunction),\r\n              true /* force newline */\r\n            )\r\n          ])\r\n        )\r\n      } else {\r\n        context.onError(\r\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\r\n        )\r\n      }\r\n    } else {\r\n      // check duplicate static names\r\n      if (staticSlotName) {\r\n        if (seenSlotNames.has(staticSlotName)) {\r\n          context.onError(\r\n            createCompilerError(\r\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\r\n              dirLoc\r\n            )\r\n          )\r\n          continue\r\n        }\r\n        seenSlotNames.add(staticSlotName)\r\n        if (staticSlotName === 'default') {\r\n          hasNamedDefaultSlot = true\r\n        }\r\n      }\r\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\r\n    }\r\n  }\r\n\r\n  if (!onComponentSlot) {\r\n    const buildDefaultSlotProperty = (\r\n      props: ExpressionNode | undefined,\r\n      children: TemplateChildNode[]\r\n    ) => {\r\n      const fn = buildSlotFn(props, undefined, children, loc)\r\n      if (__COMPAT__ && context.compatConfig) {\r\n        fn.isNonScopedSlot = true\r\n      }\r\n      return createObjectProperty(`default`, fn)\r\n    }\r\n\r\n    if (!hasTemplateSlots) {\r\n      // implicit default slot (on component)\r\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children))\r\n    } else if (\r\n      implicitDefaultChildren.length &&\r\n      // #3766\r\n      // with whitespace: 'preserve', whitespaces between slots will end up in\r\n      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\r\n      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))\r\n    ) {\r\n      // implicit default slot (mixed with named slots)\r\n      if (hasNamedDefaultSlot) {\r\n        context.onError(\r\n          createCompilerError(\r\n            ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\r\n            implicitDefaultChildren[0].loc\r\n          )\r\n        )\r\n      } else {\r\n        slotsProperties.push(\r\n          buildDefaultSlotProperty(undefined, implicitDefaultChildren)\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  const slotFlag = hasDynamicSlots\r\n    ? SlotFlags.DYNAMIC\r\n    : hasForwardedSlots(node.children)\r\n      ? SlotFlags.FORWARDED\r\n      : SlotFlags.STABLE\r\n\r\n  let slots = createObjectExpression(\r\n    slotsProperties.concat(\r\n      createObjectProperty(\r\n        `_`,\r\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n        // 1 = compiled and static = can skip normalization AND diff as optimized\r\n        createSimpleExpression(\r\n          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\r\n          false\r\n        )\r\n      )\r\n    ),\r\n    loc\r\n  ) as SlotsExpression\r\n  if (dynamicSlots.length) {\r\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n      slots,\r\n      createArrayExpression(dynamicSlots)\r\n    ]) as SlotsExpression\r\n  }\r\n\r\n  return {\r\n    slots,\r\n    hasDynamicSlots\r\n  }\r\n}\r\n\r\nfunction buildDynamicSlot(\r\n  name: ExpressionNode,\r\n  fn: FunctionExpression,\r\n  index?: number\r\n): ObjectExpression {\r\n  const props = [\r\n    createObjectProperty(`name`, name),\r\n    createObjectProperty(`fn`, fn)\r\n  ]\r\n  if (index != null) {\r\n    props.push(\r\n      createObjectProperty(`key`, createSimpleExpression(String(index), true))\r\n    )\r\n  }\r\n  return createObjectExpression(props)\r\n}\r\n\r\nfunction hasForwardedSlots(children: TemplateChildNode[]): boolean {\r\n  for (let i = 0; i < children.length; i++) {\r\n    const child = children[i]\r\n    switch (child.type) {\r\n      case NodeTypes.ELEMENT:\r\n        if (\r\n          child.tagType === ElementTypes.SLOT ||\r\n          hasForwardedSlots(child.children)\r\n        ) {\r\n          return true\r\n        }\r\n        break\r\n      case NodeTypes.IF:\r\n        if (hasForwardedSlots(child.branches)) return true\r\n        break\r\n      case NodeTypes.IF_BRANCH:\r\n      case NodeTypes.FOR:\r\n        if (hasForwardedSlots(child.children)) return true\r\n        break\r\n      default:\r\n        break\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\nfunction isNonWhitespaceContent(node: TemplateChildNode): boolean {\r\n  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)\r\n    return true\r\n  return node.type === NodeTypes.TEXT\r\n    ? !!node.content.trim()\r\n    : isNonWhitespaceContent(node.content)\r\n}\r\n", "import { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  ElementTypes,\r\n  CallExpression,\r\n  ObjectExpression,\r\n  ElementNode,\r\n  DirectiveNode,\r\n  ExpressionNode,\r\n  ArrayExpression,\r\n  createCallExpression,\r\n  createArrayExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createObjectExpression,\r\n  Property,\r\n  ComponentNode,\r\n  VNodeCall,\r\n  TemplateTextChildNode,\r\n  DirectiveArguments,\r\n  createVNodeCall,\r\n  ConstantTypes,\r\n  JSChildNode\r\n} from '../ast'\r\nimport {\r\n  PatchFlags,\r\n  PatchFlagNames,\r\n  isSymbol,\r\n  isOn,\r\n  isObject,\r\n  isReservedProp,\r\n  capitalize,\r\n  camelize,\r\n  isBuiltInDirective\r\n} from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  RESOLVE_DIRECTIVE,\r\n  RESOLVE_COMPONENT,\r\n  RESOLVE_DYNAMIC_COMPONENT,\r\n  MERGE_PROPS,\r\n  NORMALIZE_CLASS,\r\n  NORMALIZE_STYLE,\r\n  NORMALIZE_PROPS,\r\n  TO_HANDLERS,\r\n  TELEPORT,\r\n  KEEP_ALIVE,\r\n  SUSPENSE,\r\n  UNREF,\r\n  GUARD_REACTIVE_PROPS\r\n} from '../runtimeHelpers'\r\nimport {\r\n  getInnerRange,\r\n  toValidAssetId,\r\n  findProp,\r\n  isCoreComponent,\r\n  isStaticArgOf,\r\n  findDir,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { buildSlots } from './vSlot'\r\nimport { getConstantType } from './hoistStatic'\r\nimport { BindingTypes } from '../options'\r\nimport {\r\n  checkCompatEnabled,\r\n  CompilerDeprecationTypes,\r\n  isCompatEnabled\r\n} from '../compat/compatConfig'\r\n\r\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\r\n\r\n// generate a JavaScript AST for this element's codegen\r\nexport const transformElement: NodeTransform = (node, context) => {\r\n  // perform the work on exit, after all child expressions have been\r\n  // processed and merged.\r\n  return function postTransformElement() {\r\n    node = context.currentNode!\r\n\r\n    if (\r\n      !(\r\n        node.type === NodeTypes.ELEMENT &&\r\n        (node.tagType === ElementTypes.ELEMENT ||\r\n          node.tagType === ElementTypes.COMPONENT)\r\n      )\r\n    ) {\r\n      return\r\n    }\r\n\r\n    const { tag, props } = node\r\n    const isComponent = node.tagType === ElementTypes.COMPONENT\r\n\r\n    // The goal of the transform is to create a codegenNode implementing the\r\n    // VNodeCall interface.\r\n    let vnodeTag = isComponent\r\n      ? resolveComponentType(node as ComponentNode, context)\r\n      : `\"${tag}\"`\r\n\r\n    const isDynamicComponent =\r\n      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT\r\n\r\n    let vnodeProps: VNodeCall['props']\r\n    let vnodeChildren: VNodeCall['children']\r\n    let vnodePatchFlag: VNodeCall['patchFlag']\r\n    let patchFlag: number = 0\r\n    let vnodeDynamicProps: VNodeCall['dynamicProps']\r\n    let dynamicPropNames: string[] | undefined\r\n    let vnodeDirectives: VNodeCall['directives']\r\n\r\n    let shouldUseBlock =\r\n      // dynamic component may resolve to plain elements\r\n      isDynamicComponent ||\r\n      vnodeTag === TELEPORT ||\r\n      vnodeTag === SUSPENSE ||\r\n      (!isComponent &&\r\n        // <svg> and <foreignObject> must be forced into blocks so that block\r\n        // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n        // This is technically web-specific, but splitting the logic out of core\r\n        // leads to too much unnecessary complexity.\r\n        (tag === 'svg' || tag === 'foreignObject'))\r\n\r\n    // props\r\n    if (props.length > 0) {\r\n      const propsBuildResult = buildProps(\r\n        node,\r\n        context,\r\n        undefined,\r\n        isComponent,\r\n        isDynamicComponent\r\n      )\r\n      vnodeProps = propsBuildResult.props\r\n      patchFlag = propsBuildResult.patchFlag\r\n      dynamicPropNames = propsBuildResult.dynamicPropNames\r\n      const directives = propsBuildResult.directives\r\n      vnodeDirectives =\r\n        directives && directives.length\r\n          ? (createArrayExpression(\r\n              directives.map(dir => buildDirectiveArgs(dir, context))\r\n            ) as DirectiveArguments)\r\n          : undefined\r\n\r\n      if (propsBuildResult.shouldUseBlock) {\r\n        shouldUseBlock = true\r\n      }\r\n    }\r\n\r\n    // children\r\n    if (node.children.length > 0) {\r\n      if (vnodeTag === KEEP_ALIVE) {\r\n        // Although a built-in component, we compile KeepAlive with raw children\r\n        // instead of slot functions so that it can be used inside Transition\r\n        // or other Transition-wrapping HOCs.\r\n        // To ensure correct updates with block optimizations, we need to:\r\n        // 1. Force keep-alive into a block. This avoids its children being\r\n        //    collected by a parent block.\r\n        shouldUseBlock = true\r\n        // 2. Force keep-alive to always be updated, since it uses raw children.\r\n        patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        if (__DEV__ && node.children.length > 1) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN, {\r\n              start: node.children[0].loc.start,\r\n              end: node.children[node.children.length - 1].loc.end,\r\n              source: ''\r\n            })\r\n          )\r\n        }\r\n      }\r\n\r\n      const shouldBuildAsSlots =\r\n        isComponent &&\r\n        // Teleport is not a real component and has dedicated runtime handling\r\n        vnodeTag !== TELEPORT &&\r\n        // explained above.\r\n        vnodeTag !== KEEP_ALIVE\r\n\r\n      if (shouldBuildAsSlots) {\r\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\r\n        vnodeChildren = slots\r\n        if (hasDynamicSlots) {\r\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\r\n        }\r\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n        const child = node.children[0]\r\n        const type = child.type\r\n        // check for dynamic text children\r\n        const hasDynamicTextChild =\r\n          type === NodeTypes.INTERPOLATION ||\r\n          type === NodeTypes.COMPOUND_EXPRESSION\r\n        if (\r\n          hasDynamicTextChild &&\r\n          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n        ) {\r\n          patchFlag |= PatchFlags.TEXT\r\n        }\r\n        // pass directly if the only child is a text node\r\n        // (plain / interpolation / expression)\r\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\r\n          vnodeChildren = child as TemplateTextChildNode\r\n        } else {\r\n          vnodeChildren = node.children\r\n        }\r\n      } else {\r\n        vnodeChildren = node.children\r\n      }\r\n    }\r\n\r\n    // patchFlag & dynamicPropNames\r\n    if (patchFlag !== 0) {\r\n      if (__DEV__) {\r\n        if (patchFlag < 0) {\r\n          // special flags (negative and mutually exclusive)\r\n          vnodePatchFlag =\r\n            patchFlag + ` /* ${PatchFlagNames[patchFlag as PatchFlags]} */`\r\n        } else {\r\n          // bitwise flags\r\n          const flagNames = Object.keys(PatchFlagNames)\r\n            .map(Number)\r\n            .filter(n => n > 0 && patchFlag & n)\r\n            .map(n => PatchFlagNames[n as PatchFlags])\r\n            .join(`, `)\r\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`\r\n        }\r\n      } else {\r\n        vnodePatchFlag = String(patchFlag)\r\n      }\r\n      if (dynamicPropNames && dynamicPropNames.length) {\r\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)\r\n      }\r\n    }\r\n\r\n    node.codegenNode = createVNodeCall(\r\n      context,\r\n      vnodeTag,\r\n      vnodeProps,\r\n      vnodeChildren,\r\n      vnodePatchFlag,\r\n      vnodeDynamicProps,\r\n      vnodeDirectives,\r\n      !!shouldUseBlock,\r\n      false /* disableTracking */,\r\n      isComponent,\r\n      node.loc\r\n    )\r\n  }\r\n}\r\n\r\nexport function resolveComponentType(\r\n  node: ComponentNode,\r\n  context: TransformContext,\r\n  ssr = false\r\n) {\r\n  let { tag } = node\r\n\r\n  // 1. dynamic component\r\n  const isExplicitDynamic = isComponentTag(tag)\r\n  const isProp = findProp(node, 'is')\r\n  if (isProp) {\r\n    if (\r\n      isExplicitDynamic ||\r\n      (__COMPAT__ &&\r\n        isCompatEnabled(\r\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n          context\r\n        ))\r\n    ) {\r\n      const exp =\r\n        isProp.type === NodeTypes.ATTRIBUTE\r\n          ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n          : isProp.exp\r\n      if (exp) {\r\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n          exp\r\n        ])\r\n      }\r\n    } else if (\r\n      isProp.type === NodeTypes.ATTRIBUTE &&\r\n      isProp.value!.content.startsWith('vue:')\r\n    ) {\r\n      // <button is=\"vue:xxx\">\r\n      // if not <component>, only is value that starts with \"vue:\" will be\r\n      // treated as component by the parse phase and reach here, unless it's\r\n      // compat mode where all is values are considered components\r\n      tag = isProp.value!.content.slice(4)\r\n    }\r\n  }\r\n\r\n  // 1.5 v-is (TODO: remove in 3.4)\r\n  const isDir = !isExplicitDynamic && findDir(node, 'is')\r\n  if (isDir && isDir.exp) {\r\n    if (__DEV__) {\r\n      context.onWarn(\r\n        createCompilerError(ErrorCodes.DEPRECATION_V_IS, isDir.loc)\r\n      )\r\n    }\r\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n      isDir.exp\r\n    ])\r\n  }\r\n\r\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)\r\n  if (builtIn) {\r\n    // built-ins are simply fallthroughs / have special handling during ssr\r\n    // so we don't need to import their runtime equivalents\r\n    if (!ssr) context.helper(builtIn)\r\n    return builtIn\r\n  }\r\n\r\n  // 3. user component (from setup bindings)\r\n  // this is skipped in browser build since browser builds do not perform\r\n  // binding analysis.\r\n  if (!__BROWSER__) {\r\n    const fromSetup = resolveSetupReference(tag, context)\r\n    if (fromSetup) {\r\n      return fromSetup\r\n    }\r\n    const dotIndex = tag.indexOf('.')\r\n    if (dotIndex > 0) {\r\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)\r\n      if (ns) {\r\n        return ns + tag.slice(dotIndex)\r\n      }\r\n    }\r\n  }\r\n\r\n  // 4. Self referencing component (inferred from filename)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.selfName &&\r\n    capitalize(camelize(tag)) === context.selfName\r\n  ) {\r\n    context.helper(RESOLVE_COMPONENT)\r\n    // codegen.ts has special check for __self postfix when generating\r\n    // component imports, which will pass additional `maybeSelfReference` flag\r\n    // to `resolveComponent`.\r\n    context.components.add(tag + `__self`)\r\n    return toValidAssetId(tag, `component`)\r\n  }\r\n\r\n  // 5. user component (resolve)\r\n  context.helper(RESOLVE_COMPONENT)\r\n  context.components.add(tag)\r\n  return toValidAssetId(tag, `component`)\r\n}\r\n\r\nfunction resolveSetupReference(name: string, context: TransformContext) {\r\n  const bindings = context.bindingMetadata\r\n  if (!bindings || bindings.__isScriptSetup === false) {\r\n    return\r\n  }\r\n\r\n  const camelName = camelize(name)\r\n  const PascalName = capitalize(camelName)\r\n  const checkType = (type: BindingTypes) => {\r\n    if (bindings[name] === type) {\r\n      return name\r\n    }\r\n    if (bindings[camelName] === type) {\r\n      return camelName\r\n    }\r\n    if (bindings[PascalName] === type) {\r\n      return PascalName\r\n    }\r\n  }\r\n\r\n  const fromConst =\r\n    checkType(BindingTypes.SETUP_CONST) ||\r\n    checkType(BindingTypes.SETUP_REACTIVE_CONST) ||\r\n    checkType(BindingTypes.LITERAL_CONST)\r\n  if (fromConst) {\r\n    return context.inline\r\n      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\r\n        fromConst\r\n      : `$setup[${JSON.stringify(fromConst)}]`\r\n  }\r\n\r\n  const fromMaybeRef =\r\n    checkType(BindingTypes.SETUP_LET) ||\r\n    checkType(BindingTypes.SETUP_REF) ||\r\n    checkType(BindingTypes.SETUP_MAYBE_REF)\r\n  if (fromMaybeRef) {\r\n    return context.inline\r\n      ? // setup scope bindings that may be refs need to be unrefed\r\n        `${context.helperString(UNREF)}(${fromMaybeRef})`\r\n      : `$setup[${JSON.stringify(fromMaybeRef)}]`\r\n  }\r\n\r\n  const fromProps = checkType(BindingTypes.PROPS)\r\n  if (fromProps) {\r\n    return `${context.helperString(UNREF)}(${\r\n      context.inline ? '__props' : '$props'\r\n    }[${JSON.stringify(fromProps)}])`\r\n  }\r\n}\r\n\r\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\r\n\r\nexport function buildProps(\r\n  node: ElementNode,\r\n  context: TransformContext,\r\n  props: ElementNode['props'] = node.props,\r\n  isComponent: boolean,\r\n  isDynamicComponent: boolean,\r\n  ssr = false\r\n): {\r\n  props: PropsExpression | undefined\r\n  directives: DirectiveNode[]\r\n  patchFlag: number\r\n  dynamicPropNames: string[]\r\n  shouldUseBlock: boolean\r\n} {\r\n  const { tag, loc: elementLoc, children } = node\r\n  let properties: ObjectExpression['properties'] = []\r\n  const mergeArgs: PropsExpression[] = []\r\n  const runtimeDirectives: DirectiveNode[] = []\r\n  const hasChildren = children.length > 0\r\n  let shouldUseBlock = false\r\n\r\n  // patchFlag analysis\r\n  let patchFlag = 0\r\n  let hasRef = false\r\n  let hasClassBinding = false\r\n  let hasStyleBinding = false\r\n  let hasHydrationEventBinding = false\r\n  let hasDynamicKeys = false\r\n  let hasVnodeHook = false\r\n  const dynamicPropNames: string[] = []\r\n\r\n  const pushMergeArg = (arg?: PropsExpression) => {\r\n    if (properties.length) {\r\n      mergeArgs.push(\r\n        createObjectExpression(dedupeProperties(properties), elementLoc)\r\n      )\r\n      properties = []\r\n    }\r\n    if (arg) mergeArgs.push(arg)\r\n  }\r\n\r\n  const analyzePatchFlag = ({ key, value }: Property) => {\r\n    if (isStaticExp(key)) {\r\n      const name = key.content\r\n      const isEventHandler = isOn(name)\r\n      if (\r\n        isEventHandler &&\r\n        (!isComponent || isDynamicComponent) &&\r\n        // omit the flag for click handlers because hydration gives click\r\n        // dedicated fast path.\r\n        name.toLowerCase() !== 'onclick' &&\r\n        // omit v-model handlers\r\n        name !== 'onUpdate:modelValue' &&\r\n        // omit onVnodeXXX hooks\r\n        !isReservedProp(name)\r\n      ) {\r\n        hasHydrationEventBinding = true\r\n      }\r\n\r\n      if (isEventHandler && isReservedProp(name)) {\r\n        hasVnodeHook = true\r\n      }\r\n\r\n      if (isEventHandler && value.type === NodeTypes.JS_CALL_EXPRESSION) {\r\n        // handler wrapped with internal helper e.g. withModifiers(fn)\r\n        // extract the actual expression\r\n        value = value.arguments[0] as JSChildNode\r\n      }\r\n\r\n      if (\r\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\r\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\r\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\r\n          getConstantType(value, context) > 0)\r\n      ) {\r\n        // skip if the prop is a cached handler or has constant value\r\n        return\r\n      }\r\n\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n      } else if (name === 'class') {\r\n        hasClassBinding = true\r\n      } else if (name === 'style') {\r\n        hasStyleBinding = true\r\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n\r\n      // treat the dynamic class and style binding of the component as dynamic props\r\n      if (\r\n        isComponent &&\r\n        (name === 'class' || name === 'style') &&\r\n        !dynamicPropNames.includes(name)\r\n      ) {\r\n        dynamicPropNames.push(name)\r\n      }\r\n    } else {\r\n      hasDynamicKeys = true\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < props.length; i++) {\r\n    // static attribute\r\n    const prop = props[i]\r\n    if (prop.type === NodeTypes.ATTRIBUTE) {\r\n      const { loc, name, value } = prop\r\n      let isStatic = true\r\n      if (name === 'ref') {\r\n        hasRef = true\r\n        if (context.scopes.vFor > 0) {\r\n          properties.push(\r\n            createObjectProperty(\r\n              createSimpleExpression('ref_for', true),\r\n              createSimpleExpression('true')\r\n            )\r\n          )\r\n        }\r\n        // in inline mode there is no setupState object, so we can't use string\r\n        // keys to set the ref. Instead, we need to transform it to pass the\r\n        // actual ref instead.\r\n        if (!__BROWSER__ && value && context.inline) {\r\n          const binding = context.bindingMetadata[value.content]\r\n          if (\r\n            binding === BindingTypes.SETUP_LET ||\r\n            binding === BindingTypes.SETUP_REF ||\r\n            binding === BindingTypes.SETUP_MAYBE_REF\r\n          ) {\r\n            isStatic = false\r\n            properties.push(\r\n              createObjectProperty(\r\n                createSimpleExpression('ref_key', true),\r\n                createSimpleExpression(value.content, true, value.loc)\r\n              )\r\n            )\r\n          }\r\n        }\r\n      }\r\n      // skip is on <component>, or is=\"vue:xxx\"\r\n      if (\r\n        name === 'is' &&\r\n        (isComponentTag(tag) ||\r\n          (value && value.content.startsWith('vue:')) ||\r\n          (__COMPAT__ &&\r\n            isCompatEnabled(\r\n              CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n              context\r\n            )))\r\n      ) {\r\n        continue\r\n      }\r\n      properties.push(\r\n        createObjectProperty(\r\n          createSimpleExpression(\r\n            name,\r\n            true,\r\n            getInnerRange(loc, 0, name.length)\r\n          ),\r\n          createSimpleExpression(\r\n            value ? value.content : '',\r\n            isStatic,\r\n            value ? value.loc : loc\r\n          )\r\n        )\r\n      )\r\n    } else {\r\n      // directives\r\n      const { name, arg, exp, loc, modifiers } = prop\r\n      const isVBind = name === 'bind'\r\n      const isVOn = name === 'on'\r\n\r\n      // skip v-slot - it is handled by its dedicated transform.\r\n      if (name === 'slot') {\r\n        if (!isComponent) {\r\n          context.onError(\r\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\r\n          )\r\n        }\r\n        continue\r\n      }\r\n      // skip v-once/v-memo - they are handled by dedicated transforms.\r\n      if (name === 'once' || name === 'memo') {\r\n        continue\r\n      }\r\n      // skip v-is and :is on <component>\r\n      if (\r\n        name === 'is' ||\r\n        (isVBind &&\r\n          isStaticArgOf(arg, 'is') &&\r\n          (isComponentTag(tag) ||\r\n            (__COMPAT__ &&\r\n              isCompatEnabled(\r\n                CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\r\n                context\r\n              ))))\r\n      ) {\r\n        continue\r\n      }\r\n      // skip v-on in SSR compilation\r\n      if (isVOn && ssr) {\r\n        continue\r\n      }\r\n\r\n      if (\r\n        // #938: elements with dynamic keys should be forced into blocks\r\n        (isVBind && isStaticArgOf(arg, 'key')) ||\r\n        // inline before-update hooks need to force block so that it is invoked\r\n        // before children\r\n        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))\r\n      ) {\r\n        shouldUseBlock = true\r\n      }\r\n\r\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\r\n        properties.push(\r\n          createObjectProperty(\r\n            createSimpleExpression('ref_for', true),\r\n            createSimpleExpression('true')\r\n          )\r\n        )\r\n      }\r\n\r\n      // special case for v-bind and v-on with no argument\r\n      if (!arg && (isVBind || isVOn)) {\r\n        hasDynamicKeys = true\r\n        if (exp) {\r\n          if (isVBind) {\r\n            // have to merge early for compat build check\r\n            pushMergeArg()\r\n            if (__COMPAT__) {\r\n              // 2.x v-bind object order compat\r\n              if (__DEV__) {\r\n                const hasOverridableKeys = mergeArgs.some(arg => {\r\n                  if (arg.type === NodeTypes.JS_OBJECT_EXPRESSION) {\r\n                    return arg.properties.some(({ key }) => {\r\n                      if (\r\n                        key.type !== NodeTypes.SIMPLE_EXPRESSION ||\r\n                        !key.isStatic\r\n                      ) {\r\n                        return true\r\n                      }\r\n                      return (\r\n                        key.content !== 'class' &&\r\n                        key.content !== 'style' &&\r\n                        !isOn(key.content)\r\n                      )\r\n                    })\r\n                  } else {\r\n                    // dynamic expression\r\n                    return true\r\n                  }\r\n                })\r\n                if (hasOverridableKeys) {\r\n                  checkCompatEnabled(\r\n                    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                    context,\r\n                    loc\r\n                  )\r\n                }\r\n              }\r\n\r\n              if (\r\n                isCompatEnabled(\r\n                  CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\r\n                  context\r\n                )\r\n              ) {\r\n                mergeArgs.unshift(exp)\r\n                continue\r\n              }\r\n            }\r\n\r\n            mergeArgs.push(exp)\r\n          } else {\r\n            // v-on=\"obj\" -> toHandlers(obj)\r\n            pushMergeArg({\r\n              type: NodeTypes.JS_CALL_EXPRESSION,\r\n              loc,\r\n              callee: context.helper(TO_HANDLERS),\r\n              arguments: isComponent ? [exp] : [exp, `true`]\r\n            })\r\n          }\r\n        } else {\r\n          context.onError(\r\n            createCompilerError(\r\n              isVBind\r\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\r\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\r\n              loc\r\n            )\r\n          )\r\n        }\r\n        continue\r\n      }\r\n\r\n      // force hydration for v-bind with .prop modifier\r\n      if (isVBind && modifiers.includes('prop')) {\r\n        patchFlag |= PatchFlags.NEED_HYDRATION\r\n      }\r\n\r\n      const directiveTransform = context.directiveTransforms[name]\r\n      if (directiveTransform) {\r\n        // has built-in directive transform.\r\n        const { props, needRuntime } = directiveTransform(prop, node, context)\r\n        !ssr && props.forEach(analyzePatchFlag)\r\n        if (isVOn && arg && !isStaticExp(arg)) {\r\n          pushMergeArg(createObjectExpression(props, elementLoc))\r\n        } else {\r\n          properties.push(...props)\r\n        }\r\n        if (needRuntime) {\r\n          runtimeDirectives.push(prop)\r\n          if (isSymbol(needRuntime)) {\r\n            directiveImportMap.set(prop, needRuntime)\r\n          }\r\n        }\r\n      } else if (!isBuiltInDirective(name)) {\r\n        // no built-in transform, this is a user custom directive.\r\n        runtimeDirectives.push(prop)\r\n        // custom dirs may use beforeUpdate so they need to force blocks\r\n        // to ensure before-update gets called before children update\r\n        if (hasChildren) {\r\n          shouldUseBlock = true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let propsExpression: PropsExpression | undefined = undefined\r\n\r\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n  if (mergeArgs.length) {\r\n    // close up any not-yet-merged props\r\n    pushMergeArg()\r\n    if (mergeArgs.length > 1) {\r\n      propsExpression = createCallExpression(\r\n        context.helper(MERGE_PROPS),\r\n        mergeArgs,\r\n        elementLoc\r\n      )\r\n    } else {\r\n      // single v-bind with nothing else - no need for a mergeProps call\r\n      propsExpression = mergeArgs[0]\r\n    }\r\n  } else if (properties.length) {\r\n    propsExpression = createObjectExpression(\r\n      dedupeProperties(properties),\r\n      elementLoc\r\n    )\r\n  }\r\n\r\n  // patchFlag analysis\r\n  if (hasDynamicKeys) {\r\n    patchFlag |= PatchFlags.FULL_PROPS\r\n  } else {\r\n    if (hasClassBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.CLASS\r\n    }\r\n    if (hasStyleBinding && !isComponent) {\r\n      patchFlag |= PatchFlags.STYLE\r\n    }\r\n    if (dynamicPropNames.length) {\r\n      patchFlag |= PatchFlags.PROPS\r\n    }\r\n    if (hasHydrationEventBinding) {\r\n      patchFlag |= PatchFlags.NEED_HYDRATION\r\n    }\r\n  }\r\n  if (\r\n    !shouldUseBlock &&\r\n    (patchFlag === 0 || patchFlag === PatchFlags.NEED_HYDRATION) &&\r\n    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)\r\n  ) {\r\n    patchFlag |= PatchFlags.NEED_PATCH\r\n  }\r\n\r\n  // pre-normalize props, SSR is skipped for now\r\n  if (!context.inSSR && propsExpression) {\r\n    switch (propsExpression.type) {\r\n      case NodeTypes.JS_OBJECT_EXPRESSION:\r\n        // means that there is no v-bind,\r\n        // but still need to deal with dynamic key binding\r\n        let classKeyIndex = -1\r\n        let styleKeyIndex = -1\r\n        let hasDynamicKey = false\r\n\r\n        for (let i = 0; i < propsExpression.properties.length; i++) {\r\n          const key = propsExpression.properties[i].key\r\n          if (isStaticExp(key)) {\r\n            if (key.content === 'class') {\r\n              classKeyIndex = i\r\n            } else if (key.content === 'style') {\r\n              styleKeyIndex = i\r\n            }\r\n          } else if (!key.isHandlerKey) {\r\n            hasDynamicKey = true\r\n          }\r\n        }\r\n\r\n        const classProp = propsExpression.properties[classKeyIndex]\r\n        const styleProp = propsExpression.properties[styleKeyIndex]\r\n\r\n        // no dynamic key\r\n        if (!hasDynamicKey) {\r\n          if (classProp && !isStaticExp(classProp.value)) {\r\n            classProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_CLASS),\r\n              [classProp.value]\r\n            )\r\n          }\r\n          if (\r\n            styleProp &&\r\n            // the static style is compiled into an object,\r\n            // so use `hasStyleBinding` to ensure that it is a dynamic style binding\r\n            (hasStyleBinding ||\r\n              (styleProp.value.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n                styleProp.value.content.trim()[0] === `[`) ||\r\n              // v-bind:style and style both exist,\r\n              // v-bind:style with static literal object\r\n              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)\r\n          ) {\r\n            styleProp.value = createCallExpression(\r\n              context.helper(NORMALIZE_STYLE),\r\n              [styleProp.value]\r\n            )\r\n          }\r\n        } else {\r\n          // dynamic key binding, wrap with `normalizeProps`\r\n          propsExpression = createCallExpression(\r\n            context.helper(NORMALIZE_PROPS),\r\n            [propsExpression]\r\n          )\r\n        }\r\n        break\r\n      case NodeTypes.JS_CALL_EXPRESSION:\r\n        // mergeProps call, do nothing\r\n        break\r\n      default:\r\n        // single v-bind\r\n        propsExpression = createCallExpression(\r\n          context.helper(NORMALIZE_PROPS),\r\n          [\r\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\r\n              propsExpression\r\n            ])\r\n          ]\r\n        )\r\n        break\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: propsExpression,\r\n    directives: runtimeDirectives,\r\n    patchFlag,\r\n    dynamicPropNames,\r\n    shouldUseBlock\r\n  }\r\n}\r\n\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties: Property[]): Property[] {\r\n  const knownProps: Map<string, Property> = new Map()\r\n  const deduped: Property[] = []\r\n  for (let i = 0; i < properties.length; i++) {\r\n    const prop = properties[i]\r\n    // dynamic keys are always allowed\r\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\r\n      deduped.push(prop)\r\n      continue\r\n    }\r\n    const name = prop.key.content\r\n    const existing = knownProps.get(name)\r\n    if (existing) {\r\n      if (name === 'style' || name === 'class' || isOn(name)) {\r\n        mergeAsArray(existing, prop)\r\n      }\r\n      // unexpected duplicate, should have emitted error during parse\r\n    } else {\r\n      knownProps.set(name, prop)\r\n      deduped.push(prop)\r\n    }\r\n  }\r\n  return deduped\r\n}\r\n\r\nfunction mergeAsArray(existing: Property, incoming: Property) {\r\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\r\n    existing.value.elements.push(incoming.value)\r\n  } else {\r\n    existing.value = createArrayExpression(\r\n      [existing.value, incoming.value],\r\n      existing.loc\r\n    )\r\n  }\r\n}\r\n\r\nexport function buildDirectiveArgs(\r\n  dir: DirectiveNode,\r\n  context: TransformContext\r\n): ArrayExpression {\r\n  const dirArgs: ArrayExpression['elements'] = []\r\n  const runtime = directiveImportMap.get(dir)\r\n  if (runtime) {\r\n    // built-in directive with runtime\r\n    dirArgs.push(context.helperString(runtime))\r\n  } else {\r\n    // user directive.\r\n    // see if we have directives exposed via <script setup>\r\n    const fromSetup =\r\n      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)\r\n    if (fromSetup) {\r\n      dirArgs.push(fromSetup)\r\n    } else {\r\n      // inject statement for resolving directive\r\n      context.helper(RESOLVE_DIRECTIVE)\r\n      context.directives.add(dir.name)\r\n      dirArgs.push(toValidAssetId(dir.name, `directive`))\r\n    }\r\n  }\r\n  const { loc } = dir\r\n  if (dir.exp) dirArgs.push(dir.exp)\r\n  if (dir.arg) {\r\n    if (!dir.exp) {\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    dirArgs.push(dir.arg)\r\n  }\r\n  if (Object.keys(dir.modifiers).length) {\r\n    if (!dir.arg) {\r\n      if (!dir.exp) {\r\n        dirArgs.push(`void 0`)\r\n      }\r\n      dirArgs.push(`void 0`)\r\n    }\r\n    const trueExpression = createSimpleExpression(`true`, false, loc)\r\n    dirArgs.push(\r\n      createObjectExpression(\r\n        dir.modifiers.map(modifier =>\r\n          createObjectProperty(modifier, trueExpression)\r\n        ),\r\n        loc\r\n      )\r\n    )\r\n  }\r\n  return createArrayExpression(dirArgs, dir.loc)\r\n}\r\n\r\nfunction stringifyDynamicPropNames(props: string[]): string {\r\n  let propsNamesString = `[`\r\n  for (let i = 0, l = props.length; i < l; i++) {\r\n    propsNamesString += JSON.stringify(props[i])\r\n    if (i < l - 1) propsNamesString += ', '\r\n  }\r\n  return propsNamesString + `]`\r\n}\r\n\r\nfunction isComponentTag(tag: string) {\r\n  return tag === 'component' || tag === 'Component'\r\n}\r\n", "import { NodeTransform, TransformContext } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  CallExpression,\r\n  createCallExpression,\r\n  ExpressionNode,\r\n  SlotOutletNode,\r\n  createFunctionExpression\r\n} from '../ast'\r\nimport { isSlotOutlet, isStaticArgOf, isStaticExp } from '../utils'\r\nimport { buildProps, PropsExpression } from './transformElement'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { RENDER_SLOT } from '../runtimeHelpers'\r\nimport { camelize } from '@vue/shared'\r\n\r\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\r\n  if (isSlotOutlet(node)) {\r\n    const { children, loc } = node\r\n    const { slotName, slotProps } = processSlotOutlet(node, context)\r\n\r\n    const slotArgs: CallExpression['arguments'] = [\r\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n      slotName,\r\n      '{}',\r\n      'undefined',\r\n      'true'\r\n    ]\r\n    let expectedLen = 2\r\n\r\n    if (slotProps) {\r\n      slotArgs[2] = slotProps\r\n      expectedLen = 3\r\n    }\r\n\r\n    if (children.length) {\r\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc)\r\n      expectedLen = 4\r\n    }\r\n\r\n    if (context.scopeId && !context.slotted) {\r\n      expectedLen = 5\r\n    }\r\n    slotArgs.splice(expectedLen) // remove unused arguments\r\n\r\n    node.codegenNode = createCallExpression(\r\n      context.helper(RENDER_SLOT),\r\n      slotArgs,\r\n      loc\r\n    )\r\n  }\r\n}\r\n\r\ninterface SlotOutletProcessResult {\r\n  slotName: string | ExpressionNode\r\n  slotProps: PropsExpression | undefined\r\n}\r\n\r\nexport function processSlotOutlet(\r\n  node: SlotOutletNode,\r\n  context: TransformContext\r\n): SlotOutletProcessResult {\r\n  let slotName: string | ExpressionNode = `\"default\"`\r\n  let slotProps: PropsExpression | undefined = undefined\r\n\r\n  const nonNameProps = []\r\n  for (let i = 0; i < node.props.length; i++) {\r\n    const p = node.props[i]\r\n    if (p.type === NodeTypes.ATTRIBUTE) {\r\n      if (p.value) {\r\n        if (p.name === 'name') {\r\n          slotName = JSON.stringify(p.value.content)\r\n        } else {\r\n          p.name = camelize(p.name)\r\n          nonNameProps.push(p)\r\n        }\r\n      }\r\n    } else {\r\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\r\n        if (p.exp) slotName = p.exp\r\n      } else {\r\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n          p.arg.content = camelize(p.arg.content)\r\n        }\r\n        nonNameProps.push(p)\r\n      }\r\n    }\r\n  }\r\n\r\n  if (nonNameProps.length > 0) {\r\n    const { props, directives } = buildProps(\r\n      node,\r\n      context,\r\n      nonNameProps,\r\n      false,\r\n      false\r\n    )\r\n    slotProps = props\r\n\r\n    if (directives.length) {\r\n      context.onError(\r\n        createCompilerError(\r\n          ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\r\n          directives[0].loc\r\n        )\r\n      )\r\n    }\r\n  }\r\n\r\n  return {\r\n    slotName,\r\n    slotProps\r\n  }\r\n}\r\n", "import { DirectiveTransform, DirectiveTransformResult } from '../transform'\r\nimport {\r\n  createCompoundExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  DirectiveNode,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  NodeTypes,\r\n  SimpleExpressionNode\r\n} from '../ast'\r\nimport { camelize, toHandlerKey } from '@vue/shared'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { processExpression } from './transformExpression'\r\nimport { validateBrowserExpression } from '../validateExpression'\r\nimport { hasScopeRef, isMemberExpression } from '../utils'\r\nimport { TO_HANDLER_KEY } from '../runtimeHelpers'\r\n\r\nconst fnExpRE =\r\n  /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/\r\n\r\nexport interface VOnDirectiveNode extends DirectiveNode {\r\n  // v-on without arg is handled directly in ./transformElements.ts due to it affecting\r\n  // codegen for the entire props object. This transform here is only for v-on\r\n  // *with* args.\r\n  arg: ExpressionNode\r\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\r\n  // skipped by transformExpression as a special case.\r\n  exp: SimpleExpressionNode | undefined\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (\r\n  dir,\r\n  node,\r\n  context,\r\n  augmentor\r\n) => {\r\n  const { loc, modifiers, arg } = dir as VOnDirectiveNode\r\n  if (!dir.exp && !modifiers.length) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\r\n  }\r\n  let eventName: ExpressionNode\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      let rawName = arg.content\r\n      if (__DEV__ && rawName.startsWith('vnode')) {\r\n        context.onWarn(\r\n          createCompilerError(ErrorCodes.DEPRECATION_VNODE_HOOKS, arg.loc)\r\n        )\r\n      }\r\n      if (rawName.startsWith('vue:')) {\r\n        rawName = `vnode-${rawName.slice(4)}`\r\n      }\r\n      const eventString =\r\n        node.tagType !== ElementTypes.ELEMENT ||\r\n        rawName.startsWith('vnode') ||\r\n        !/[A-Z]/.test(rawName)\r\n          ? // for non-element and vnode lifecycle event listeners, auto convert\r\n            // it to camelCase. See issue #2249\r\n            toHandlerKey(camelize(rawName))\r\n          : // preserve case for plain element listeners that have uppercase\r\n            // letters, as these may be custom elements' custom events\r\n            `on:${rawName}`\r\n      eventName = createSimpleExpression(eventString, true, arg.loc)\r\n    } else {\r\n      // #2388\r\n      eventName = createCompoundExpression([\r\n        `${context.helperString(TO_HANDLER_KEY)}(`,\r\n        arg,\r\n        `)`\r\n      ])\r\n    }\r\n  } else {\r\n    // already a compound expression.\r\n    eventName = arg\r\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)\r\n    eventName.children.push(`)`)\r\n  }\r\n\r\n  // handler processing\r\n  let exp: ExpressionNode | undefined = dir.exp as\r\n    | SimpleExpressionNode\r\n    | undefined\r\n  if (exp && !exp.content.trim()) {\r\n    exp = undefined\r\n  }\r\n  let shouldCache: boolean = context.cacheHandlers && !exp && !context.inVOnce\r\n  if (exp) {\r\n    const isMemberExp = isMemberExpression(exp.content, context)\r\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\r\n    const hasMultipleStatements = exp.content.includes(`;`)\r\n\r\n    // process the expression since it's been skipped\r\n    if (!__BROWSER__ && context.prefixIdentifiers) {\r\n      isInlineStatement && context.addIdentifiers(`$event`)\r\n      exp = dir.exp = processExpression(\r\n        exp,\r\n        context,\r\n        false,\r\n        hasMultipleStatements\r\n      )\r\n      isInlineStatement && context.removeIdentifiers(`$event`)\r\n      // with scope analysis, the function is hoistable if it has no reference\r\n      // to scope variables.\r\n      shouldCache =\r\n        context.cacheHandlers &&\r\n        // unnecessary to cache inside v-once\r\n        !context.inVOnce &&\r\n        // runtime constants don't need to be cached\r\n        // (this is analyzed by compileScript in SFC <script setup>)\r\n        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&\r\n        // #1541 bail if this is a member exp handler passed to a component -\r\n        // we need to use the original function to preserve arity,\r\n        // e.g. <transition> relies on checking cb.length to determine\r\n        // transition end handling. Inline function is ok since its arity\r\n        // is preserved even when cached.\r\n        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&\r\n        // bail if the function references closure variables (v-for, v-slot)\r\n        // it must be passed fresh to avoid stale values.\r\n        !hasScopeRef(exp, context.identifiers)\r\n      // If the expression is optimizable and is a member expression pointing\r\n      // to a function, turn it into invocation (and wrap in an arrow function\r\n      // below) so that it always accesses the latest value when called - thus\r\n      // avoiding the need to be patched.\r\n      if (shouldCache && isMemberExp) {\r\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n          exp.content = `${exp.content} && ${exp.content}(...args)`\r\n        } else {\r\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]\r\n        }\r\n      }\r\n    }\r\n\r\n    if (__DEV__ && __BROWSER__) {\r\n      validateBrowserExpression(\r\n        exp as SimpleExpressionNode,\r\n        context,\r\n        false,\r\n        hasMultipleStatements\r\n      )\r\n    }\r\n\r\n    if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n      // wrap inline statement in a function expression\r\n      exp = createCompoundExpression([\r\n        `${\r\n          isInlineStatement\r\n            ? !__BROWSER__ && context.isTS\r\n              ? `($event: any)`\r\n              : `$event`\r\n            : `${\r\n                !__BROWSER__ && context.isTS ? `\\n//@ts-ignore\\n` : ``\r\n              }(...args)`\r\n        } => ${hasMultipleStatements ? `{` : `(`}`,\r\n        exp,\r\n        hasMultipleStatements ? `}` : `)`\r\n      ])\r\n    }\r\n  }\r\n\r\n  let ret: DirectiveTransformResult = {\r\n    props: [\r\n      createObjectProperty(\r\n        eventName,\r\n        exp || createSimpleExpression(`() => {}`, false, loc)\r\n      )\r\n    ]\r\n  }\r\n\r\n  // apply extended compiler augmentor\r\n  if (augmentor) {\r\n    ret = augmentor(ret)\r\n  }\r\n\r\n  if (shouldCache) {\r\n    // cache handlers so that it's always the same handler being passed down.\r\n    // this avoids unnecessary re-renders when users use inline handlers on\r\n    // components.\r\n    ret.props[0].value = context.cache(ret.props[0].value)\r\n  }\r\n\r\n  // mark the key as handler for props normalization check\r\n  ret.props.forEach(p => (p.key.isHandlerKey = true))\r\n  return ret\r\n}\r\n", "import { DirectiveTransform } from '../transform'\r\nimport {\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  ExpressionNode,\r\n  NodeTypes\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport { camelize } from '@vue/shared'\r\nimport { CAMELIZE } from '../runtimeHelpers'\r\n\r\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nexport const transformBind: DirectiveTransform = (dir, _node, context) => {\r\n  const { exp, modifiers, loc } = dir\r\n  const arg = dir.arg!\r\n\r\n  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\r\n    arg.children.unshift(`(`)\r\n    arg.children.push(`) || \"\"`)\r\n  } else if (!arg.isStatic) {\r\n    arg.content = `${arg.content} || \"\"`\r\n  }\r\n\r\n  // .sync is replaced by v-model:arg\r\n  if (modifiers.includes('camel')) {\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      if (arg.isStatic) {\r\n        arg.content = camelize(arg.content)\r\n      } else {\r\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\r\n      }\r\n    } else {\r\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\r\n      arg.children.push(`)`)\r\n    }\r\n  }\r\n\r\n  if (!context.inSSR) {\r\n    if (modifiers.includes('prop')) {\r\n      injectPrefix(arg, '.')\r\n    }\r\n    if (modifiers.includes('attr')) {\r\n      injectPrefix(arg, '^')\r\n    }\r\n  }\r\n\r\n  if (\r\n    !exp ||\r\n    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\r\n  ) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\r\n    return {\r\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\r\n    }\r\n  }\r\n\r\n  return {\r\n    props: [createObjectProperty(arg, exp)]\r\n  }\r\n}\r\n\r\nconst injectPrefix = (arg: ExpressionNode, prefix: string) => {\r\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n    if (arg.isStatic) {\r\n      arg.content = prefix + arg.content\r\n    } else {\r\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``\r\n    }\r\n  } else {\r\n    arg.children.unshift(`'${prefix}' + (`)\r\n    arg.children.push(`)`)\r\n  }\r\n}\r\n", "import { NodeTransform } from '../transform'\r\nimport {\r\n  NodeTypes,\r\n  CompoundExpressionNode,\r\n  createCallExpression,\r\n  CallExpression,\r\n  ElementTypes,\r\n  ConstantTypes,\r\n  createCompoundExpression\r\n} from '../ast'\r\nimport { isText } from '../utils'\r\nimport { CREATE_TEXT } from '../runtimeHelpers'\r\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\r\nimport { getConstantType } from './hoistStatic'\r\n\r\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nexport const transformText: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ROOT ||\r\n    node.type === NodeTypes.ELEMENT ||\r\n    node.type === NodeTypes.FOR ||\r\n    node.type === NodeTypes.IF_BRANCH\r\n  ) {\r\n    // perform the transform on node exit so that all expressions have already\r\n    // been processed.\r\n    return () => {\r\n      const children = node.children\r\n      let currentContainer: CompoundExpressionNode | undefined = undefined\r\n      let hasText = false\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child)) {\r\n          hasText = true\r\n          for (let j = i + 1; j < children.length; j++) {\r\n            const next = children[j]\r\n            if (isText(next)) {\r\n              if (!currentContainer) {\r\n                currentContainer = children[i] = createCompoundExpression(\r\n                  [child],\r\n                  child.loc\r\n                )\r\n              }\r\n              // merge adjacent text node into current\r\n              currentContainer.children.push(` + `, next)\r\n              children.splice(j, 1)\r\n              j--\r\n            } else {\r\n              currentContainer = undefined\r\n              break\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (\r\n        !hasText ||\r\n        // if this is a plain element with a single text child, leave it\r\n        // as-is since the runtime has dedicated fast path for this by directly\r\n        // setting textContent of the element.\r\n        // for component root it's always normalized anyway.\r\n        (children.length === 1 &&\r\n          (node.type === NodeTypes.ROOT ||\r\n            (node.type === NodeTypes.ELEMENT &&\r\n              node.tagType === ElementTypes.ELEMENT &&\r\n              // #3756\r\n              // custom directives can potentially add DOM elements arbitrarily,\r\n              // we need to avoid setting textContent of the element at runtime\r\n              // to avoid accidentally overwriting the DOM elements added\r\n              // by the user through custom directives.\r\n              !node.props.find(\r\n                p =>\r\n                  p.type === NodeTypes.DIRECTIVE &&\r\n                  !context.directiveTransforms[p.name]\r\n              ) &&\r\n              // in compat mode, <template> tags with no special directives\r\n              // will be rendered as a fragment so its children must be\r\n              // converted into vnodes.\r\n              !(__COMPAT__ && node.tag === 'template'))))\r\n      ) {\r\n        return\r\n      }\r\n\r\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n      // runtime normalization.\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i]\r\n        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n          const callArgs: CallExpression['arguments'] = []\r\n          // createTextVNode defaults to single whitespace, so if it is a\r\n          // single space the code could be an empty call to save bytes.\r\n          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {\r\n            callArgs.push(child)\r\n          }\r\n          // mark dynamic text with flag so it gets patched inside a block\r\n          if (\r\n            !context.ssr &&\r\n            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\r\n          ) {\r\n            callArgs.push(\r\n              PatchFlags.TEXT +\r\n                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)\r\n            )\r\n          }\r\n          children[i] = {\r\n            type: NodeTypes.TEXT_CALL,\r\n            content: child,\r\n            loc: child.loc,\r\n            codegenNode: createCallExpression(\r\n              context.helper(CREATE_TEXT),\r\n              callArgs\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { NodeTransform } from '../transform'\r\nimport { findDir } from '../utils'\r\nimport { ElementNode, ForNode, IfNode, NodeTypes } from '../ast'\r\nimport { SET_BLOCK_TRACKING } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformOnce: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {\r\n    if (seen.has(node) || context.inVOnce || context.inSSR) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    context.inVOnce = true\r\n    context.helper(SET_BLOCK_TRACKING)\r\n    return () => {\r\n      context.inVOnce = false\r\n      const cur = context.currentNode as ElementNode | IfNode | ForNode\r\n      if (cur.codegenNode) {\r\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { DirectiveTransform } from '../transform'\r\nimport {\r\n  createSimpleExpression,\r\n  createObjectProperty,\r\n  createCompoundExpression,\r\n  NodeTypes,\r\n  Property,\r\n  ElementTypes,\r\n  ExpressionNode,\r\n  ConstantTypes\r\n} from '../ast'\r\nimport { createCompilerError, ErrorCodes } from '../errors'\r\nimport {\r\n  isMemberExpression,\r\n  isSimpleIdentifier,\r\n  hasScopeRef,\r\n  isStaticExp\r\n} from '../utils'\r\nimport { IS_REF } from '../runtimeHelpers'\r\nimport { BindingTypes } from '../options'\r\nimport { camelize } from '@vue/shared'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, arg } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  const rawExp = exp.loc.source\r\n  const expString =\r\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp\r\n\r\n  // im SFC <script setup> inline mode, the exp may have been transformed into\r\n  // _unref(exp)\r\n  const bindingType = context.bindingMetadata[rawExp]\r\n\r\n  // check props\r\n  if (\r\n    bindingType === BindingTypes.PROPS ||\r\n    bindingType === BindingTypes.PROPS_ALIASED\r\n  ) {\r\n    context.onError(createCompilerError(ErrorCodes.X_V_MODEL_ON_PROPS, exp.loc))\r\n    return createTransformProps()\r\n  }\r\n\r\n  const maybeRef =\r\n    !__BROWSER__ &&\r\n    context.inline &&\r\n    (bindingType === BindingTypes.SETUP_LET ||\r\n      bindingType === BindingTypes.SETUP_REF ||\r\n      bindingType === BindingTypes.SETUP_MAYBE_REF)\r\n\r\n  if (\r\n    !expString.trim() ||\r\n    (!isMemberExpression(expString, context) && !maybeRef)\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    isSimpleIdentifier(expString) &&\r\n    context.identifiers[expString]\r\n  ) {\r\n    context.onError(\r\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\r\n    )\r\n    return createTransformProps()\r\n  }\r\n\r\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\r\n  const eventName = arg\r\n    ? isStaticExp(arg)\r\n      ? `onUpdate:${camelize(arg.content)}`\r\n      : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n    : `onUpdate:modelValue`\r\n\r\n  let assignmentExp: ExpressionNode\r\n  const eventArg = context.isTS ? `($event: any)` : `$event`\r\n  if (maybeRef) {\r\n    if (bindingType === BindingTypes.SETUP_REF) {\r\n      // v-model used on known ref.\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => ((`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event)`\r\n      ])\r\n    } else {\r\n      // v-model used on a potentially ref binding in <script setup> inline mode.\r\n      // the assignment needs to check whether the binding is actually a ref.\r\n      const altAssignment =\r\n        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`\r\n      assignmentExp = createCompoundExpression([\r\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\r\n        createSimpleExpression(rawExp, false, exp.loc),\r\n        `).value = $event : ${altAssignment})`\r\n      ])\r\n    }\r\n  } else {\r\n    assignmentExp = createCompoundExpression([\r\n      `${eventArg} => ((`,\r\n      exp,\r\n      `) = $event)`\r\n    ])\r\n  }\r\n\r\n  const props = [\r\n    // modelValue: foo\r\n    createObjectProperty(propName, dir.exp!),\r\n    // \"onUpdate:modelValue\": $event => (foo = $event)\r\n    createObjectProperty(eventName, assignmentExp)\r\n  ]\r\n\r\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\r\n  if (\r\n    !__BROWSER__ &&\r\n    context.prefixIdentifiers &&\r\n    !context.inVOnce &&\r\n    context.cacheHandlers &&\r\n    !hasScopeRef(exp, context.identifiers)\r\n  ) {\r\n    props[1].value = context.cache(props[1].value)\r\n  }\r\n\r\n  // modelModifiers: { foo: true, \"bar-baz\": true }\r\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\r\n    const modifiers = dir.modifiers\r\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n      .join(`, `)\r\n    const modifiersKey = arg\r\n      ? isStaticExp(arg)\r\n        ? `${arg.content}Modifiers`\r\n        : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n      : `modelModifiers`\r\n    props.push(\r\n      createObjectProperty(\r\n        modifiersKey,\r\n        createSimpleExpression(\r\n          `{ ${modifiers} }`,\r\n          false,\r\n          dir.loc,\r\n          ConstantTypes.CAN_HOIST\r\n        )\r\n      )\r\n    )\r\n  }\r\n\r\n  return createTransformProps(props)\r\n}\r\n\r\nfunction createTransformProps(props: Property[] = []) {\r\n  return { props }\r\n}\r\n", "import { NodeTransform } from '../transform'\r\nimport { findDir } from '../utils'\r\nimport {\r\n  convertToBlock,\r\n  createCallExpression,\r\n  createFunctionExpression,\r\n  ElementTypes,\r\n  MemoExpression,\r\n  NodeTypes,\r\n  PlainElementNode\r\n} from '../ast'\r\nimport { WITH_MEMO } from '../runtimeHelpers'\r\n\r\nconst seen = new WeakSet()\r\n\r\nexport const transformMemo: NodeTransform = (node, context) => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    const dir = findDir(node, 'memo')\r\n    if (!dir || seen.has(node)) {\r\n      return\r\n    }\r\n    seen.add(node)\r\n    return () => {\r\n      const codegenNode =\r\n        node.codegenNode ||\r\n        (context.currentNode as PlainElementNode).codegenNode\r\n      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {\r\n        // non-component sub tree should be turned into a block\r\n        if (node.tagType !== ElementTypes.COMPONENT) {\r\n          convertToBlock(codegenNode, context)\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\r\n          dir.exp!,\r\n          createFunctionExpression(undefined, codegenNode),\r\n          `_cache`,\r\n          String(context.cached++)\r\n        ]) as MemoExpression\r\n      }\r\n    }\r\n  }\r\n}\r\n", "import { CompilerOptions } from './options'\r\nimport { baseParse } from './parse'\r\nimport { transform, NodeTransform, DirectiveTransform } from './transform'\r\nimport { generate, CodegenResult } from './codegen'\r\nimport { RootNode } from './ast'\r\nimport { isString, extend } from '@vue/shared'\r\nimport { transformIf } from './transforms/vIf'\r\nimport { transformFor } from './transforms/vFor'\r\nimport { transformExpression } from './transforms/transformExpression'\r\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\r\nimport { transformElement } from './transforms/transformElement'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformBind } from './transforms/vBind'\r\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\r\nimport { transformText } from './transforms/transformText'\r\nimport { transformOnce } from './transforms/vOnce'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformFilter } from './compat/transformFilter'\r\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\r\nimport { transformMemo } from './transforms/vMemo'\r\n\r\nexport type TransformPreset = [\r\n  NodeTransform[],\r\n  Record<string, DirectiveTransform>\r\n]\r\n\r\nexport function getBaseTransformPreset(\r\n  prefixIdentifiers?: boolean\r\n): TransformPreset {\r\n  return [\r\n    [\r\n      transformOnce,\r\n      transformIf,\r\n      transformMemo,\r\n      transformFor,\r\n      ...(__COMPAT__ ? [transformFilter] : []),\r\n      ...(!__BROWSER__ && prefixIdentifiers\r\n        ? [\r\n            // order is important\r\n            trackVForSlotScopes,\r\n            transformExpression\r\n          ]\r\n        : __BROWSER__ && __DEV__\r\n          ? [transformExpression]\r\n          : []),\r\n      transformSlotOutlet,\r\n      transformElement,\r\n      trackSlotScopes,\r\n      transformText\r\n    ],\r\n    {\r\n      on: transformOn,\r\n      bind: transformBind,\r\n      model: transformModel\r\n    }\r\n  ]\r\n}\r\n\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nexport function baseCompile(\r\n  template: string | RootNode,\r\n  options: CompilerOptions = {}\r\n): CodegenResult {\r\n  const onError = options.onError || defaultOnError\r\n  const isModuleMode = options.mode === 'module'\r\n  /* istanbul ignore if */\r\n  if (__BROWSER__) {\r\n    if (options.prefixIdentifiers === true) {\r\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\r\n    } else if (isModuleMode) {\r\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\r\n    }\r\n  }\r\n\r\n  const prefixIdentifiers =\r\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\r\n  if (!prefixIdentifiers && options.cacheHandlers) {\r\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\r\n  }\r\n  if (options.scopeId && !isModuleMode) {\r\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\r\n  }\r\n\r\n  const ast = isString(template) ? baseParse(template, options) : template\r\n  const [nodeTransforms, directiveTransforms] =\r\n    getBaseTransformPreset(prefixIdentifiers)\r\n\r\n  if (!__BROWSER__ && options.isTS) {\r\n    const { expressionPlugins } = options\r\n    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {\r\n      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']\r\n    }\r\n  }\r\n\r\n  transform(\r\n    ast,\r\n    extend({}, options, {\r\n      prefixIdentifiers,\r\n      nodeTransforms: [\r\n        ...nodeTransforms,\r\n        ...(options.nodeTransforms || []) // user transforms\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        directiveTransforms,\r\n        options.directiveTransforms || {} // user transforms\r\n      )\r\n    })\r\n  )\r\n\r\n  return generate(\r\n    ast,\r\n    extend({}, options, {\r\n      prefixIdentifiers\r\n    })\r\n  )\r\n}\r\n", "import { DirectiveTransform } from '../transform'\r\n\r\nexport const noopDirectiveTransform: DirectiveTransform = () => ({ props: [] })\r\n", "import { registerRuntimeHelpers } from '@vue/compiler-core'\r\n\r\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\r\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\r\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\r\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\r\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\r\n\r\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\r\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\r\n\r\nexport const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)\r\n\r\nexport const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)\r\nexport const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)\r\n\r\nregisterRuntimeHelpers({\r\n  [V_MODEL_RADIO]: `vModelRadio`,\r\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n  [V_MODEL_TEXT]: `vModelText`,\r\n  [V_MODEL_SELECT]: `vModelSelect`,\r\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n  [V_ON_WITH_KEYS]: `withKeys`,\r\n  [V_SHOW]: `vShow`,\r\n  [TRANSITION]: `Transition`,\r\n  [TRANSITION_GROUP]: `TransitionGroup`\r\n})\r\n", "/* eslint-disable no-restricted-globals */\r\n\r\nlet decoder: HTMLDivElement\r\n\r\nexport function decodeHtmlBrowser(raw: string, asAttr = false): string {\r\n  if (!decoder) {\r\n    decoder = document.createElement('div')\r\n  }\r\n  if (asAttr) {\r\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`\r\n    return decoder.children[0].getAttribute('foo')!\r\n  } else {\r\n    decoder.innerHTML = raw\r\n    return decoder.textContent!\r\n  }\r\n}\r\n", "import {\r\n  TextModes,\r\n  ParserOptions,\r\n  ElementNode,\r\n  NodeTypes,\r\n  isBuiltInType\r\n} from '@vue/compiler-core'\r\nimport { makeMap, isVoidTag, isHTMLTag, isSVGTag } from '@vue/shared'\r\nimport { TRANSITION, TRANSITION_GROUP } from './runtimeHelpers'\r\nimport { decodeHtml } from './decodeHtml'\r\nimport { decodeHtmlBrowser } from './decodeHtmlBrowser'\r\n\r\nconst isRawTextContainer = /*#__PURE__*/ makeMap(\r\n  'style,iframe,script,noscript',\r\n  true\r\n)\r\n\r\nexport const enum DOMNamespaces {\r\n  HTML = 0 /* Namespaces.HTML */,\r\n  SVG,\r\n  MATH_ML\r\n}\r\n\r\nexport const parserOptions: ParserOptions = {\r\n  isVoidTag,\r\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\r\n  isPreTag: tag => tag === 'pre',\r\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\r\n\r\n  isBuiltInComponent: (tag: string): symbol | undefined => {\r\n    if (isBuiltInType(tag, `Transition`)) {\r\n      return TRANSITION\r\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n      return TRANSITION_GROUP\r\n    }\r\n  },\r\n\r\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\r\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\r\n\r\n    if (parent && ns === DOMNamespaces.MATH_ML) {\r\n      if (parent.tag === 'annotation-xml') {\r\n        if (tag === 'svg') {\r\n          return DOMNamespaces.SVG\r\n        }\r\n        if (\r\n          parent.props.some(\r\n            a =>\r\n              a.type === NodeTypes.ATTRIBUTE &&\r\n              a.name === 'encoding' &&\r\n              a.value != null &&\r\n              (a.value.content === 'text/html' ||\r\n                a.value.content === 'application/xhtml+xml')\r\n          )\r\n        ) {\r\n          ns = DOMNamespaces.HTML\r\n        }\r\n      } else if (\r\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\r\n        tag !== 'mglyph' &&\r\n        tag !== 'malignmark'\r\n      ) {\r\n        ns = DOMNamespaces.HTML\r\n      }\r\n    } else if (parent && ns === DOMNamespaces.SVG) {\r\n      if (\r\n        parent.tag === 'foreignObject' ||\r\n        parent.tag === 'desc' ||\r\n        parent.tag === 'title'\r\n      ) {\r\n        ns = DOMNamespaces.HTML\r\n      }\r\n    }\r\n\r\n    if (ns === DOMNamespaces.HTML) {\r\n      if (tag === 'svg') {\r\n        return DOMNamespaces.SVG\r\n      }\r\n      if (tag === 'math') {\r\n        return DOMNamespaces.MATH_ML\r\n      }\r\n    }\r\n    return ns\r\n  },\r\n\r\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n  getTextMode({ tag, ns }: ElementNode): TextModes {\r\n    if (ns === DOMNamespaces.HTML) {\r\n      if (tag === 'textarea' || tag === 'title') {\r\n        return TextModes.RCDATA\r\n      }\r\n      if (isRawTextContainer(tag)) {\r\n        return TextModes.RAWTEXT\r\n      }\r\n    }\r\n    return TextModes.DATA\r\n  }\r\n}\r\n", "import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  createSimpleExpression,\r\n  SimpleExpressionNode,\r\n  SourceLocation,\r\n  ConstantTypes\r\n} from '@vue/compiler-core'\r\nimport { parseStringStyle } from '@vue/shared'\r\n\r\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nexport const transformStyle: NodeTransform = node => {\r\n  if (node.type === NodeTypes.ELEMENT) {\r\n    node.props.forEach((p, i) => {\r\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\r\n        // replace p with an expression node\r\n        node.props[i] = {\r\n          type: NodeTypes.DIRECTIVE,\r\n          name: `bind`,\r\n          arg: createSimpleExpression(`style`, true, p.loc),\r\n          exp: parseInlineCSS(p.value.content, p.loc),\r\n          modifiers: [],\r\n          loc: p.loc\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nconst parseInlineCSS = (\r\n  cssText: string,\r\n  loc: SourceLocation\r\n): SimpleExpressionNode => {\r\n  const normalized = parseStringStyle(cssText)\r\n  return createSimpleExpression(\r\n    JSON.stringify(normalized),\r\n    false,\r\n    loc,\r\n    ConstantTypes.CAN_STRINGIFY\r\n  )\r\n}\r\n", "import {\r\n  SourceLocation,\r\n  CompilerError,\r\n  createCompilerError,\r\n  ErrorCodes\r\n} from '@vue/compiler-core'\r\n\r\nexport interface DOMCompilerError extends CompilerError {\r\n  code: DOMErrorCodes\r\n}\r\n\r\nexport function createDOMCompilerError(\r\n  code: DOMErrorCodes,\r\n  loc?: SourceLocation\r\n) {\r\n  return createCompilerError(\r\n    code,\r\n    loc,\r\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\r\n  ) as DOMCompilerError\r\n}\r\n\r\nexport const enum DOMErrorCodes {\r\n  X_V_HTML_NO_EXPRESSION = 53 /* ErrorCodes.__EXTEND_POINT__ */,\r\n  X_V_HTML_WITH_CHILDREN,\r\n  X_V_TEXT_NO_EXPRESSION,\r\n  X_V_TEXT_WITH_CHILDREN,\r\n  X_V_MODEL_ON_INVALID_ELEMENT,\r\n  X_V_MODEL_ARG_ON_ELEMENT,\r\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n  X_V_MODEL_UNNECESSARY_VALUE,\r\n  X_V_SHOW_NO_EXPRESSION,\r\n  X_TRANSITION_INVALID_CHILDREN,\r\n  X_IGNORED_SIDE_EFFECT_TAG,\r\n  __EXTEND_POINT__\r\n}\r\n\r\nif (__TEST__) {\r\n  // esbuild cannot infer const enum increments if first value is from another\r\n  // file, so we have to manually keep them in sync. this check ensures it\r\n  // errors out if there are collisions.\r\n  if (DOMErrorCodes.X_V_HTML_NO_EXPRESSION < ErrorCodes.__EXTEND_POINT__) {\r\n    throw new Error(\r\n      `DOMErrorCodes need to be updated to ${\r\n        ErrorCodes.__EXTEND_POINT__ + 1\r\n      } to match extension point from core ErrorCodes.`\r\n    )\r\n  }\r\n}\r\n\r\nexport const DOMErrorMessages: { [code: number]: string } = {\r\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\r\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\r\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\r\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\r\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n  [DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n  [DOMErrorCodes.X_V_SHOW_NO_EXPRESSION]: `v-show is missing expression.`,\r\n  [DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN]: `<Transition> expects exactly one child element or component.`,\r\n  [DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n}\r\n", "import {\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createSimpleExpression\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\n\r\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`innerHTML`, true, loc),\r\n        exp || createSimpleExpression('', true)\r\n      )\r\n    ]\r\n  }\r\n}\r\n", "import {\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  TO_DISPLAY_STRING,\r\n  createCallExpression,\r\n  getConstantType\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\n\r\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n  if (node.children.length) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\r\n    )\r\n    node.children.length = 0\r\n  }\r\n  return {\r\n    props: [\r\n      createObjectProperty(\r\n        createSimpleExpression(`textContent`, true),\r\n        exp\r\n          ? getConstantType(exp, context) > 0\r\n            ? exp\r\n            : createCallExpression(\r\n                context.helperString(TO_DISPLAY_STRING),\r\n                [exp],\r\n                loc\r\n              )\r\n          : createSimpleExpression('', true)\r\n      )\r\n    ]\r\n  }\r\n}\r\n", "import {\r\n  transformModel as baseTransform,\r\n  DirectiveTransform,\r\n  ElementTypes,\r\n  findProp,\r\n  NodeTypes,\r\n  hasDynamicKeyVBind,\r\n  findDir,\r\n  isStaticArgOf\r\n} from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\nimport {\r\n  V_MODEL_CHECKBOX,\r\n  V_MODEL_RADIO,\r\n  V_MODEL_SELECT,\r\n  V_MODEL_TEXT,\r\n  V_MODEL_DYNAMIC\r\n} from '../runtimeHelpers'\r\n\r\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\r\n  const baseResult = baseTransform(dir, node, context)\r\n  // base transform has errors OR component v-model (only need props)\r\n  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {\r\n    return baseResult\r\n  }\r\n\r\n  if (dir.arg) {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\r\n        dir.arg.loc\r\n      )\r\n    )\r\n  }\r\n\r\n  function checkDuplicatedValue() {\r\n    const value = findDir(node, 'bind')\r\n    if (value && isStaticArgOf(value.arg, 'value')) {\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\r\n          value.loc\r\n        )\r\n      )\r\n    }\r\n  }\r\n\r\n  const { tag } = node\r\n  const isCustomElement = context.isCustomElement(tag)\r\n  if (\r\n    tag === 'input' ||\r\n    tag === 'textarea' ||\r\n    tag === 'select' ||\r\n    isCustomElement\r\n  ) {\r\n    let directiveToUse = V_MODEL_TEXT\r\n    let isInvalidType = false\r\n    if (tag === 'input' || isCustomElement) {\r\n      const type = findProp(node, `type`)\r\n      if (type) {\r\n        if (type.type === NodeTypes.DIRECTIVE) {\r\n          // :type=\"foo\"\r\n          directiveToUse = V_MODEL_DYNAMIC\r\n        } else if (type.value) {\r\n          switch (type.value.content) {\r\n            case 'radio':\r\n              directiveToUse = V_MODEL_RADIO\r\n              break\r\n            case 'checkbox':\r\n              directiveToUse = V_MODEL_CHECKBOX\r\n              break\r\n            case 'file':\r\n              isInvalidType = true\r\n              context.onError(\r\n                createDOMCompilerError(\r\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\r\n                  dir.loc\r\n                )\r\n              )\r\n              break\r\n            default:\r\n              // text type\r\n              __DEV__ && checkDuplicatedValue()\r\n              break\r\n          }\r\n        }\r\n      } else if (hasDynamicKeyVBind(node)) {\r\n        // element has bindings with dynamic keys, which can possibly contain\r\n        // \"type\".\r\n        directiveToUse = V_MODEL_DYNAMIC\r\n      } else {\r\n        // text type\r\n        __DEV__ && checkDuplicatedValue()\r\n      }\r\n    } else if (tag === 'select') {\r\n      directiveToUse = V_MODEL_SELECT\r\n    } else {\r\n      // textarea\r\n      __DEV__ && checkDuplicatedValue()\r\n    }\r\n    // inject runtime directive\r\n    // by returning the helper symbol via needRuntime\r\n    // the import will replaced a resolveDirective call.\r\n    if (!isInvalidType) {\r\n      baseResult.needRuntime = context.helper(directiveToUse)\r\n    }\r\n  } else {\r\n    context.onError(\r\n      createDOMCompilerError(\r\n        DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\r\n        dir.loc\r\n      )\r\n    )\r\n  }\r\n\r\n  // native vmodel doesn't need the `modelValue` props since they are also\r\n  // passed to the runtime as `binding.value`. removing it reduces code size.\r\n  baseResult.props = baseResult.props.filter(\r\n    p =>\r\n      !(\r\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\r\n        p.key.content === 'modelValue'\r\n      )\r\n  )\r\n\r\n  return baseResult\r\n}\r\n", "import {\r\n  transformOn as baseTransform,\r\n  DirectiveTransform,\r\n  createObjectProperty,\r\n  createCallExpression,\r\n  createSimpleExpression,\r\n  NodeTypes,\r\n  createCompoundExpression,\r\n  ExpressionNode,\r\n  SimpleExpressionNode,\r\n  isStaticExp,\r\n  CompilerDeprecationTypes,\r\n  TransformContext,\r\n  SourceLocation,\r\n  checkCompatEnabled\r\n} from '@vue/compiler-core'\r\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\r\nimport { makeMap, capitalize } from '@vue/shared'\r\n\r\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\r\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\r\n  // event propagation management\r\n  `stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`\r\n)\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')\r\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\r\n  `onkeyup,onkeydown,onkeypress`,\r\n  true\r\n)\r\n\r\nconst resolveModifiers = (\r\n  key: ExpressionNode,\r\n  modifiers: string[],\r\n  context: TransformContext,\r\n  loc: SourceLocation\r\n) => {\r\n  const keyModifiers = []\r\n  const nonKeyModifiers = []\r\n  const eventOptionModifiers = []\r\n\r\n  for (let i = 0; i < modifiers.length; i++) {\r\n    const modifier = modifiers[i]\r\n\r\n    if (\r\n      __COMPAT__ &&\r\n      modifier === 'native' &&\r\n      checkCompatEnabled(\r\n        CompilerDeprecationTypes.COMPILER_V_ON_NATIVE,\r\n        context,\r\n        loc\r\n      )\r\n    ) {\r\n      eventOptionModifiers.push(modifier)\r\n    } else if (isEventOptionModifier(modifier)) {\r\n      // eventOptionModifiers: modifiers for addEventListener() options,\r\n      // e.g. .passive & .capture\r\n      eventOptionModifiers.push(modifier)\r\n    } else {\r\n      // runtimeModifiers: modifiers that needs runtime guards\r\n      if (maybeKeyModifier(modifier)) {\r\n        if (isStaticExp(key)) {\r\n          if (isKeyboardEvent((key as SimpleExpressionNode).content)) {\r\n            keyModifiers.push(modifier)\r\n          } else {\r\n            nonKeyModifiers.push(modifier)\r\n          }\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n          nonKeyModifiers.push(modifier)\r\n        }\r\n      } else {\r\n        if (isNonKeyModifier(modifier)) {\r\n          nonKeyModifiers.push(modifier)\r\n        } else {\r\n          keyModifiers.push(modifier)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    keyModifiers,\r\n    nonKeyModifiers,\r\n    eventOptionModifiers\r\n  }\r\n}\r\n\r\nconst transformClick = (key: ExpressionNode, event: string) => {\r\n  const isStaticClick =\r\n    isStaticExp(key) && key.content.toLowerCase() === 'onclick'\r\n  return isStaticClick\r\n    ? createSimpleExpression(event, true)\r\n    : key.type !== NodeTypes.SIMPLE_EXPRESSION\r\n      ? createCompoundExpression([\r\n          `(`,\r\n          key,\r\n          `) === \"onClick\" ? \"${event}\" : (`,\r\n          key,\r\n          `)`\r\n        ])\r\n      : key\r\n}\r\n\r\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\r\n  return baseTransform(dir, node, context, baseResult => {\r\n    const { modifiers } = dir\r\n    if (!modifiers.length) return baseResult\r\n\r\n    let { key, value: handlerExp } = baseResult.props[0]\r\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =\r\n      resolveModifiers(key, modifiers, context, dir.loc)\r\n\r\n    // normalize click.right and click.middle since they don't actually fire\r\n    if (nonKeyModifiers.includes('right')) {\r\n      key = transformClick(key, `onContextmenu`)\r\n    }\r\n    if (nonKeyModifiers.includes('middle')) {\r\n      key = transformClick(key, `onMouseup`)\r\n    }\r\n\r\n    if (nonKeyModifiers.length) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n        handlerExp,\r\n        JSON.stringify(nonKeyModifiers)\r\n      ])\r\n    }\r\n\r\n    if (\r\n      keyModifiers.length &&\r\n      // if event name is dynamic, always wrap with keys guard\r\n      (!isStaticExp(key) || isKeyboardEvent(key.content))\r\n    ) {\r\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n        handlerExp,\r\n        JSON.stringify(keyModifiers)\r\n      ])\r\n    }\r\n\r\n    if (eventOptionModifiers.length) {\r\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')\r\n      key = isStaticExp(key)\r\n        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n        : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`])\r\n    }\r\n\r\n    return {\r\n      props: [createObjectProperty(key, handlerExp)]\r\n    }\r\n  })\r\n}\r\n", "import { DirectiveTransform } from '@vue/compiler-core'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\nimport { V_SHOW } from '../runtimeHelpers'\r\n\r\nexport const transformShow: DirectiveTransform = (dir, node, context) => {\r\n  const { exp, loc } = dir\r\n  if (!exp) {\r\n    context.onError(\r\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc)\r\n    )\r\n  }\r\n\r\n  return {\r\n    props: [],\r\n    needRuntime: context.helper(V_SHOW)\r\n  }\r\n}\r\n", "import {\r\n  NodeTransform,\r\n  NodeTypes,\r\n  ElementTypes,\r\n  ComponentNode,\r\n  IfBranchNode\r\n} from '@vue/compiler-core'\r\nimport { TRANSITION } from '../runtimeHelpers'\r\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\r\n\r\nexport const transformTransition: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.COMPONENT\r\n  ) {\r\n    const component = context.isBuiltInComponent(node.tag)\r\n    if (component === TRANSITION) {\r\n      return () => {\r\n        if (!node.children.length) {\r\n          return\r\n        }\r\n\r\n        // warn multiple transition children\r\n        if (hasMultipleChildren(node)) {\r\n          context.onError(\r\n            createDOMCompilerError(\r\n              DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN,\r\n              {\r\n                start: node.children[0].loc.start,\r\n                end: node.children[node.children.length - 1].loc.end,\r\n                source: ''\r\n              }\r\n            )\r\n          )\r\n        }\r\n\r\n        // check if it's s single child w/ v-show\r\n        // if yes, inject \"persisted: true\" to the transition props\r\n        const child = node.children[0]\r\n        if (child.type === NodeTypes.ELEMENT) {\r\n          for (const p of child.props) {\r\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'show') {\r\n              node.props.push({\r\n                type: NodeTypes.ATTRIBUTE,\r\n                name: 'persisted',\r\n                value: undefined,\r\n                loc: node.loc\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction hasMultipleChildren(node: ComponentNode | IfBranchNode): boolean {\r\n  // #1352 filter out potential comment nodes.\r\n  const children = (node.children = node.children.filter(\r\n    c =>\r\n      c.type !== NodeTypes.COMMENT &&\r\n      !(c.type === NodeTypes.TEXT && !c.content.trim())\r\n  ))\r\n  const child = children[0]\r\n  return (\r\n    children.length !== 1 ||\r\n    child.type === NodeTypes.FOR ||\r\n    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))\r\n  )\r\n}\r\n", "import { NodeTransform, NodeTypes, ElementTypes } from '@vue/compiler-core'\r\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\r\n\r\nexport const ignoreSideEffectTags: NodeTransform = (node, context) => {\r\n  if (\r\n    node.type === NodeTypes.ELEMENT &&\r\n    node.tagType === ElementTypes.ELEMENT &&\r\n    (node.tag === 'script' || node.tag === 'style')\r\n  ) {\r\n    __DEV__ &&\r\n      context.onError(\r\n        createDOMCompilerError(\r\n          DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG,\r\n          node.loc\r\n        )\r\n      )\r\n    context.removeNode()\r\n  }\r\n}\r\n", "import {\r\n  baseCompile,\r\n  baseParse,\r\n  CompilerOptions,\r\n  CodegenResult,\r\n  ParserOptions,\r\n  RootNode,\r\n  noopDirectiveTransform,\r\n  NodeTransform,\r\n  DirectiveTransform\r\n} from '@vue/compiler-core'\r\nimport { parserOptions } from './parserOptions'\r\nimport { transformStyle } from './transforms/transformStyle'\r\nimport { transformVHtml } from './transforms/vHtml'\r\nimport { transformVText } from './transforms/vText'\r\nimport { transformModel } from './transforms/vModel'\r\nimport { transformOn } from './transforms/vOn'\r\nimport { transformShow } from './transforms/vShow'\r\nimport { transformTransition } from './transforms/Transition'\r\nimport { stringifyStatic } from './transforms/stringifyStatic'\r\nimport { ignoreSideEffectTags } from './transforms/ignoreSideEffectTags'\r\nimport { extend } from '@vue/shared'\r\n\r\nexport { parserOptions }\r\n\r\nexport const DOMNodeTransforms: NodeTransform[] = [\r\n  transformStyle,\r\n  ...(__DEV__ ? [transformTransition] : [])\r\n]\r\n\r\nexport const DOMDirectiveTransforms: Record<string, DirectiveTransform> = {\r\n  cloak: noopDirectiveTransform,\r\n  html: transformVHtml,\r\n  text: transformVText,\r\n  model: transformModel, // override compiler-core\r\n  on: transformOn, // override compiler-core\r\n  show: transformShow\r\n}\r\n\r\nexport function compile(\r\n  template: string,\r\n  options: CompilerOptions = {}\r\n): CodegenResult {\r\n  return baseCompile(\r\n    template,\r\n    extend({}, parserOptions, options, {\r\n      nodeTransforms: [\r\n        // ignore <script> and <tag>\r\n        // this is not put inside DOMNodeTransforms because that list is used\r\n        // by compiler-ssr to generate vnode fallback branches\r\n        ignoreSideEffectTags,\r\n        ...DOMNodeTransforms,\r\n        ...(options.nodeTransforms || [])\r\n      ],\r\n      directiveTransforms: extend(\r\n        {},\r\n        DOMDirectiveTransforms,\r\n        options.directiveTransforms || {}\r\n      ),\r\n      transformHoist: __BROWSER__ ? null : stringifyStatic\r\n    })\r\n  )\r\n}\r\n\r\nexport function parse(template: string, options: ParserOptions = {}): RootNode {\r\n  return baseParse(template, extend({}, parserOptions, options))\r\n}\r\n\r\nexport * from './runtimeHelpers'\r\nexport { transformStyle } from './transforms/transformStyle'\r\nexport { createDOMCompilerError, DOMErrorCodes } from './errors'\r\nexport * from '@vue/compiler-core'\r\n"],
  "mappings": "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,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,MAAK,IAAG,IAAG,MAAK,IAAG,GAAE,MAAK,KAAI,MAAK,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,MAAK,GAAE,MAAK,IAAG,GAAE,MAAK,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,MAAK,KAAI,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE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",
  "names": ["Position", "constructor", "line", "col", "index", "column", "SourceLocation", "start", "end", "filename", "identifierName", "createPositionWithColumnOffset", "position", "columnOffset", "code", "ModuleErrors", "ImportMetaOutsideModule", "message", "ImportOutsideModule", "NodeDescriptions", "ArrayPattern", "AssignmentExpression", "AssignmentPattern", "ArrowFunctionExpression", "ConditionalExpression", "CatchClause", "ForOfStatement", "ForInStatement", "ForStatement", "FormalParameters", "Identifier", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "ObjectPattern", "ParenthesizedExpression", "RestElement", "UpdateExpression", "true", "false", "VariableDeclarator", "YieldExpression", "toNodeDescription", "type", "prefix", "String", "StandardErrors", "AccessorIsGenerator", "kind", "ArgumentsInClass", "AsyncFunctionInSingleStatementContext", "AwaitBindingIdentifier", "AwaitBindingIdentifierInStaticBlock", "AwaitExpressionFormalParameter", "AwaitUsingNotInAsyncContext", "AwaitNotInAsyncContext", "AwaitNotInAsyncFunction", "BadGetterArity", "BadSetterArity", "BadSetterRestParameter", "ConstructorClassField", "ConstructorClassPrivateField", "ConstructorIsAccessor", "ConstructorIsAsync", "ConstructorIsGenerator", "DeclarationMissingInitializer", "DecoratorArgumentsOutsideParentheses", "DecoratorBeforeExport", "DecoratorsBeforeAfterExport", "DecoratorConstructor", "DecoratorExportClass", "DecoratorSemicolon", "DecoratorStaticBlock", "DeferImportRequiresNamespace", "DeletePrivateField", "DestructureNamedImport", "DuplicateConstructor", "DuplicateDefaultExport", "DuplicateExport", "exportName", "DuplicateProto", "DuplicateRegExpFlags", "DynamicImportPhaseRequiresImportExpressions", "phase", "ElementAfterRest", "EscapedCharNotAnIdentifier", "ExportBindingIsString", "localName", "ExportDefaultFromAsIdentifier", "ForInOfLoopInitializer", "ForInUsing", "ForOfAsync", "ForOfLet", "GeneratorInSingleStatementContext", "IllegalBreakContinue", "IllegalLanguageModeDirective", "IllegalReturn", "ImportAttributesUseAssert", "ImportBindingIsString", "importName", "ImportCallArgumentTrailingComma", "ImportCallArity", "maxArgumentCount", "ImportCallNotNewExpression", "ImportCallSpreadArgument", "ImportJSONBindingNotDefault", "ImportReflectionHasAssertion", "ImportReflectionNotBinding", "IncompatibleRegExpUVFlags", "InvalidBigIntLiteral", "InvalidCodePoint", "InvalidCoverInitializedName", "InvalidDecimal", "InvalidDigit", "radix", "InvalidEscapeSequence", "InvalidEscapeSequenceTemplate", "InvalidEscapedReservedWord", "reservedWord", "InvalidIdentifier", "InvalidLhs", "ancestor", "InvalidLhsBinding", "InvalidLhsOptionalChaining", "InvalidNumber", "InvalidOrMissingExponent", "InvalidOrUnexpectedToken", "unexpected", "InvalidParenthesizedAssignment", "InvalidPrivateFieldResolution", "InvalidPropertyBindingPattern", "InvalidRecordProperty", "InvalidRestAssignmentPattern", "LabelRedeclaration", "labelName", "LetInLexicalBinding", "LineTerminatorBeforeArrow", "MalformedRegExpFlags", "MissingClassName", "MissingEqInAssignment", "MissingSemicolon", "MissingPlugin", "missingPlugin", "map", "name", "JSON", "stringify", "join", "MissingOneOfPlugins", "MissingUnicodeEscape", "MixingCoalesceWithLogical", "ModuleAttributeDifferentFromType", "ModuleAttributeInvalidValue", "ModuleAttributesWithDuplicateKeys", "key", "ModuleExportNameHasLoneSurrogate", "surrogateCharCode", "toString", "ModuleExportUndefined", "MultipleDefaultsInSwitch", "NewlineAfterThrow", "NoCatchOrFinally", "NumberIdentifier", "NumericSeparatorInEscapeSequence", "ObsoleteAwaitStar", "OptionalChainingNoNew", "OptionalChainingNoTemplate", "OverrideOnConstructor", "ParamDupe", "PatternHasAccessor", "PatternHasMethod", "PrivateInExpectedIn", "PrivateNameRedeclaration", "RecordExpressionBarIncorrectEndSyntaxType", "RecordExpressionBarIncorrectStartSyntaxType", "RecordExpressionHashIncorrectStartSyntaxType", "RecordNoProto", "RestTrailingComma", "SloppyFunction", "SloppyFunctionAnnexB", "SourcePhaseImportRequiresDefault", "StaticPrototype", "SuperNotAllowed", "SuperPrivateField", "TrailingDecorator", "TupleExpressionBarIncorrectEndSyntaxType", "TupleExpressionBarIncorrectStartSyntaxType", "TupleExpressionHashIncorrectStartSyntaxType", "UnexpectedArgumentPlaceholder", "UnexpectedAwaitAfterPipelineBody", "UnexpectedDigitAfterHash", "UnexpectedImportExport", "UnexpectedKeyword", "keyword", "UnexpectedLeadingDecorator", "UnexpectedLexicalDeclaration", "UnexpectedNewTarget", "UnexpectedNumericSeparator", "UnexpectedPrivateField", "UnexpectedReservedWord", "UnexpectedSuper", "UnexpectedToken", "expected", "UnexpectedTokenUnaryExponentiation", "UnexpectedUsingDeclaration", "UnsupportedBind", "UnsupportedDecoratorExport", "UnsupportedDefaultExport", "UnsupportedImport", "UnsupportedMetaProperty", "target", "onlyValidPropertyName", "UnsupportedParameterDecorator", "UnsupportedPropertyDecorator", "UnsupportedSuper", "UnterminatedComment", "UnterminatedRegExp", "UnterminatedString", "UnterminatedTemplate", "UsingDeclarationHasBindingPattern", "VarRedeclaration", "YieldBindingIdentifier", "YieldInParameter", "ZeroDigitNumericSeparator", "StrictModeErrors", "StrictDelete", "StrictEvalArguments", "referenceName", "StrictEvalArgumentsBinding", "bindingName", "StrictFunction", "StrictNumericEscape", "StrictOctalLiteral", "StrictWith", "UnparenthesizedPipeBodyDescriptions", "Set", "PipelineOperatorErrors", "PipeBodyIsTighter", "PipeTopicRequiresHackPipes", "PipeTopicUnbound", "PipeTopicUnconfiguredToken", "token", "PipeTopicUnused", "PipeUnparenthesizedBody", "PipelineBodyNoArrow", "PipelineBodySequenceExpression", "PipelineHeadSequenceExpression", "PipelineTopicUnused", "PrimaryTopicNotAllowed", "PrimaryTopicRequiresSmartPipeline", "defineHidden", "obj", "value", "Object", "defineProperty", "enumerable", "configurable", "toParseErrorConstructor", "_ref", "toMessage", "properties", "_objectWithoutPropertiesLoose", "_excluded", "loc", "details", "error", "SyntaxError", "assign", "pos", "clone", "overrides", "_overrides$loc", "get", "set", "writable", "ParseErrorEnum", "argument", "syntaxPlugin", "Array", "isArray", "parseErrorTemplates", "ParseErrorConstructors", "reasonCode", "keys", "template", "_ref2", "rest", "_excluded2", "Errors", "toUnenumerable", "object", "toESTreeLocation", "node", "estree", "superClass", "ESTreeParserMixin", "parse", "file", "options", "tokens", "parseRegExpLiteral", "pattern", "flags", "regex", "RegExp", "e", "estreeParseLiteral", "parseBigIntLiteral", "bigInt", "BigInt", "_unused", "bigint", "parseDecimalLiteral", "decimal", "parseLiteral", "parseStringLiteral", "parseNumericLiteral", "parseNullLiteral", "parseBooleanLiteral", "directiveToStmt", "directive", "expression", "raw", "extra", "expressionValue", "stmt", "rawValue", "initFunction", "isAsync", "checkDeclaration", "isObjectProperty", "getObjectOrClassMethodParams", "method", "params", "isValidDirective", "_stmt$expression$extr", "parenthesized", "parseBlockBody", "allowDirectives", "topLevel", "afterBlockParse", "directiveStatements", "directives", "d", "body", "concat", "pushClassMethod", "classBody", "isGenerator", "isConstructor", "allowsDirectSuper", "parseMethod", "typeParameters", "push", "parsePrivateName", "getPluginOption", "convertPrivateNameToPrivateIdentifier", "getPrivateNameSV", "id", "isPrivateName", "parseFunctionBody", "allowExpression", "isMethod", "allowDirectSuper", "inClassScope", "funcNode", "startNode", "computed", "finishNode", "parseClassProperty", "args", "propertyNode", "parseClassPrivateProperty", "parseObjectMethod", "prop", "isPattern", "isAccessor", "shorthand", "parseObjectProperty", "startLoc", "refExpressionErrors", "isValidLVal", "isUnparenthesizedInAssign", "binding", "isAssignable", "isBinding", "toAssignable", "isLHS", "classScope", "usePrivateName", "toAssignableObjectExpressionProp", "isLast", "raise", "at", "finishCallExpression", "unfinished", "optional", "callee", "source", "arguments", "hasPlugin", "_node$arguments$", "_node$arguments$2", "attributes", "toReferencedArguments", "parseExport", "decorators", "exportStartLoc", "state", "lastTokStartLoc", "exported", "specifiers", "length", "_declaration$decorato", "declaration", "resetStartLocation", "parseSubscript", "base", "noCalls", "optionalChainMember", "substring", "stop", "chain", "startNodeAtNode", "isOptionalMemberExpression", "hasPropertyAsPrivateName", "isObjectMethod", "finishNodeAt", "endLoc", "resetEndLocation", "lastTokEndLoc", "TokContext", "preserveSpace", "types", "brace", "j_oTag", "j_cTag", "j_expr", "beforeExpr", "startsExpr", "isLoop", "isAssign", "postfix", "ExportedTokenType", "label", "conf", "rightAssociative", "binop", "updateContext", "keywords", "Map", "createKeyword", "createToken", "createBinop", "tokenTypeCounter", "tokenTypes", "tokenLabels", "tokenBinops", "tokenBeforeExprs", "tokenStartsExprs", "tokenPrefixes", "_options$binop", "_options$beforeExpr", "_options$startsExpr", "_options$prefix", "createKeywordLike", "_options$binop2", "_options$beforeExpr2", "_options$startsExpr2", "_options$prefix2", "tt", "bracketL", "bracketHashL", "bracketBarL", "bracketR", "bracketBarR", "braceL", "braceBarL", "braceHashL", "braceR", "braceBarR", "parenL", "parenR", "comma", "semi", "colon", "doubleColon", "dot", "question", "questionDot", "arrow", "ellipsis", "backQuote", "dollarBraceL", "templateTail", "templateNonTail", "hash", "interpreterDirective", "eq", "slashAssign", "xorAssign", "moduloAssign", "incDec", "bang", "tilde", "doubleCaret", "doubleAt", "pipeline", "nullishCoalescing", "logicalOR", "logicalAND", "bitwiseOR", "bitwiseXOR", "bitwiseAND", "equality", "lt", "gt", "relational", "bitShift", "bitShiftL", "bitShiftR", "plusMin", "modulo", "star", "slash", "exponent", "_in", "_instanceof", "_break", "_case", "_catch", "_continue", "_debugger", "_default", "_else", "_finally", "_function", "_if", "_return", "_switch", "_throw", "_try", "_var", "_const", "_with", "_new", "_this", "_super", "_class", "_extends", "_export", "_import", "_null", "_true", "_false", "_typeof", "_void", "_delete", "_do", "_for", "_while", "_as", "_assert", "_async", "_await", "_defer", "_from", "_get", "_let", "_meta", "_of", "_sent", "_set", "_source", "_static", "_using", "_yield", "_asserts", "_checks", "_exports", "_global", "_implements", "_intrinsic", "_infer", "_is", "_mixins", "_proto", "_require", "_satisfies", "_keyof", "_readonly", "_unique", "_abstract", "_declare", "_enum", "_module", "_namespace", "_interface", "_type", "_opaque", "string", "num", "regexp", "privateName", "eof", "jsxName", "jsxText", "jsxTagStart", "jsxTagEnd", "placeholder", "tokenIsIdentifier", "tokenKeywordOrIdentifierIsKeyword", "tokenIsKeywordOrIdentifier", "tokenIsLiteralPropertyName", "tokenComesBeforeExpression", "tokenCanStartExpression", "tokenIsAssignment", "tokenIsFlowInterfaceOrTypeOrOpaque", "tokenIsLoop", "tokenIsKeyword", "tokenIsOperator", "tokenIsPostfix", "tokenIsPrefix", "tokenIsTSTypeOperator", "tokenIsTSDeclarationStart", "tokenLabelName", "tokenOperatorPrecedence", "tokenIsRightAssociative", "tokenIsTemplate", "getExportedToken", "context", "pop", "tc", "nonASCIIidentifierStartChars", "nonASCIIidentifierChars", "nonASCIIidentifierStart", "nonASCIIidentifier", "astralIdentifierStartCodes", "astralIdentifierCodes", "isInAstralSet", "i", "isIdentifierStart", "test", "fromCharCode", "isIdentifierChar", "reservedWords", "strict", "strictBind", "reservedWordsStrictSet", "reservedWordsStrictBindSet", "isReservedWord", "word", "inModule", "isStrictReservedWord", "has", "isStrictBindOnlyReservedWord", "isStrictBindReservedWord", "isKeyword", "isIteratorStart", "current", "next", "next2", "reservedWordLikeSet", "canBeReservedWord", "Scope", "var", "lexical", "functions", "ScopeHandler", "parser", "scopeStack", "undefinedExports", "inTopLevel", "currentScope", "inFunction", "currentVarScopeFlags", "allowSuper", "currentThisScopeFlags", "inClass", "inClassAndNotInNonArrowFunction", "inStaticBlock", "ScopeFlag", "inNonArrowFunction", "treatFunctionsAsVar", "treatFunctionsAsVarInScope", "createScope", "enter", "exit", "scope", "declareName", "bindingType", "checkRedeclarationInScope", "add", "maybeExportDefined", "delete", "isRedeclaredInScope", "values", "checkLocalExport", "topLevelScope", "FlowScope", "declareFunctions", "FlowScopeHandler", "BaseParser", "sawUnambiguousESM", "ambiguousScriptDifferentAst", "pluginConfig", "plugins", "pluginName", "pluginOptions", "actualOptions", "plugin", "_this$plugins$get", "setTrailingComments", "comments", "trailingComments", "undefined", "unshift", "setLeadingComments", "leadingComments", "setInnerComments", "innerComments", "adjustInnerComments", "elements", "commentWS", "lastElement", "CommentsParser", "addComment", "comment", "processComment", "commentStack", "commentStackLength", "lastCommentWS", "leadingNode", "nodeStart", "commentEnd", "containingNode", "finalizeComment", "splice", "trailingNode", "commentStart", "input", "charCodeAt", "finalizeRemainingComments", "resetPreviousNodeTrailingComments", "resetPreviousIdentifierLeadingComments", "takeSurroundingComments", "lineBreak", "lineBreakG", "isNewLine", "skipWhiteSpace", "skipWhiteSpaceInLine", "skipWhiteSpaceToLineBreak", "isWhitespace", "State", "curLine", "lineStart", "errors", "potentialArrowAt", "noArrowAt", "noArrowParamsConversionAt", "maybeInArrowParameters", "inType", "noAnonFunctionType", "hasFlowComment", "isAmbientContext", "inAbstractClass", "inDisallowConditionalTypesContext", "topicContext", "maxNumOfResolvableTopics", "maxTopicIndex", "soloAwait", "inFSharpPipelineDirectBody", "labels", "lastTokStart", "ct", "canStartJSXElement", "containsEsc", "firstInvalidTemplateEscapePos", "strictErrors", "tokensLength", "init", "strictMode", "sourceType", "startLine", "startColumn", "curPosition", "skipArrays", "val", "slice", "isDigit", "forbiddenNumericSeparatorSiblings", "decBinOct", "hex", "isAllowedNumericSeparatorSibling", "bin", "ch", "oct", "dec", "readStringContents", "initialPos", "initialLineStart", "initialCurLine", "out", "firstInvalidLoc", "chunkStart", "unterminated", "isStringEnd", "res", "readEscapedChar", "str", "containsInvalid", "inTemplate", "throwOnInvalid", "readHexChar", "readCodePoint", "fromCodePoint", "strictNumericEscape", "startPos", "match", "octalStr", "octal", "parseInt", "len", "forceLen", "n", "readInt", "invalidEscapeSequence", "allowNumSeparator", "bailOnError", "forbiddenSiblings", "isAllowedSibling", "invalid", "total", "Infinity", "prev", "numericSeparatorInEscapeSequence", "Number", "isNaN", "unexpectedNumericSeparator", "_isDigit", "invalidDigit", "indexOf", "invalidCodePoint", "buildPosition", "VALID_REGEX_FLAGS", "Token", "Tokenizer", "isLookahead", "errorHandlers_readInt", "errorRecovery", "errorBuilder", "errorHandlers_readCodePoint", "errorHandlers_readStringContents_string", "recordStrictModeErrors", "errorHandlers_readStringContents_template", "pushToken", "checkKeywordEscapes", "nextToken", "eat", "createLookaheadState", "curContext", "lookahead", "old", "curr", "nextTokenStart", "nextTokenStartSince", "lastIndex", "lookaheadCharCode", "nextTokenInLineStart", "nextTokenInLineStartSince", "lookaheadInLineCharCode", "codePointAtPos", "cp", "trail", "setStrict", "forEach", "toParseError", "clear", "skipSpace", "finishToken", "getTokenFromCode", "skipBlockComment", "skipLineComment", "startSkip", "spaceStart", "loop", "attachComment", "annexB", "commentWhitespace", "prevType", "replaceToken", "readToken_numberSign", "readToken_interpreter", "nextPos", "expectPlugin", "readWord1", "finishOp", "readToken_dot", "readNumber", "readToken_slash", "readToken_mult_modulo", "width", "readToken_pipe_amp", "readToken_caret", "proposal", "topicToken", "lookaheadCh", "codePointAt", "readToken_atSign", "readToken_plus_min", "readToken_lt", "readToken_gt", "size", "readToken_eq_excl", "readToken_question", "readTemplateToken", "readRadixNumber", "readString", "readWord", "readRegexp", "escaped", "content", "mods", "char", "includes", "isBigInt", "replace", "startsWithDot", "isFloat", "isDecimal", "hasExponent", "isOctal", "hasLeadingZero", "integer", "underscorePos", "parseFloat", "quote", "readTemplateContinuation", "opening", "firstCode", "escStart", "identifierCheck", "esc", "keywordTypes", "raiseProperties", "raiseOverwrite", "expectOnePlugin", "pluginNames", "some", "ClassScope", "privateNames", "loneAccessors", "undefinedPrivateNames", "ClassScopeHandler", "stack", "oldClassScope", "from", "declarePrivateName", "elementType", "redefined", "accessor", "oldStatic", "newStatic", "oldKind", "newKind", "ExpressionScope", "canBeArrowParameterDeclaration", "isCertainlyParameterDeclaration", "ArrowHeadParsingScope", "declarationErrors", "recordDeclarationError", "ParsingErrorClass", "clearDeclarationError", "iterateErrors", "iterator", "ExpressionScopeHandler", "recordParameterInitializerError", "origin", "recordArrowParameterBindingError", "recordAsyncArrowParametersError", "validateAsPattern", "newParameterDeclarationScope", "newArrowHeadScope", "newAsyncArrowScope", "newExpressionScope", "ProductionParameterHandler", "stacks", "currentFlags", "hasAwait", "hasYield", "hasReturn", "hasIn", "functionFlags", "UtilParser", "addExtra", "isContextual", "isUnparsedContextual", "nameStart", "nameEnd", "nextCh", "isLookaheadContextual", "eatContextual", "expectContextual", "canInsertSemicolon", "hasPrecedingLineBreak", "hasFollowingLineBreak", "isLineTerminator", "semicolon", "allowAsi", "expect", "tryParse", "fn", "oldState", "abortSignal", "failState", "thrown", "aborted", "checkExpressionErrors", "andThrow", "shorthandAssignLoc", "doubleProtoLoc", "privateKeyLoc", "optionalParametersLoc", "hasErrors", "isLiteralPropertyName", "property", "initializeScopes", "oldLabels", "oldExportedIdentifiers", "exportedIdentifiers", "oldInModule", "oldScope", "getScopeHandler", "oldProdParam", "prodParam", "oldExpressionScope", "expressionScope", "enterInitialScopes", "paramFlags", "checkDestructuringPrivate", "ExpressionErrors", "Node", "ranges", "range", "NodePrototype", "prototype", "__clone", "newNode", "clonePlaceholder", "cloneIdentifier", "cloned", "create", "expectedNode", "cloneStringLiteral", "NodeUtils", "startNodeAt", "resetStartLocationFromNode", "locationNode", "reservedTypes", "FlowErrors", "AmbiguousConditionalArrow", "AmbiguousDeclareModuleKind", "AssignReservedType", "reservedType", "DeclareClassElement", "DeclareClassFieldInitializer", "DuplicateDeclareModuleExports", "EnumBooleanMemberNotInitialized", "memberName", "enumName", "EnumDuplicateMemberName", "EnumInconsistentMemberValues", "EnumInvalidExplicitType", "invalidEnumType", "EnumInvalidExplicitTypeUnknownSupplied", "EnumInvalidMemberInitializerPrimaryType", "explicitType", "EnumInvalidMemberInitializerSymbolType", "EnumInvalidMemberInitializerUnknownType", "EnumInvalidMemberName", "suggestion", "EnumNumberMemberNotInitialized", "EnumStringMemberInconsistentlyInitialized", "GetterMayNotHaveThisParam", "ImportReflectionHasImportType", "ImportTypeShorthandOnlyInPureImport", "InexactInsideExact", "InexactInsideNonObject", "InexactVariance", "InvalidNonTypeImportInDeclareModule", "MissingTypeParamDefault", "NestedDeclareModule", "NestedFlowComment", "PatternIsOptional", "SetterMayNotHaveThisParam", "SpreadVariance", "ThisParamAnnotationRequired", "ThisParamBannedInConstructor", "ThisParamMayNotBeOptional", "ThisParamMustBeFirst", "ThisParamNoDefault", "TypeBeforeInitializer", "TypeCastInPattern", "UnexpectedExplicitInexactInObject", "UnexpectedReservedType", "UnexpectedReservedUnderscore", "UnexpectedSpaceBetweenModuloChecks", "UnexpectedSpreadType", "UnexpectedSubtractionOperand", "UnexpectedTokenAfterTypeParameter", "UnexpectedTypeParameterBeforeAsyncArrowFunction", "UnsupportedDeclareExportKind", "unsupportedExportKind", "UnsupportedStatementInDeclareModule", "UnterminatedFlowComment", "isEsModuleType", "bodyElement", "hasTypeImportKind", "importKind", "exportSuggestions", "const", "let", "interface", "partition", "list", "list1", "list2", "FLOW_PRAGMA_REGEX", "flow", "FlowParserMixin", "flowPragma", "shouldParseTypes", "shouldParseEnums", "matches", "exec", "Error", "flowParseTypeInitialiser", "tok", "oldInType", "flowParseType", "flowParsePredicate", "moduloLoc", "parseExpression", "flowParseTypeAndPredicateInitialiser", "predicate", "flowParseDeclareClass", "flowParseInterfaceish", "flowParseDeclareFunction", "parseIdentifier", "typeNode", "typeContainer", "flowParseTypeParameterDeclaration", "tmp", "flowParseFunctionTypeParams", "this", "returnType", "typeAnnotation", "flowParseDeclare", "insideModule", "flowParseDeclareVariable", "flowParseDeclareModuleExports", "flowParseDeclareModule", "flowParseDeclareTypeAlias", "flowParseDeclareOpaqueType", "flowParseDeclareInterface", "flowParseDeclareExportDeclaration", "flowParseTypeAnnotatableIdentifier", "parseExprAtom", "bodyNode", "parseImport", "hasModuleExport", "default", "isLet", "exportKind", "flowParseTypeAnnotation", "finished", "flowParseTypeAlias", "flowParseOpaqueType", "isClass", "flowParseRestrictedIdentifier", "extends", "flowParseInterfaceExtends", "implements", "mixins", "flowParseObjectType", "allowStatic", "allowExact", "allowSpread", "allowProto", "allowInexact", "flowParseQualifiedTypeIdentifier", "flowParseTypeParameterInstantiation", "flowParseInterface", "checkNotUnderscore", "checkReservedType", "liberal", "right", "declare", "supertype", "impltype", "flowParseTypeParameter", "requireDefault", "nodeStartLoc", "variance", "flowParseVariance", "ident", "bound", "defaultRequired", "typeParameter", "oldNoAnonFunctionType", "flowParseTypeParameterInstantiationCallOrNew", "flowParseTypeOrImplicitInstantiation", "flowParseInterfaceType", "flowParseObjectPropertyKey", "flowParseObjectTypeIndexer", "isStatic", "static", "flowParseObjectTypeInternalSlot", "flowParseObjectTypeMethodish", "flowParseFunctionTypeParam", "flowParseObjectTypeCallProperty", "valueNode", "callProperties", "indexers", "internalSlots", "endDelim", "exact", "inexact", "protoStartLoc", "inexactStartLoc", "propOrInexact", "flowParseObjectTypeProperty", "flowObjectTypeSemicolon", "isInexactToken", "proto", "flowCheckGetterSetterParams", "paramCount", "_startLoc", "node2", "qualification", "flowParseGenericType", "flowParseTypeofType", "flowParsePrimaryType", "flowParseTupleType", "first", "lh", "isThis", "reinterpretTypeAsFunctionTypeParam", "flowIdentToTypeAnnotation", "isGroupedType", "parseLiteralAtNode", "createIdentifier", "flowParsePostfixType", "seenOptionalIndexedAccess", "objectType", "indexType", "flowParsePrefixType", "flowParseAnonFunctionWithoutParens", "param", "flowParseIntersectionType", "flowParseUnionType", "allowPrimitiveOverride", "typeCastToParameter", "allowExpressionBody", "forwardNoArrowParamsConversionAt", "parseFunctionBodyAndFinish", "parseStatementLike", "flowParseEnumDeclaration", "parseExpressionStatement", "expr", "shouldParseExportDeclaration", "isExportDefaultSpecifier", "parseExportDefaultExpression", "parseConditional", "setOptionalParametersError", "originalNoArrowAt", "consequent", "failed", "tryParseConditionalConsequent", "valid", "getArrowLikeExpressions", "alternate", "parseMaybeAssign", "parseMaybeAssignAllowIn", "disallowInvalid", "arrows", "finishArrowValidation", "every", "_node$extra", "toAssignableList", "trailingCommaLoc", "checkParams", "result", "parseParenItem", "typeCastNode", "assertModuleNodeAllowed", "parseExportDeclaration", "declarationNode", "parseExportSpecifiers", "parseExportFrom", "eatExportStar", "maybeParseExportNamespaceSpecifier", "hasNamespace", "parseClassId", "isStatement", "optionalId", "parseClassMember", "member", "parseClassMemberFromModifier", "isIterator", "readIterator", "fullWord", "left", "exprList", "toReferencedList", "isParenthesizedExpr", "_expr$extra", "parseArrayLike", "close", "canBePattern", "isTuple", "isParenthesized", "isClassMethod", "isClassProperty", "isNonstaticConstructor", "isThisParam", "pushClassPrivateMethod", "parseClassSuper", "superTypeParameters", "implemented", "checkGetterSetterParams", "parsePropertyNamePrefixOperator", "parseObjPropValue", "parseAssignableListItemTypes", "parseMaybeDefault", "checkImportReflection", "module", "parseImportSpecifierLocal", "specifier", "local", "finishImportSpecifier", "isPotentialImportPhase", "isExport", "applyImportPhase", "parseImportSpecifier", "importedIsString", "isInTypeOnlyImport", "isMaybeTypeOnly", "firstIdent", "imported", "specifierTypeKind", "as_ident", "specifierIsTypeImport", "checkReservedWord", "parseBindingAtom", "parseFunctionParams", "parseVarId", "decl", "parseAsyncArrowFromCallExpression", "call", "shouldParseAsyncArrow", "afterLeftParse", "_jsx", "jsx", "currentContext", "_jsx2", "_jsx3", "abort", "_arrowExpression$extr", "arrowExpression", "maybeUnwrapTypeCastExpression", "async", "parseArrow", "shouldParseArrow", "setArrowFunctionParameters", "allowDuplicates", "isArrowFunction", "strictModeChanged", "parseParenAndDistinguishExpression", "canBeArrow", "parseSubscripts", "parseCallExpressionArguments", "parseAsyncArrowWithTypeParameters", "subscriptState", "isLookaheadToken_lt", "typeArguments", "parseNewCallee", "targs", "parseArrowExpression", "parseTopLevel", "program", "fileNode", "skipFlowComment", "hasFlowCommentCompletion", "commentSkip", "shiftToFirstNonWhiteSpace", "ch2", "ch3", "flowEnumErrorBooleanMemberNotInitialized", "flowEnumErrorInvalidMemberInitializer", "enumContext", "flowEnumErrorNumberMemberNotInitialized", "flowEnumErrorStringMemberInconsistentlyInitialized", "flowEnumMemberInit", "endOfInit", "literal", "flowEnumMemberRaw", "flowEnumCheckExplicitTypeMismatch", "expectedType", "flowEnumMembers", "seenNames", "members", "booleanMembers", "numberMembers", "stringMembers", "defaultedMembers", "hasUnknownMembers", "memberNode", "toUpperCase", "flowEnumStringMembers", "initializedMembers", "flowEnumParseExplicitType", "flowEnumBody", "nameLoc", "empty", "boolsLen", "numsLen", "strsLen", "defaultedLen", "afterNext", "entities", "__proto__", "quot", "amp", "apos", "nbsp", "iexcl", "cent", "pound", "curren", "yen", "brvbar", "sect", "uml", "copy", "ordf", "laquo", "not", "shy", "reg", "macr", "deg", "plusmn", "sup2", "sup3", "acute", "micro", "para", "middot", "cedil", "sup1", "ordm", "raquo", "frac14", "frac12", "frac34", "iquest", "Agrave", "Aacute", "Acirc", "Atilde", "Auml", "Aring", "AElig", "Ccedil", "Egrave", "Eacute", "Ecirc", "Euml", "Igrave", "Iacute", "Icirc", "Iuml", "ETH", "Ntilde", "Ograve", "Oacute", "Ocirc", "Otilde", "Ouml", "times", "Oslash", "Ugrave", "Uacute", "Ucirc", "Uuml", "Yacute", "THORN", "szlig", "agrave", "aacute", "acirc", "atilde", "auml", "aring", "aelig", "ccedil", "egrave", "eacute", "ecirc", "euml", "igrave", "iacute", "icirc", "iuml", "eth", "ntilde", "ograve", "oacute", "ocirc", "otilde", "ouml", "divide", "oslash", "ugrave", "uacute", "ucirc", "uuml", "yacute", "thorn", "yuml", "OElig", "oelig", "Scaron", "scaron", "Yuml", "fnof", "circ", "Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu", "Xi", "Omicron", "Pi", "Rho", "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega", "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigmaf", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega", "thetasym", "upsih", "piv", "ensp", "emsp", "thinsp", "zwnj", "zwj", "lrm", "rlm", "ndash", "mdash", "lsquo", "rsquo", "sbquo", "ldquo", "rdquo", "bdquo", "dagger", "Dagger", "bull", "hellip", "permil", "prime", "Prime", "lsaquo", "rsaquo", "oline", "frasl", "euro", "image", "weierp", "real", "trade", "alefsym", "larr", "uarr", "rarr", "darr", "harr", "crarr", "lArr", "uArr", "rArr", "dArr", "hArr", "forall", "part", "exist", "nabla", "isin", "notin", "ni", "prod", "sum", "minus", "lowast", "radic", "infin", "ang", "and", "or", "cap", "cup", "int", "there4", "sim", "cong", "asymp", "ne", "equiv", "le", "ge", "sub", "sup", "nsub", "sube", "supe", "oplus", "otimes", "perp", "sdot", "lceil", "rceil", "lfloor", "rfloor", "lang", "rang", "loz", "spades", "clubs", "hearts", "diams", "JsxErrors", "AttributeIsEmpty", "MissingClosingTagElement", "openingTagName", "MissingClosingTagFragment", "UnexpectedSequenceExpression", "HTMLEntity", "UnsupportedJsxValue", "UnterminatedJsxContent", "UnwrappedAdjacentJSXElements", "isFragment", "getQualifiedJSXName", "namespace", "JSXParserMixin", "jsxReadToken", "jsxReadEntity", "jsxReadNewLine", "normalizeCRLF", "jsxReadString", "codePoint", "count", "desc", "entity", "XHTMLEntities", "jsxReadWord", "jsxParseIdentifier", "jsxParseNamespacedName", "jsxParseElementName", "jsxParseAttributeValue", "setContext", "jsxParseExpressionContainer", "jsxParseEmptyExpression", "jsxParseSpreadChild", "previousContext", "jsxParseAttribute", "jsxParseOpeningElementAt", "jsxParseOpeningElementAfterName", "selfClosing", "jsxParseClosingElementAt", "jsxParseElementAt", "children", "openingElement", "closingElement", "contents", "openingFragment", "closingFragment", "jsxParseElement", "newContext", "TypeScriptScope", "enums", "constEnums", "classes", "exportOnlyBindings", "TypeScriptScopeHandler", "importsStack", "hasImport", "allowShadow", "isConst", "wasConst", "getOwn", "hasOwnProperty", "unwrapParenthesizedExpression", "LValParser", "_node$extra3", "last", "_node$extra2", "operator", "arg", "checkToRestConversion", "elt", "element", "toReferencedListDeep", "parseSpread", "parseRestBinding", "parseBindingList", "ParseBindingListFlags", "parseObjectLike", "closeCharCode", "allowEmpty", "elts", "checkCommaAfterRest", "parseDecorator", "parseAssignableListItem", "parseBindingRestProperty", "parseBindingProperty", "parsePropertyName", "_left", "ObjectProperty", "checkLVal", "in", "checkClashes", "hasParenthesizedAncestor", "_expression$extra", "checkIdentifier", "validity", "ParseErrorClass", "isParenthesizedExpression", "nextAncestor", "child", "declareNameFromIdentifier", "identifier", "allowPattern", "nonNull", "x", "assert", "TSErrors", "AbstractMethodHasImplementation", "methodName", "AbstractPropertyHasInitializer", "propertyName", "AccesorCannotDeclareThisParameter", "AccesorCannotHaveTypeParameters", "AccessorCannotBeOptional", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", "ConstructorHasTypeParameters", "DeclareAccessor", "DeclareClassFieldHasInitializer", "DeclareFunctionHasImplementation", "DuplicateAccessibilityModifier", "modifier", "DuplicateModifier", "EmptyHeritageClauseType", "EmptyTypeArguments", "EmptyTypeParameters", "ExpectedAmbientAfterExportDeclare", "ImportAliasHasImportType", "IncompatibleModifiers", "modifiers", "IndexSignatureHasAbstract", "IndexSignatureHasAccessibility", "IndexSignatureHasDeclare", "IndexSignatureHasOverride", "IndexSignatureHasStatic", "InitializerNotAllowedInAmbientContext", "InvalidModifierOnTypeMember", "InvalidModifierOnTypeParameter", "InvalidModifierOnTypeParameterPositions", "InvalidModifiersOrder", "orderedModifiers", "InvalidPropertyAccessAfterInstantiationExpression", "InvalidTupleMemberLabel", "MissingInterfaceName", "NonAbstractClassHasAbstractMethod", "NonClassMethodPropertyHasAbstractModifer", "OptionalTypeBeforeRequired", "OverrideNotInSubClass", "PrivateElementHasAbstract", "PrivateElementHasAccessibility", "ReadonlyForMethodSignature", "ReservedArrowTypeParam", "ReservedTypeAssertion", "SetAccesorCannotHaveOptionalParameter", "SetAccesorCannotHaveRestParameter", "SetAccesorCannotHaveReturnType", "SingleTypeParameterWithoutTrailingComma", "typeParameterName", "StaticBlockCannotHaveModifier", "TupleOptionalAfterType", "TypeAnnotationAfterAssign", "TypeImportCannotSpecifyDefaultAndNamed", "TypeModifierIsUsedInTypeExports", "TypeModifierIsUsedInTypeImports", "UnexpectedParameterModifier", "UnexpectedReadonly", "UnexpectedTypeAnnotation", "UnexpectedTypeCastInParameter", "UnsupportedImportTypeArgument", "UnsupportedParameterPropertyKind", "UnsupportedSignatureParameterKind", "keywordTypeFromName", "tsIsAccessModifier", "tsIsVarianceAnnotations", "typescript", "TypeScriptParserMixin", "tsParseInOutModifiers", "tsParseModifiers", "bind", "allowedModifiers", "disallowedModifiers", "errorTemplate", "tsParseConstModifier", "tsParseInOutConstModifiers", "tsIsIdentifier", "tsTokenCanFollowModifier", "tsNextTokenCanFollowModifier", "tsParseModifier", "stopOnStartOfClassStaticBlock", "tsIsStartOfStaticBlocks", "tsTryParse", "modified", "enforceOrder", "before", "after", "incompatible", "mod1", "mod2", "accessibility", "tsIsListTerminator", "tsParseList", "parseElement", "tsParseDelimitedList", "refTrailingCommaPos", "tsParseDelimitedListWorker", "expectSuccess", "trailingCommaPos", "tsParseBracketedList", "bracket", "skipFirstToken", "tsParseImportType", "qualifier", "tsParseEntityName", "tsParseTypeArguments", "allowReservedWords", "tsParseTypeReference", "typeName", "tsParseThisTypePredicate", "lhs", "parameterName", "tsParseTypeAnnotation", "asserts", "tsParseThisTypeNode", "tsParseTypeQuery", "exprName", "tsParseTypeParameter", "parseModifiers", "tsParseTypeParameterName", "constraint", "tsEatThenParseType", "tsTryParseTypeParameters", "tsParseTypeParameters", "tsFillSignature", "returnToken", "signature", "returnTokenRequired", "paramsKey", "returnTypeKey", "tsParseBindingListForSignature", "tsParseTypeOrTypePredicateAnnotation", "tsParseTypeMemberSemicolon", "tsParseSignatureMember", "tsIsUnambiguouslyIndexSignature", "tsTryParseIndexSignature", "tsLookAhead", "parameters", "tsTryParseTypeAnnotation", "tsParsePropertyOrMethodSignature", "readonly", "nodeAny", "firstParameter", "tsParseTypeMember", "idx", "tsParseTypeLiteral", "tsParseObjectTypeMembers", "tsIsStartOfMappedType", "tsParseMappedTypeParameter", "tsExpectThenParseType", "tsParseMappedType", "nameType", "tsParseType", "tsTryParseType", "tsParseTupleType", "elementTypes", "tsParseTupleElementType", "seenOptionalElement", "elementNode", "labeled", "isWord", "chAfterWord", "wordName", "typeOrLabel", "tsParseNonArrayType", "labeledNode", "optionalTypeNode", "restNode", "tsParseParenthesizedType", "tsParseFunctionOrConstructorType", "abstract", "tsInAllowConditionalTypesContext", "tsParseLiteralTypeNode", "tsParseTemplateLiteralType", "parseTemplate", "parseTemplateSubstitution", "tsParseThisTypeOrThisTypePredicate", "thisKeyword", "parseMaybeUnary", "nodeType", "tsParseArrayTypeOrHigher", "tsParseTypeOperator", "tsParseTypeOperatorOrHigher", "tsCheckTypeAnnotationForReadOnly", "tsParseInferType", "tsParseConstraintForInferType", "tsInDisallowConditionalTypesContext", "isTypeOperator", "tsParseUnionOrIntersectionType", "parseConstituentType", "hasLeadingOperator", "tsParseIntersectionTypeOrHigher", "tsParseUnionTypeOrHigher", "tsIsStartOfFunctionType", "tsIsUnambiguouslyStartOfFunctionType", "tsSkipParameterStart", "previousErrorCount", "_unused2", "tsInType", "t", "tsParseTypePredicateAsserts", "thisTypePredicate", "typePredicateVariable", "tsParseTypePredicatePrefix", "tsTryParseTypeOrTypePredicateAnnotation", "eatColon", "tsParseNonConditionalType", "checkType", "extendsType", "trueType", "falseType", "isAbstractConstructorSignature", "tsParseTypeAssertion", "tsParseHeritageClause", "originalStartLoc", "delimitedList", "tsParseInterfaceDeclaration", "tsParseTypeAliasDeclaration", "tsInNoContext", "cb", "oldContext", "oldInDisallowConditionalTypesContext", "tsNextThenParseType", "tsParseEnumMember", "initializer", "tsParseEnumDeclaration", "tsParseModuleBlock", "parseBlockOrModuleBlockBody", "tsParseModuleOrNamespaceDeclaration", "nested", "inner", "tsParseAmbientExternalModuleDeclaration", "global", "tsParseImportEqualsDeclaration", "maybeDefaultIdentifier", "moduleReference", "tsParseModuleReference", "tsIsExternalModuleReference", "tsParseExternalModuleReference", "f", "tsTryParseAndCatch", "tsTryParseDeclare", "nany", "startType", "tsInAmbientContext", "parseFunctionStatement", "parseClass", "parseVarStatement", "tsParseDeclaration", "tsTryParseExportDeclaration", "tsParseExpressionStatement", "mod", "tsCheckLineTerminator", "tsParseAbstractDeclaration", "tsTryParseGenericAsyncArrowFunction", "oldMaybeInArrowParameters", "tsParseTypeArgumentsInExpression", "reScan_lt", "reScan_lt_gt", "tsIsDeclarationStart", "override", "pp", "parameter", "isSimpleParameter", "tsDisallowOptionalPattern", "bodilessType", "registerFunctionStatementId", "tsCheckForInvalidTypeCasts", "items", "isInParens", "nonNullExpression", "isOptionalCall", "missingParenErrorLoc", "atPossibleAsyncArrow", "asyncArrowFn", "parseTaggedTemplateExpression", "tokenType", "_callee$extra", "parseExprOp", "leftStartLoc", "minPrec", "isSatisfies", "checkKeywords", "checkDuplicateExports", "importNode", "parseMaybeImportPhase", "parseImportSpecifiersAndAfter", "isAbstractClass", "cls", "allowMissingInitializer", "declarations", "isValidAmbientConstInitializer", "parseStatementContent", "parseAccessModifier", "tsHasSomeModifiers", "callParseClassMemberWithIsStatic", "parseClassStaticBlock", "parseClassMemberWithIsStatic", "hadSuperClass", "parsePostMemberNameModifiers", "methodOrProp", "isDeclare", "isIdentifier", "parseClassPropertyAnnotation", "definite", "parseClassAccessorProperty", "declareClassPrivateMethodInScope", "_typeCast", "_typeCast2", "typeCast", "_typeParameters", "reportReservedArrowTypeParam", "trailingComma", "sawUnary", "toAssignableParenthesizedExpression", "TSTypeCastExpression", "TSParameterProperty", "TSNonNullExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "parseMaybeDecoratorArguments", "canHaveLeadingDecorator", "getGetterSetterExpectedParamCount", "baseCount", "firstParam", "hasContextParam", "parseCatchClauseParam", "oldIsAmbientContext", "oldInAbstractClass", "maybeTakeDecorators", "hasBody", "shouldParseAsAmbientContext", "getExpression", "parseExportSpecifier", "isString", "isInTypeExport", "parseTypeOnlyImportExportSpecifier", "isImport", "isInTypeOnlyImportExport", "leftOfAsKey", "rightOfAsKey", "leftOfAs", "rightOfAs", "hasTypeSpecifier", "canParseAsKeyword", "firstAs", "secondAs", "parseModuleExportName", "kindKey", "isPossiblyLiteralEnum", "expressions", "isUncomputedMemberExpressionChain", "isNumber", "isNegativeNumber", "PlaceholderErrors", "ClassNameIsRequired", "UnexpectedSpace", "placeholders", "PlaceholdersParserMixin", "parsePlaceholder", "assertNoSpace", "finishPlaceholder", "isFinished", "chStartsBindingIdentifier", "verifyBreakContinue", "isBreak", "parseStatementOrSloppyAnnexBFunctionDeclaration", "parseBlock", "createNewLexicalScope", "parseFunctionId", "requireId", "oldStrict", "parseClassBody", "startsWith", "maybeParseExportDefaultSpecifier", "_specifiers", "checkExport", "filter", "hasStarImport", "maybeParseStarImportSpecifier", "parseNamedImportSpecifiers", "parseImportSource", "v8intrinsic", "V8IntrinsicMixin", "parseV8Intrinsic", "v8IntrinsicStartLoc", "parseIdentifierName", "expectedConfig", "expectedName", "expectedOptions", "expectedKeys", "expectedOptionsIsEmpty", "p", "option", "find", "PIPELINE_PROPOSALS", "TOPIC_TOKENS", "RECORD_AND_TUPLE_SYNTAX_TYPES", "validatePlugins", "decoratorsBeforeExport", "allowCallParenthesized", "proposalList", "tupleSyntaxIsHash", "syntaxType", "tokenList", "moduleAttributesVersionPluginOption", "missingPlugins", "mixinPlugins", "mixinPluginNames", "defaultOptions", "sourceFilename", "allowAwaitOutsideFunction", "allowReturnOutsideFunction", "allowNewTargetOutsideFunction", "allowImportExportEverywhere", "allowSuperOutsideMethod", "allowUndeclaredExports", "createImportExpressions", "createParenthesizedExpressions", "getOptions", "opts", "_opts$key", "ExpressionParser", "checkProto", "isRecord", "protoRef", "used", "shouldExitDescending", "disallowIn", "disallowInAnd", "parseExpressionBase", "allowInAnd", "parseMaybeAssignDisallowIn", "resultError", "_resultError$loc", "parseYield", "ownExpressionErrors", "parseMaybeConditional", "startIndex", "parseExprOps", "parseMaybeUnaryOrPrivate", "op", "prec", "checkPipelineAtInfixOperator", "logical", "coalesce", "parseExprOpRightExpr", "finishedNode", "nextOp", "withTopicBindingContext", "parseHackPipeBody", "parseSmartPipelineBodyInStyle", "parseExprOpBaseRightExpr", "withSoloAwaitPermittingContext", "parseFSharpPipelineBody", "_body$extra", "requiredParentheses", "topicReferenceWasUsedInCurrentContext", "checkExponentialAfterUnary", "isAwait", "isAwaitAllowed", "parseAwait", "update", "isDelete", "parseUpdate", "isAmbiguousAwait", "updateExpressionNode", "parseExprSubscripts", "maybeAsyncArrow", "parseBind", "parseCoverCallAndAsyncArrowHead", "parseMember", "parseNoCallExpr", "tag", "quasi", "expectImportAttributesPlugin", "dynamicImport", "allowPlaceholder", "nodeForExtra", "oldInFSharpPipelineDirectBody", "addTrailingCommaExtraToNode", "parseExprListItem", "_call$extra", "parseSuper", "parseImportMetaProperty", "parseImportCall", "parseDo", "parseFunctionOrFunctionSent", "parseDecorators", "parseNewOrNewTarget", "parseTopicReferenceThenEqualsSign", "parseTopicReference", "pipeProposal", "parseModuleExpression", "parseAsyncFunctionExpression", "parseAsyncArrowUnaryFunction", "topicTokenType", "topicTokenValue", "finishTopicReference", "testTopicReferenceConfiguration", "topicReferenceIsAllowedInCurrentContext", "registerTopicReference", "meta", "parseMetaProperty", "parseFunction", "isSource", "innerStartLoc", "spreadStartLoc", "optionalCommaStartLoc", "spreadNodeStartLoc", "innerEndLoc", "arrowNode", "wrapParenthesis", "parenExpression", "metaProp", "parseNew", "parseExprList", "parseTemplateElement", "isTagged", "elemStart", "elem", "isTail", "endOffset", "elemEnd", "cooked", "tail", "curElt", "quasis", "propHash", "parsePropertyDefinition", "maybeAsyncOrAccessorProp", "keyName", "_params", "finishedProp", "generator", "isExpression", "hasStrictModeDirective", "nonSimple", "isSimpleParamList", "formalParameters", "reservedTest", "delegating", "delegate", "childExpr", "isSimpleReference", "checkSmartPipeTopicBodyEarlyErrors", "callback", "outerContextTopicState", "withSmartMixTopicForbiddingContext", "outerContextSoloAwaitState", "prodParamToSet", "ParamKind", "prodParamToClear", "ret", "revertScopes", "parseProgram", "loopLabel", "switchLabel", "loneSurrogate", "keywordRelationalOperator", "babel7CompatTokens", "hashEndPos", "hashEndLoc", "backquoteEnd", "backquoteEndLoc", "startToken", "templateValue", "templateElementEnd", "templateElementEndLoc", "endToken", "StatementParser", "interpreter", "parseInterpreterDirective", "finishedProgram", "stmtToDirective", "directiveLiteral", "hasFollowingBindingAtom", "endCh", "chStartsBindingPattern", "hasInLineFollowingBindingIdentifier", "startsUsingForOf", "startsAwaitUsing", "parseModuleItem", "ParseStatementFlag", "parseStatementListItem", "allowLabeledFunction", "parseStatement", "starttype", "allowDeclaration", "allowFunctionDeclaration", "parseBreakContinueStatement", "parseDebuggerStatement", "parseDoWhileStatement", "parseForStatement", "parseIfStatement", "parseReturnStatement", "parseSwitchStatement", "parseThrowStatement", "parseTryStatement", "parseWhileStatement", "parseWithStatement", "parseEmptyStatement", "nextTokenCharCode", "isAsyncFunction", "maybeName", "parseLabeledStatement", "decoratorsEnabledBeforeExport", "maybeDecorators", "classNode", "exportNode", "allowExport", "paramsStartLoc", "lab", "parseHeaderExpression", "awaitAt", "parseFor", "startsWithLet", "startsWithAwaitUsing", "starsWithUsingDeclaration", "isLetOrUsing", "initNode", "parseVar", "isForIn", "parseForIn", "startsWithAsync", "isForOf", "isHangingDeclaration", "ParseFunctionFlag", "discriminant", "cases", "cur", "sawDefault", "isCase", "block", "handler", "clause", "finalizer", "statementStart", "parsedNonDirective", "await", "isFor", "hangingDeclaration", "isDeclaration", "hadConstructor", "publicMethod", "privateMethod", "publicProp", "privateProp", "accessorProp", "publicMember", "parseClassElementName", "isPrivate", "maybeQuestionTokenStartLoc", "pushClassPrivateProperty", "pushClassProperty", "pushClassAccessorProperty", "_member$decorators", "parseInitializer", "hasDefault", "parseAfterDefault", "hasStar", "parseAfterNamespace", "isFromRequired", "hasSpecifiers", "maybeParseExportNamedSpecifiers", "hasDeclaration", "maybeParseExportDeclaration", "_node2$declaration", "isTypeExport", "assertions", "nextType", "hasFrom", "nextAfterFrom", "maybeParseImportAttributes", "checkJSONModuleImport", "checkNames", "isDefault", "isFrom", "_node$specifiers", "_declaration$extra", "nodes", "surrogate", "isJSONModuleImport", "singleBindingType", "_node$assertions", "nonDefaultNamedSpecifier", "phaseIdentifier", "isImportPhase", "isPrecedingIdImportPhase", "parseImportSourceAndAttributes", "maybeParseDefaultImportSpecifier", "parseNext", "_node$specifiers2", "parseImportAttributes", "attrs", "attrNames", "parseModuleAttributes", "useWith", "importSpecifier", "Parser", "pluginsMap", "pluginMap", "_options", "getParser", "ast", "moduleError", "generateExportedTokenTypes", "internalTokenTypes", "tokTypes", "getParserClass", "parserClassCache", "pluginsFromOptions", "pluginList", "normalize", "has", "set", "SourceMapGenerator", "sourceFile", "map", "comparator", "p", "version", "needle", "section", "SourceMapGenerator", "map", "ReactiveEffect", "computed", "warn", "TrackOpTypes", "TriggerOpTypes", "map", "val", "last", "effect", "effect", "ReactiveEffect", "effect", "last", "shouldTrack", "key", "effect", "hasOwnProperty", "isReadonly", "isReadonly", "isShallow", "has", "get", "mutableInstrumentations", "shallowInstrumentations", "readonlyInstrumentations", "shallowReadonlyInstrumentations", "isReadonly", "ref", "get", "set", "isReadonly", "ReactiveEffect", "self", "NOOP", "warn", "last", "ErrorCodes", "warn", "p", "seen", "NOOP", "warn", "version", "DeprecationTypes", "emit", "warn", "isModelListener", "raw", "Component", "emit", "render", "warn", "effect", "warn", "ReactiveEffect", "seen", "warn", "warn", "callHook", "hook", "remove", "key", "vnode", "resolve", "warn", "ref", "instance", "warn", "p", "warn", "isInSSRComponentSetup", "Component", "warn", "warn", "warn", "warn", "isFunction", "warn", "has", "warn", "p", "warn", "render", "get", "set", "computed", "h", "render", "hydrate", "createApp", "warn", "warn", "isOn", "raw", "warn", "warn", "ref", "warn", "patchProp", "remove", "hydrate", "warn", "ref", "isTemplateNode", "hasWarned", "next", "parentNode", "queuePostFlushCb", "ref", "warn", "effect", "ReactiveEffect", "needTransition", "remove", "render", "hydrate", "p", "SuspenseImpl", "remove", "vnode", "parentComponent", "container", "anchor", "isSVG", "parentSuspense", "warn", "warn", "container", "anchor", "ref", "warn", "warn", "ref", "uid", "emit", "getGlobalThis", "warn", "isInSSRComponentSetup", "Component", "computed", "isInSSRComponentSetup", "warn", "computed", "render", "callHook", "h", "resolve", "warn", "warn", "isBoolean", "compatUtils", "DeprecationTypes", "warn", "e", "hydrate", "warn", "resolve", "def", "getCurrentInstance", "warn", "enterCbKey", "warn", "warn", "matches", "isArray", "compatUtils", "DeprecationTypes", "warn", "isComponent", "isVNode", "isComponent", "p", "p", "p", "p", "match", "loc", "isComponent", "i", "returnType", "p", "hoistStatic", "isVNode", "i", "matches", "advancePositionWithMutation", "locStub", "RESOLVE_FILTER", "isText", "isComponent", "p", "walk", "walk", "p", "import_parser", "node", "isReferenced", "last", "source", "processExpression", "processExpression", "range", "i", "children", "node", "isComponent", "isComponent", "arg", "checkCompatEnabled", "CompilerDeprecationTypes", "isCompatEnabled", "props", "mergeAsArray", "p", "processExpression", "hasScopeRef", "p", "p", "seen", "TRANSITION", "TRANSITION", "p", "ErrorCodes", "transformModel", "p", "transformOn", "TRANSITION", "p", "transformModel", "transformOn", "compile", "warn", "compile", "render"]
}
